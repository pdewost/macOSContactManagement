-- ==============================================
-- MODULE: ContactManager
--  VERSION: 0.9.8 (2025-06-09)
-- ==============================================
-- Copyright: ©Philippe Dewost 2025
-- Main orchestrator for the CCC Contact Cleaner system.
--
-- ==============================================
-- CHANGELOG
-- ==============================================
-- 0.9.9 Fixed the Unified Logging System for proper, consistant, console log and session log file
-- 0.9.7 (2025-06-10)
--	• Decommissionning of v1 pipeline
--	• 
-- 0.9.6-alpha  (2025-06-04)
--	• Started decommissionning v1 pipeline
--   0.9.4-alpha (2025-05-24):
--     • Header audit, pipeline orchestration mapping, no functional changes.
--     • Confirmed UI/pipeline branching, validated session management calls.
--   0.9.0-alpha4 (2025-05-21): 
--     • Pipeline debug and propagation tested, all upstream handlers robust.
--     • Integration with robust Utilities and Contact Operations modules.
--      0.9.0-alpha3 (2025-05-21)
--          * Session/backup folder names now use zero-padded timestamps (no seconds)
--          * All file/report/backup exports unified through Utilities (no seconds in any filenames)
--          * Logging, error handling, and backup coordination robust and standardized
--          * Parameter passing fixed for all report/backup handlers (no -1721 errors)
--      0.9.0-alpha2 (2025-05-20)
--          * v2 pipeline integration, statistics export, and session reporting
--          * Unified Utilities script for file/folder/backup/manifest actions
--      0.9.0-alpha1 (2025-05-18)
-- * Added support for unified contact processing architecture
-- * Updated pipeline toggle system to support refactored code
-- * Enhanced pipeline comparison functions
-- * Improved logs for better debugging and pipeline isolation
--
-- ==============================================
--  FEATURE REQUESTS / NEXT STEPS
-- ==============================================
--   * Reorganize code around human / AI readable blocks without changing anything
--    * Remove references to the v1 v2 pipeline selection
--      * Menu/UX redesign to flat, list-based selection (no nested dialog traps)
--      * Investigate/fix block deduplication warning
--      * QA: simulated/real contact runs, result report, finalize test coverage
--
-- ==============================================
-- TARGET IDEAS / GRAND SCHEME OF THINGS
-- ==============================================
-- * Groups as Finder tags in exported vCards
-- * Automatic security tagging based on note contents
-- * Remove hard-coded debugMode/testMode defaults before release
-- * Finish CLI automation entry-point parity with UX flow
-- * Add dialog window titles when they are missing and remove them from dialog text
-- * Improve error visualization for contact modification failures
-- * restructure the script in human readable blocks
-- * v2 : extend script functionalities to export Contact Names and companies along with notes to a .txt file that can be used in NoteBookLM to compile ToDo lists from 'ToDo' tags, generate statistics, etc... [OPTION] create ToDos in Calendar ToDo with a link to the originating contact
-- * v2 : same principle for Calendar export allowing to cross event notes content with contacts
-- * v2 : same principle for "Notes" export
--
-- ==============================================
-- KNOWN ISSUES
-- ==============================================
--      * Menu navigation to be simplified in next session
--
-- ==============================================
-- CORE HANDLERS & STATUS
-- ==============================================
-- run() - Main entry point
-- initializeSystem() - Sets up the environment
-- showMainMenu() - Displays main menu interface
-- handleContactCleaning() - Launches note deduplication workflow

(*
Detailed Rationale for Regrouping:
1. Module Core & Configuration (Block 1)
Purpose: Centralizes all system-wide configuration and version management
Benefits:

Easy to find version information
Configuration changes in one place
Clear separation of constants from logic

2. Logging System Interface (Block 2)
Purpose: Provides clean logging facade for entire application
Benefits:

Single point for logging policy changes
Easy to replace logging implementation
Clear separation from business logic

3. System Lifecycle Management (Block 3)
Purpose: Manages application startup/shutdown sequence
Benefits:

Clear initialization order
Easy to debug startup issues
Single point for system state management

4. Core User Interface Flow (Block 4)
Purpose: Main user interaction pathways
Benefits:

Clear user flow understanding
Easy to modify main workflows
Separation of primary vs. secondary features

5. Tools & Configuration Menus (Block 5)
Purpose: Advanced features and system configuration
Benefits:

Groups related administrative functions
Separates power-user features from basic workflow
Easy to extend with new tools

6. Backup & Recovery System (Block 6)
Purpose: Data protection and recovery operations
Benefits:

Groups related data safety functions
Clear separation of backup logic
Easy to enhance backup capabilities

Additional Organizational Improvements:
Handler Documentation Standard:
applescript-- =============================================================================
-- Handler: handlerName
-- VERSION: 0.9.0-alpha4 (2025-05-27)
-- PURPOSE: Clear description of what this handler does
-- INPUTS:  parameter descriptions
-- RETURNS: return value description
-- NOTES:   Any special considerations
-- =============================================================================
Dependency Mapping:
Each block should document its dependencies:
applescript-- DEPENDENCIES:
-- - Utilities: safeLog(), createFolderPath(), formatTimestamp()
-- - ContactOperations: processContactsWithScope(), setLogLevel()
Public API Declaration:
applescript-- ===== PUBLIC API =====
-- These handlers may be called by external scripts:
-- - run()
-- - initializeSystem()

-- ===== INTERNAL API =====
-- These handlers are for internal use only:
-- - handleContactCleaning()
-- - synchronizeLogSettings()
*)

use AppleScript version "2.4"
use framework "Foundation"
use scripting additions

-- ==============================================
-- SCRIPT CONFIGURATION
-- ==============================================

property scriptName : "Contact Management System"
property scriptVersion : "" -- will receive SYSTEM_VERSION at runtime
property scriptTitle : "" -- set once in initializeSystem / fallback in UI
property dialogWindowTitle : ""

-- Reference to other modules
property utilitiesScript : missing value
property contactOpsScript : missing value

-- Global configuration

-- FOR ADVANCED USERS ONLY : debugMode and testMode can be safely switched to true or false
property developmentMode : false -- ⚠️ Forces modules to reload on a new run to avoid caching.
property defaultDebugMode : false -- ⚠️ Enable for verbose logging (true or false)
property defaultTestMode : true -- Enable for simulation mode : outputs original and processed contacts in Backup folder for comparison without editing contact database
-- FOR ADVANCED USERS

-- 🆕 NAVIGATION SYSTEM TOGGLE
property useNewNavigation : true -- Toggle for testing new navigation UI
property menuSystemVersion : "1.0.0-revamp"
property navigationTestMode : true -- Additional safety for navigation testing

-- Live flags that are reset on each run
property debugMode : missing value -- true or false
property testMode : missing value

property shouldExitScript : missing value -- for UX loop exit mechanism

-- Global paths as properties rather than global variables with assignments
property scriptFolder : ""
property backupFolder : ""
property logsFolder : ""
property reportsFolder : ""
property sessionLogPath : missing value

-- PURPOSE: Single source of truth for version information

-- VERSION DEFINITION - CHANGE ONLY HERE
property SYSTEM_VERSION : "0.9.9" -- Main system version
property SYSTEM_RELEASE_DATE : "June 25, 2025" -- Release date
property SYSTEM_VERSION_NAME : "Contact Management System" -- System name

-- Additional version components - automatically derived
property SYSTEM_VERSION_MAJOR : "0" -- Major version (auto-derived)
property SYSTEM_VERSION_MINOR : "9" -- Minor version (auto-derived)
property SYSTEM_VERSION_PATCH : "8" -- Patch version (auto-derived)
property SYSTEM_VERSION_STAGE : "" -- Stage (auto-derived)
property SYSTEM_VERSION_BUILD : "" -- Build number (auto-derived)

-- Unified logging system : see Utilities
property startupLogBuffer : {}
property kLogLevelError : 0
property kLogLevelInfo : 1
property kLogLevelDebug : 2
property kLogLevelWarning : 3 -- Make it higher than INFO (1), less than milestone (9)
property kLogLevelMilestone : 9 -- for reporting key progress in console log
property emojiMilestone : "📍"
property emojiError : "🔴"
property emojiWarning : "⚠️"
property emojiInfo : "ℹ️"
property emojiDebug : "🔍"
property logLevel : 1 -- Initialize to INFO level

property loggingActive : false -- Set true when Utilities/session log ready

-- ==============================================
-- INITIALIZATION
-- ==============================================

-- Extract filename from a full path (simple version)
on getFilenameFromPath(fullPath)
	-- Find the last colon in the path
	set lastColonPos to 0
	repeat with i from (length of fullPath) to 1 by -1
		if character i of fullPath is ":" then
			set lastColonPos to i
			exit repeat
		end if
	end repeat
	
	-- Extract the filename part
	if lastColonPos > 0 then
		return text (lastColonPos + 1) thru -1 of fullPath
	else
		-- Fallback if no colon found
		return fullPath
	end if
end getFilenameFromPath

-------------------------------------------------------------------------------
-- Handler: initializeSystem
-- VERSION: 0.9.9 (2025-06-22)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: System initialization with single-buffer logging approach
-- CHANGE: Sets loggingActive=true only AFTER single buffer flush completes
-- WHY:    Ensures ALL startup messages flow through ContactManager for natural order
-- WHEN:   Called once at script startup from run() handler
-- HOW:    Single buffer approach - other modules don't log during startup
-- BREAKS:  Nothing - improves chronological consistency
-------------------------------------------------------------------------------
on initializeSystem()
	cmLogDebug("🟠 System initialization...")
	global scriptFolder, backupFolder, logsFolder, reportsFolder
	global utilitiesScript, contactOpsScript, debugMode, testMode
	global logLevel, startupLogBuffer, loggingActive
	
	if shouldExitScript is missing value then set shouldExitScript to false
	
	-- CRITICAL: Keep logging in single-buffer mode throughout startup
	set loggingActive to false
	
	-- Initialize logging system variables
	if logLevel is missing value then set logLevel to kLogLevelInfo
	if debugMode is missing value then set debugMode to defaultDebugMode
	
	-- Set basic properties
	set debugMode to defaultDebugMode
	set testMode to defaultTestMode
	set scriptVersion to "v" & SYSTEM_VERSION
	set scriptTitle to scriptName & " (" & scriptVersion & ")"
	
	-- Create session folders
	cmLogDebug("🟠 Creating session folders")
	createSessionFolders()
	
	-- Load required modules (they won't log independently during startup)
	cmLogInfo("🟠 Loading required modules: Utilities, ContactOperations")
	if not loadModules() then
		display dialog "🔴 Failed to load required modules." buttons {"Exit"} default button "Exit" with icon stop
		return false
	end if
	
	-- Initialize logging system (modules now loaded)
	try
		utilitiesScript's initializeLogging()
		cmLogInfo("Unified Logging System ready")
	on error logErr
		cmLogError("Error initializing logging: " & logErr)
	end try
	
	-- Set session paths in both modules
	try
		utilitiesScript's setSessionPaths(scriptFolder, backupFolder, logsFolder, reportsFolder)
		contactOpsScript's setSessionPaths(scriptFolder, backupFolder, logsFolder, reportsFolder)
		contactOpsScript's setUtilitiesReference(utilitiesScript)
		cmLogInfo("Session Folder paths configured")
	on error pathErr
		cmLogError("Error setting session paths: " & pathErr)
	end try
	
	-- Set performance tracking and cumulative stats files
	try
		utilitiesScript's initializeTrackingFiles()
		cmLogInfo("Performance and Stats files setup complete")
	on error pathErr
		cmLogError("Error setting performance and stats files: " & pathErr)
	end try
	
	-- Run backup system
	try
		set backupResult to utilitiesScript's runBackupSystem(SYSTEM_VERSION)
		-- Check for success property
		try
			if backupResult's success then
				cmLogInfo("Backup system running in mode: " & backupResult's reason)
			else
				cmLogWarning("Backup system issue: " & backupResult's reason)
			end if
		on error propErr
			-- Fallback: Maybe it returns {needed:} instead of {success:}
			cmLogError(" Backup result missing 'success' property: " & propErr)
			try
				if backupResult contains record then
					cmLogDebug("Backup result is a record, investigating properties...")
				end if
			on error
				cmLogError("Backup result format completely unexpected")
			end try
		end try
		
	on error backupErr
		cmLogError("Backup system error: " & backupErr)
	end try
	
	-- Sync settings across modules
	synchronizeLogSettings()
	
	-- PHASE TRANSITION: Flush single buffer in natural execution order
	set flushedCount to flushSingleStartupBuffer()
	
	-- CRITICAL: Only now switch to direct logging mode
	set loggingActive to true
	
	-- This message will now go directly to session log (no buffering)
	cmLogInfo("🟢 All modules initialized and startup logs flushed.")
	
	return true
end initializeSystem

-------------------------------------------------------------------------------
-- Handler: createSessionFolders
-- VERSION: 0.9.0-alpha4 (2025-05-21)
-- PURPOSE: Safely creates CCC Script, session, and subfolders using Utilities
--          Ensures all global paths are set before logging or any dependent code.
-- NOTE : When handler executes, utilities script is not available
-------------------------------------------------------------------------------
on createSessionFolders()
	global scriptFolder, backupFolder, logsFolder, reportsFolder
	global utilitiesScript
	
	set cccFolder to (path to documents folder as string) & "CCC Script:"
	set timestamp to ""
	-- Use unified date/time from Utilities if available
	set currentDate to current date
	set timestamp to ((year of currentDate) as string) & "-" & ¬
		(text -2 thru -1 of ("0" & (month of currentDate as integer))) & "-" & ¬
		(text -2 thru -1 of ("0" & (day of currentDate))) & "_" & ¬
		(text -2 thru -1 of ("0" & (hours of currentDate))) & "-" & ¬
		(text -2 thru -1 of ("0" & (minutes of currentDate))) & "-" & ¬
		(text -2 thru -1 of ("0" & (seconds of currentDate)))
	set sessionFolderName to "Session_" & timestamp
	set sessionFolder to cccFolder & sessionFolderName & ":"
	set backupsFolderName to "Backups"
	set logsFolderName to "Logs"
	set reportsFolderName to "Reports"
	
	-- SET ALL PATH GLOBALS **BEFORE** ANY LOGGING OR SYSTEM CALLS
	set scriptFolder to sessionFolder
	set backupFolder to sessionFolder & backupsFolderName & ":"
	set logsFolder to sessionFolder & logsFolderName & ":"
	set reportsFolder to sessionFolder & reportsFolderName & ":"
	
	try
		tell application "Finder"
			if not (exists folder cccFolder) then
				make new folder at (path to documents folder) with properties {name:"CCC Script"}
			end if
			if not (exists folder sessionFolder) then
				make new folder at cccFolder with properties {name:sessionFolderName}
			end if
			if not (exists folder backupFolder) then
				make new folder at sessionFolder with properties {name:backupsFolderName}
			end if
			if not (exists folder logsFolder) then
				make new folder at sessionFolder with properties {name:logsFolderName}
			end if
			if not (exists folder reportsFolder) then
				make new folder at sessionFolder with properties {name:reportsFolderName}
			end if
		end tell
		
		cmLogMilestone("📂 Session folders ready: Session, Backups, Logs, Reports")
		-- cmLogDebug("  Session: " & scriptFolder)
		-- cmLogDebug("  Backups: " & backupFolder)
		-- cmLogDebug("  Logs: " & logsFolder)
		-- cmLogDebug("  Reports: " & reportsFolder)
		
		-- Only now (paths set!) set logInitialized etc if required elsewhere
		global logInitialized
		set logInitialized to false
		
		return true
	on error folderErr
		cmLogMilestone("❌ Failed to create session folders: " & folderErr)
		return false
	end try
end createSessionFolders

-- Load script modules with proper property assignments and logging
on loadModules()
	global scriptFolder, backupFolder, logsFolder, reportsFolder
	global utilitiesScript, contactOpsScript
	
	-- DEVELOPMENT MODE: Clear module cache if enabled
	-- (developmentMode property on top of script)
	if developmentMode then
		set utilitiesScript to missing value
		set contactOpsScript to missing value
		cmLogDebug("🔄 Development mode: Module cache cleared")
	end if
	-- END DEVELOPMENT MODE: Clear module cache if enabled
	
	-- Preserve the session paths in local variables
	set savedSessionFolder to scriptFolder
	set savedBackupFolder to backupFolder
	set savedLogsFolder to logsFolder
	set savedReportsFolder to reportsFolder
	
	-- Determine modules folder
	set modulesFolder to ""
	set myPath to path to me as string
	set myName to getFilenameFromPath(myPath)
	-- log "Script name: " & myName
	
	set oldDelimiters to AppleScript's text item delimiters
	set AppleScript's text item delimiters to myName
	set pathParts to text items of myPath
	
	if (count of pathParts) > 0 then
		set modulesFolder to item 1 of pathParts
		cmLogDebug("Modules folders set to " & modulesFolder)
	else
		-- Last resort: use Documents folder
		set modulesFolder to (path to documents folder as string)
		cmLogWarning("Documents folder fallback used to set Modules folders (path to me as string method fails) " & modulesFolder)
	end if
	
	set AppleScript's text item delimiters to oldDelimiters
	
	-- Build full paths and load each script
	set utilitiesPath to modulesFolder & "utilities.scpt"
	set operationsPath to modulesFolder & "contact-operations.scpt"
	
	-- Try loading Utilities with validation
	try
		set my utilitiesScript to load script (utilitiesPath as alias)
	on error errUtilities
		cmLogError("❌ Failed to load Utilities module: " & errUtilities)
		return false
	end try
	
	-- Initialise utilitiesScript
	try
		utilitiesScript's initializeModule()
	on error initUtilErr
		cmLogError("❌ Failed to initialize Utilities module:  " & initUtilErr)
	end try
	
	-- Try loading ContactOperations
	try
		set my contactOpsScript to load script (operationsPath as alias)
	on error errOps
		cmLogError("❌ Failed to load ContactOperations module: " & errOps)
		return false
	end try
	
	-- Pass Utilities to ContactOperations with better error handling
	try
		set referenceResult to contactOpsScript's setUtilitiesReference(my utilitiesScript)
		if referenceResult then
		else
			cmLogError("❌ ContactOperations rejected Utilities reference")
			return false
		end if
	on error refErr
		cmLogError("❌ Failed to pass Utilities reference: " & refErr)
		return false
	end try
	
	-- Initialise contactOpsScript
	try
		contactOpsScript's initializeModule()
	on error initOpsErr
		cmLogError("❌ Failed to initialize ContactOperations module: " & initOpsErr)
	end try
	
	-- Restore the original session paths
	set scriptFolder to savedSessionFolder
	set backupFolder to savedBackupFolder
	set logsFolder to savedLogsFolder
	set reportsFolder to savedReportsFolder
	
	-- Post-load sanity checks
	if my utilitiesScript is missing value then cmLogWarning("utilitiesScript is still missing value after loading")
	
	if my contactOpsScript is missing value then cmLogWarning("contactOpsScript is still missing value after loading")
	
	-- Update final milestone message for dev mode
	try
		if developmentMode then
			cmLogMilestone("📦 Modules loaded FRESH (dev mode): Utilities, ContactOperations")
		else
			cmLogMilestone("📦 Modules loaded: Utilities, ContactOperations")
		end if
	on error
		cmLogMilestone("📦 Modules loaded: Utilities, ContactOperations")
	end try
	
	return true
end loadModules

-------------------------------------------------------------------------------
-- UNIFIED LOGGING SYSTEM: POLICY, DISPLAY, & ROUTING RULES (2025-06-20, POLICY UPDATE)
-------------------------------------------------------------------------------
--  SYSTEM OVERVIEW:
--   • All log calls (Info, Warning, Error, Debug, Milestone) MUST go through module-level facades
--     (cmLogXXX in ContactManager, coLogXXX in ContactOperations), delegating to Utilities’ logging handlers.
--   • During early startup, logs are buffered and flushed to the session log once Utilities is ready.
--   • Milestone and Error logs ALWAYS appear in BOTH the console and session log—regardless of module state.
--   • Warnings and Info:
--        – ALWAYS appear in session log (regardless of mode).
--        – Appear in Console ONLY in Debug mode (incl. auto-escalation).
--   • Fallback: If Utilities isn’t loaded, log outputs directly to console (timestamp + emoji + message), buffer for flush.
--   • Changing log/debug level via UI or handler MUST synchronize to all modules (use synchronizeLogSettings).
--   • Never call deprecated logError/logDebug/etc. directly—always use facades.
--   • No log is lost: fallback always logs to console, buffers if session file not ready.

--  DISPLAY RULES (Console and Session File):
--   • Log output is ALWAYS formatted with emoji and ISO timestamp.
--   • [module] tag appears:
--        – In session log: Only in Debug mode (including via auto-escalation to Debug)
--        – In console: Only for Errors
--   • Example formats:
--        – Milestone:   YYYY-MM-DD HH:MM:SS 📍 Message
--        – Info:        YYYY-MM-DD HH:MM:SS ℹ️ Message
--        – Debug:       YYYY-MM-DD HH:MM:SS 🔍 [Module] Message (session log, Debug mode)
--        – Warning:     YYYY-MM-DD HH:MM:SS ⚠️ Message (session log: [Module] in Debug mode)
--        – Error:       YYYY-MM-DD HH:MM:SS 🔴 [Module] Message (Console & session log, any mode)
--   • Console output:
--        – Milestones always, Errors always (with [Module]),
--        – Warnings/Info ONLY in Debug mode, no [Module] except for Errors.
--   • Session log:
--        – All events, [Module] appears only in Debug mode (including via auto-escalate).

--  AUTO-ESCALATE:
--   • If error count reaches escalation threshold, session log switches to Debug mode for remainder of run.
--   • All subsequent session log entries show [module]; Warnings/Info appear in console until session end.

--  IMPLEMENTATION NOTES:
--   • All fallback and error paths must emit to BOTH console and file log, regardless of state.
--   • Buffering/fallback ensures all logs are either written or flushed when ready.
--   • All wrappers and logging handlers should remain grouped under this header for clarity.
-------------------------------------------------------------------------------


-------------------------------------------------------------------------------
-- Handler: cmLog
-- VERSION: 0.9.9 (2025-06-22)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Core ContactManager logging interface with strict single-buffer startup
-- CHANGE: Enforces single-buffer approach - only ContactManager logs during startup
-- WHY:    Eliminates multi-buffer complexity and chronological ordering issues
-- WHEN:   Called by all cmLogXXX() facades for unified routing
-- HOW:    Uses loggingActive flag for strict phase separation
-- BREAKS:  Nothing - maintains same interface, improves reliability
-------------------------------------------------------------------------------
on cmLog(msg, level)
	global loggingActive, startupLogBuffer, utilitiesScript
	
	-- Always create timestamp at log time for accuracy
	set nowDate to (current date)
	set logEntry to {level:level, msg:msg, ts:nowDate, iso:(my getISOTimestamp(nowDate))}
	
	-- SINGLE-BUFFER STARTUP: All startup messages go through ContactManager only
	if not loggingActive then
		-- STARTUP PHASE: Buffer everything, no console output
		set end of startupLogBuffer to logEntry
		-- No console output prevents chronological confusion
		-- All messages will appear in natural execution order during flush
		
	else
		-- RUNTIME PHASE: Direct logging through Utilities
		try
			if utilitiesScript is not missing value then
				if (level = kLogLevelMilestone or level = "MILESTONE") then
					utilitiesScript's milestoneLog("ContactManager", msg)
				else
					utilitiesScript's safeLog("ContactManager", msg, level, missing value)
				end if
			else
				-- Emergency fallback: should not happen in runtime phase
				set timeStr to my getISOTimestamp(nowDate)
				log timeStr & " 🔴 [EMERGENCY] " & msg
			end if
		on error errMsg
			-- Fallback logging with timestamp
			set timeStr to my getISOTimestamp(nowDate)
			log timeStr & " ❌ [LOG ERROR] " & errMsg & " - Original: " & msg
		end try
	end if
end cmLog

-- Facades to avoid rewiring all the cmLog messages

on cmLogError(msg)
	cmLog(msg, kLogLevelError)
end cmLogError

on cmLogWarning(msg)
	cmLog(msg, kLogLevelWarning)
end cmLogWarning

on cmLogInfo(msg)
	cmLog(msg, kLogLevelInfo)
end cmLogInfo

on cmLogDebug(msg)
	cmLog(msg, kLogLevelDebug)
end cmLogDebug

-------------------------------------------------------------------------------
-- Handler: cmLogMilestone
-- VERSION: 0.9.9 (2025-06-22)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Milestone logging with single-buffer startup approach
-- CHANGE: Enforces consistent buffering during startup, direct logging during runtime
-- WHY:    Eliminates chronological anomalies from mixed buffering/direct logging
-- WHEN:   Called for major system milestones and progress markers
-- HOW:    Uses same phase separation as cmLog() for consistency
-- BREAKS:  Nothing - maintains same interface, improves reliability
-------------------------------------------------------------------------------
on cmLogMilestone(msg)
	global utilitiesScript, startupLogBuffer, loggingActive
	
	-- Create log entry with current timestamp
	set nowDate to (current date)
	set logEntry to {level:kLogLevelMilestone, msg:msg, ts:nowDate, iso:(my getISOTimestamp(nowDate))}
	
	-- SINGLE-BUFFER STARTUP: Consistent with cmLog() approach
	if not loggingActive then
		-- STARTUP PHASE: Buffer milestone for chronological flush
		set end of startupLogBuffer to logEntry
		-- No console output during startup prevents ordering confusion
		
	else
		-- RUNTIME PHASE: Direct milestone logging through Utilities
		try
			if utilitiesScript is not missing value then
				utilitiesScript's milestoneLog("ContactManager", msg)
			else
				-- Emergency fallback with timestamp
				set timeStr to my getISOTimestamp(nowDate)
				log timeStr & " 📍 [EMERGENCY] " & msg
			end if
		on error errMsg
			-- Fallback logging with timestamp
			set timeStr to my getISOTimestamp(nowDate)
			log timeStr & " ❌ [MILESTONE ERROR] " & errMsg & " - Original: " & msg
		end try
	end if
end cmLogMilestone

on dumpStartupLogBuffer(bufferName, logBuffer)
	log "==== DUMPING " & bufferName & " (" & (count of logBuffer) & " entries) ===="
	repeat with logEntry in logBuffer
		set levelStr to logEntry's level as string
		set msgStr to logEntry's msg
		try
			set isoStr to logEntry's iso
		on error
			try
				set isoStr to my getISOTimestamp(logEntry's ts)
			on error
				set isoStr to "NO_TIMESTAMP"
			end try
		end try
		log isoStr & " [" & levelStr & "] " & msgStr
	end repeat
	log "==== END OF " & bufferName & " DUMP ===="
end dumpStartupLogBuffer

-------------------------------------------------------------------------------  
-- Handler: flushSingleStartupBuffer  
-- VERSION: 0.9.11 (2025-06-24)
-- PURPOSE: Flush startup buffer with accurate counting and proper module tag handling
-- CHANGE: Fixed empty module brackets and accurate entry counting
-- WHY:    Empty string "" creates [] brackets, missing value creates no brackets
-- ACCURACY: Count reflects written entries vs processed entries for clarity
-------------------------------------------------------------------------------
on flushSingleStartupBuffer()
	global startupLogBuffer, utilitiesScript, debugMode
	global kLogLevelMilestone, kLogLevelInfo, kLogLevelWarning, kLogLevelDebug, kLogLevelError
	
	set totalWritten to 0
	set totalProcessed to 0
	set duplicatesSkipped to 0
	set processedMessages to {}
	
	-- Ensure debug mode is accessible
	set currentDebugMode to false
	try
		set currentDebugMode to debugMode
	on error
		set currentDebugMode to false -- Safe fallback
	end try
	
	repeat with logEntry in startupLogBuffer
		set totalProcessed to totalProcessed + 1
		
		-- Check for duplicates (unchanged logic)
		set isDuplicate to false
		repeat with processedMsg in processedMessages
			if processedMsg = logEntry's msg then
				set isDuplicate to true
				set duplicatesSkipped to duplicatesSkipped + 1
				exit repeat
			end if
		end repeat
		
		-- Process unique messages with debug-mode-aware module tagging
		if not isDuplicate then
			try
				set end of processedMessages to logEntry's msg
				
				-- FIXED: Debug-mode-aware routing with proper module handling
				if currentDebugMode then
					-- DEBUG MODE: Include module tags (existing behavior)
					if logEntry's level = kLogLevelMilestone then
						utilitiesScript's milestoneLog("ContactManager", logEntry's msg)
					else if logEntry's level = kLogLevelInfo then
						utilitiesScript's moduleLogInfo("ContactManager", logEntry's msg)
					else if logEntry's level = kLogLevelWarning then
						utilitiesScript's moduleLogWarning("ContactManager", logEntry's msg)
					else if logEntry's level = kLogLevelDebug then
						utilitiesScript's moduleLogDebug("ContactManager", logEntry's msg)
					else if logEntry's level = kLogLevelError then
						utilitiesScript's moduleLogError("ContactManager", logEntry's msg)
					else
						utilitiesScript's moduleLogInfo("ContactManager [Level " & logEntry's level & "]", logEntry's msg)
					end if
				else
					-- NORMAL MODE: Warnings/Errors still need source context
					if logEntry's level = kLogLevelWarning or logEntry's level = kLogLevelError then
						-- Warnings and errors always show module for troubleshooting
						utilitiesScript's moduleLogWarning("ContactManager", logEntry's msg)
					else
						-- Info/Debug/Milestone: no module tags in normal mode
						utilitiesScript's safeLog(missing value, logEntry's msg, logEntry's level, missing value)
					end if
				end if
				
				set totalWritten to totalWritten + 1
				
			on error flushErr
				log "❌ FLUSH ERROR: " & flushErr & " - Message: " & logEntry's msg
			end try
		end if
	end repeat
	
	-- Clear buffer after successful processing
	set startupLogBuffer to {}
	
	-- FIXED: Accurate summary with clear metrics
	set summaryMsg to totalWritten & " entries written from startup log buffer to session log file"
	if totalProcessed > totalWritten then
		set summaryMsg to summaryMsg & " (" & (totalProcessed - totalWritten) & " filtered)"
	end if
	if duplicatesSkipped > 0 then
		set summaryMsg to summaryMsg & " (" & duplicatesSkipped & " duplicates skipped)"
	end if
	utilitiesScript's moduleLogDebug("ContactManager", summaryMsg)
	-- log "✅ " & summaryMsg
	
	return totalWritten
end flushSingleStartupBuffer

-------------------------------------------------------------------------------
-- USAGE:
--   • Call ONCE at the end of initializeSystem(), after all modules, paths, and log file are ready.
--   • This is now the ONLY place startup log buffers are flushed—no partial/early flushes elsewhere.
-------------------------------------------------------------------------------
-- DEPRECATION PLAN:
--   • flushStartupLogBuffer() should now be deprecated and removed once all calls are confirmed removed from cmLogMilestone and initializeSystem.
--   • mergeStartupLogBuffers() is the sole flush point for startup logs in the unified logging system.
-------------------------------------------------------------------------------

-- Synchronize logging settings across all modules
on synchronizeLogSettings()
	global debugMode, logLevel, kLogLevelInfo, kLogLevelDebug
	
	-- Sync logLevel with Utilities, if available
	try
		if utilitiesScript is not missing value then
			set logLevel to utilitiesScript's logLevel
			utilitiesScript's setDebugMode(debugMode) -- maintain original API and compatibility
			-- No additional logging - setDebugMode already logs
		end if
	on error utilErr
		cmLogError("❌ Error setting Utilities log settings: " & utilErr)
	end try
	
	-- ContactOperations will get the settings when it needs them
	-- No need to set them proactively
	
	cmLogMilestone("📝 Unified Logging System operational") -- Single summary message
	return true
end synchronizeLogSettings


-- helper for formatting the date
on systemDateString(theDate)
	set y to year of theDate as string
	set m to text -2 thru -1 of ("0" & (month of theDate as integer))
	set d to text -2 thru -1 of ("0" & (day of theDate as integer))
	set h to text -2 thru -1 of ("0" & (hours of theDate as integer))
	set min to text -2 thru -1 of ("0" & (minutes of theDate as integer))
	set s to text -2 thru -1 of ("0" & (seconds of theDate as integer))
	return y & "-" & m & "-" & d & " " & h & ":" & min & ":" & s
end systemDateString

-- Parse version components on script load
on parseVersionComponents()
	-- Extract major.minor.patch
	set ASTID to AppleScript's text item delimiters
	
	-- Parse major.minor.patch
	set AppleScript's text item delimiters to "."
	try
		set versionParts to text items of SYSTEM_VERSION
		if (count of versionParts) ≥ 1 then
			set SYSTEM_VERSION_MAJOR to item 1 of versionParts
		end if
		if (count of versionParts) ≥ 2 then
			set SYSTEM_VERSION_MINOR to item 2 of versionParts
		end if
		if (count of versionParts) ≥ 3 then
			-- The third part might have a suffix like "-alpha2"
			set patchPart to item 3 of versionParts
			
			-- Extract the patch number and stage/build if present
			if patchPart contains "-" then
				set AppleScript's text item delimiters to "-"
				set patchItems to text items of patchPart
				if (count of patchItems) ≥ 1 then
					set SYSTEM_VERSION_PATCH to item 1 of patchItems
				end if
				if (count of patchItems) ≥ 2 then
					set stageBuild to item 2 of patchItems
					
					-- Split stage and build number if applicable
					set stageLen to 0
					repeat with i from 1 to length of stageBuild
						set charItem to character i of stageBuild
						if charItem ≥ "0" and charItem ≤ "9" then
							exit repeat
						end if
						set stageLen to stageLen + 1
					end repeat
					
					if stageLen > 0 then
						set SYSTEM_VERSION_STAGE to text 1 thru stageLen of stageBuild
						if stageLen < length of stageBuild then
							set SYSTEM_VERSION_BUILD to text (stageLen + 1) thru -1 of stageBuild
						end if
					end if
				end if
			else
				set SYSTEM_VERSION_PATCH to patchPart
				set SYSTEM_VERSION_STAGE to ""
				set SYSTEM_VERSION_BUILD to ""
			end if
		end if
	on error parseErr
		cmLogError("Error parsing version components: " & parseErr)
	end try
	
	-- Restore text item delimiters
	set AppleScript's text item delimiters to ASTID
end parseVersionComponents

-- Build a formatted version string with extra information
on getFormattedVersion()
	set formattedVersion to SYSTEM_VERSION
	
	if SYSTEM_VERSION_STAGE is not "" then
		set formattedVersion to formattedVersion & " (" & SYSTEM_VERSION_STAGE
		if SYSTEM_VERSION_BUILD is not "" then
			set formattedVersion to formattedVersion & " build " & SYSTEM_VERSION_BUILD
		end if
		set formattedVersion to formattedVersion & ")"
	end if
	
	set formattedVersion to formattedVersion & " - " & SYSTEM_RELEASE_DATE
	
	return formattedVersion
end getFormattedVersion

-- Get a short version display suitable for dialogs
on getVersionForDisplay()
	return "v" & SYSTEM_VERSION
end getVersionForDisplay

-- Get a detailed version report with all components and cumulative statistics
on getVersionReport()
	set reportText to SYSTEM_VERSION_NAME & " - Version Information" & return & return
	set reportText to reportText & "Version: " & SYSTEM_VERSION & return
	set reportText to reportText & "Released: " & SYSTEM_RELEASE_DATE & return & return
	
	set reportText to reportText & "Components:" & return
	set reportText to reportText & "• Major: " & SYSTEM_VERSION_MAJOR & return
	set reportText to reportText & "• Minor: " & SYSTEM_VERSION_MINOR & return
	set reportText to reportText & "• Patch: " & SYSTEM_VERSION_PATCH & return
	
	if SYSTEM_VERSION_STAGE is not "" then
		set reportText to reportText & "• Stage: " & SYSTEM_VERSION_STAGE & return
		if SYSTEM_VERSION_BUILD is not "" then
			set reportText to reportText & "• Build: " & SYSTEM_VERSION_BUILD & return
		end if
	end if
	
	-- ENHANCEMENT: Add cumulative statistics to version info
	set reportText to reportText & return
	if contactOpsScript is not missing value then
		try
			set statsReport to contactOpsScript's getCumulativeStatsReport()
			set reportText to reportText & statsReport
		on error statsErr
			cmLogError("Error getting cumulative stats: " & statsErr)
			set reportText to reportText & "Cumulative statistics unavailable."
		end try
	else
		set reportText to reportText & "Cumulative statistics unavailable - Contact Operations module not loaded."
	end if
	
	return reportText
end getVersionReport

-- Signal script exit with enhanced logging and exit reason tracking
on signalScriptExit()
	
	-- Set the property exit flag that will be checked in the main loop
	set shouldExitScript to true
	
	-- Log the flag change with module context
	cmLogDebug("Exit flag set to TRUE - script will terminate at next checkpoint")
	
	return "exit_script"
end signalScriptExit



-- ==============================================
-- USER INTERFACE
-- ==============================================
-- Main menu and navigation system for the Contact Management System
-- Organized into logical sections:
--  - Core Menus: Main menu and primary operations
--  - Tools Menus: Settings and utilities 
--  - Backup Menus: Script and contact backup operations
--  - Helper Functions: UI utilities and shared functions

-- ==============================================
-- CORE MENUS (v1.0.0 UX)
-- ==============================================

-- ============================================
-- Handler: showNavigationControls
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Navigation system controls and testing options
-- ============================================
on showNavigationControls()
	set handlerName to "Navigation Controls"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	global useNewNavigation, navigationTestMode
	
	set currentSystem to "LEGACY"
	if useNewNavigation then set currentSystem to "NEW"
	
	set testStatus to "DISABLED"
	if navigationTestMode then set testStatus to "ENABLED"
	
	set itemList to {¬
		"» Current: " & currentSystem & " | Test Mode: " & testStatus, ¬
		"Toggle Navigation System", ¬
		"Enable Test Mode", ¬
		"Disable Test Mode", ¬
		"Main Menu"}
	
	set handlerList to {¬
		"", ¬
		"toggleNavigationSystem", ¬
		"enableNavigationTestMode", ¬
		"disableNavigationTestMode", ¬
		"main_menu"}
	
	set promptText to "Navigation System Controls:" & return & return & ¬
		"Current system and test mode status shown above." & return & return & ¬
		"• Toggle Navigation System: Switch between NEW and LEGACY" & return & ¬
		"• Enable Test Mode: Force new system with enhanced logging" & return & ¬
		"• Disable Test Mode: Return to normal operation"
	
	return chooseAndDispatch(itemList, handlerList, dialogTitle, promptText)
end showNavigationControls

-- ROUTING HANDLERS (bridge to appropriate menu system)
on routeToCleaningMenu()
	return showMenuWithFallback("cleaning")
end routeToCleaningMenu

on routeToGroupMenu()
	return showMenuWithFallback("group")
end routeToGroupMenu

on routeToStatsMenu()
	return showMenuWithFallback("stats")
end routeToStatsMenu

on routeToSettingsMenu()
	return showMenuWithFallback("settings")
end routeToSettingsMenu

-- ============================================
-- Handler: getDialogTitleForHandler
-- VERSION: 1.2.0-edit-warning-simulation-clean (2025-07-08)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Returns dialog title with mode indicator, ⚠️ for Edit mode, clean Simulation display
-- ENHANCEMENT: 
--   • Added ⚠️ warning emoji for Edit mode in window titles
--   • Clean display for Simulation mode (no special indicators)
--   • Debug mode retains highest priority display
-- CHANGELOG:
--   • 1.2.0-edit-warning-simulation-clean: Added ⚠️ for Edit mode, clean Simulation display
--   • Enhanced visual distinction between safe (Simulation) and active (Edit) modes
--   • Failsafe operation continues with base title if mode detection fails
--   • Contact Cleaning context detection for appropriate mode display
-- ============================================
on getDialogTitleForHandler(handlerName)
	try
		global scriptVersion, debugMode, testMode
		
		-- Build base title with error handling
		set baseTitle to ""
		try
			if scriptVersion is not missing value then
				set baseTitle to handlerName & " (" & scriptVersion & ")"
			else
				set baseTitle to handlerName & " (v?.?.?)"
			end if
		on error titleErr
			set baseTitle to handlerName
		end try
		
		-- Add mode indicator for Contact Cleaning contexts only
		if handlerName is "Contact Cleaning" or handlerName contains "Clean" then
			try
				set modeIndicator to ""
				
				-- Priority order: Debug → Edit (with warning) → Simulation (clean)
				try
					if debugMode is true then
						set modeIndicator to " • Debug"
					else if testMode is false then
						-- ✅ NEW: Edit mode gets warning emoji
						set modeIndicator to " • ⚠️ Edit"
					else if testMode is true then
						-- ✅ CLEAN: Simulation mode no special indicators
						set modeIndicator to " • Simulation"
					end if
				on error modeVarErr
					-- Fallback: try to determine mode from context
					try
						global processingMode
						if processingMode is "update" then
							set modeIndicator to " • ⚠️ Edit"
						else if processingMode is "simulation" then
							set modeIndicator to " • Simulation"
						end if
					on error contextErr
						-- No mode indicator if all detection methods fail
						set modeIndicator to ""
					end try
				end try
				
				set baseTitle to baseTitle & modeIndicator
				
			on error modeErr
				-- Failsafe: Continue with base title if mode detection fails completely
				cmLogDebug("Mode detection failed in dialog title: " & modeErr)
			end try
		end if
		
		return baseTitle
		
	on error totalErr
		-- Ultimate failsafe: Return basic title
		try
			return handlerName & " (Contact Manager)"
		on error
			return "Contact Manager"
		end try
	end try
end getDialogTitleForHandler

-- ============================================
-- Handler: getDialogTitleWithMode
-- VERSION: 1.1.0-edit-warning-explicit (2025-07-08)
-- PURPOSE: Explicit mode-aware title generation with Edit warning support
-- ENHANCEMENT: Automatic ⚠️ detection for Edit mode in forced mode strings
-- USAGE: When you need to override automatic mode detection
-- FAILSAFE: Graceful handling of missing parameters
-- ============================================
on getDialogTitleWithMode(handlerName, forcedMode)
	try
		global scriptVersion
		
		set baseTitle to ""
		try
			if scriptVersion is not missing value then
				set baseTitle to handlerName & " (" & scriptVersion & ")"
			else
				set baseTitle to handlerName
			end if
		on error titleErr
			set baseTitle to handlerName
		end try
		
		if forcedMode is not missing value and forcedMode is not "" then
			try
				-- ✅ NEW: Automatically add warning emoji for Edit mode
				if forcedMode is "Edit" then
					set baseTitle to baseTitle & " • ⚠️ Edit"
				else if forcedMode is "Simulation" then
					set baseTitle to baseTitle & " • Simulation"
				else if forcedMode is "Debug" then
					set baseTitle to baseTitle & " • Debug"
				else
					-- Pass through other modes as-is
					set baseTitle to baseTitle & " • " & forcedMode
				end if
			on error modeErr
				-- Continue with base title if mode addition fails
			end try
		end if
		
		return baseTitle
		
	on error totalErr
		-- Ultimate failsafe
		try
			return handlerName & " (Contact Manager)"
		on error
			return "Contact Manager"
		end try
	end try
end getDialogTitleWithMode

-- ============================================
-- Handler: chooseAndDispatch
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Core dispatcher pattern for flat menu navigation
-- INPUTS:  itemList (list) - visible menu items
--          handlerList (list) - corresponding handler names (empty string for headers)
--          menuTitle (text) - dialog title
--          promptText (text) - dialog prompt
-- RETURNS: text - result from executed handler or "exit" for main menu return
-- DEPENDENCIES: Utilities.indexOfItem()
-- ============================================
on chooseAndDispatch(itemList, handlerList, menuTitle, promptText)
	repeat
		try
			set picked to choose from list itemList ¬
				with prompt promptText ¬
				with title menuTitle ¬
				OK button name ¬
				"Select" cancel button name "Main Menu"
			
			if picked is false then
				cmLogDebug("User selected Main Menu return via cancel")
				return "main_menu"
			end if
			
			-- Find the handler for the selected item using Utilities function
			set selectedItem to item 1 of picked
			set handlerIndex to 0
			
			if utilitiesScript is not missing value then
				set handlerIndex to utilitiesScript's indexOfItem(selectedItem, itemList)
			else
				-- Fallback: local implementation if utilities not available
				repeat with i from 1 to count of itemList
					if item i of itemList is selectedItem then
						set handlerIndex to i
						exit repeat
					end if
				end repeat
			end if
			
			if handlerIndex > 0 and handlerIndex ≤ (count of handlerList) then
				set handlerName to item handlerIndex of handlerList
				
				-- Skip empty handlers (headers) and Main Menu returns
				if handlerName is "" then
					-- Do nothing for header rows
				else if handlerName is "main_menu" then
					return "main_menu"
				else
					-- Execute the handler with error protection
					cmLogDebug("Dispatching to handler: " & handlerName)
					try
						run script handlerName of me
					on error handlerErr
						cmLogError("Handler execution error (" & handlerName & "): " & handlerErr)
						display dialog "Error executing " & handlerName & ":" & return & handlerErr ¬
							with title "Handler Error" buttons {"OK"} default button "OK"
					end try
				end if
			else
				cmLogError("Invalid handler index: " & handlerIndex & " for item: " & selectedItem)
			end if
			
		on error dispatchErr
			cmLogError("Dispatcher error: " & dispatchErr)
			display dialog "Menu error: " & dispatchErr with title ¬
				"Navigation Error" buttons {"OK"} default button "OK"
		end try
	end repeat
end chooseAndDispatch

-- ============================================
-- Handler: showMenuWithFallback
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Failsafe menu system that switches between old and new navigation
-- INPUTS:  menuType (text) - "main", "cleaning", "group", "stats", "settings"
-- RETURNS: text - menu result
-- SAFETY:  Always falls back to working legacy system if new system fails
-- ============================================
on showMenuWithFallback(menuType)
	global useNewNavigation, navigationTestMode
	
	-- Safety check: if test mode is enabled, force new navigation for testing
	if navigationTestMode then
		set useNewNavigation to true
		cmLogDebug("Navigation test mode active - forcing new navigation")
	end if
	
	try
		if useNewNavigation then
			cmLogDebug("Using NEW navigation system for menu type: " & menuType)
			return showNewMenuSystem(menuType)
		else
			cmLogDebug("Using LEGACY navigation system for menu type: " & menuType)
			return showLegacyMenuSystem(menuType)
		end if
	on error menuErr
		cmLogError("Menu system error: " & menuErr)
		
		-- FAILSAFE: If new navigation fails, automatically fall back to legacy
		if useNewNavigation then
			cmLogWarning("NEW navigation failed - falling back to LEGACY system")
			display dialog ¬
				"New navigation system encountered an error. Falling back to the previous system." with title "Navigation Fallback" buttons {"OK"} default button "OK"
			
			try
				return showLegacyMenuSystem(menuType)
			on error legacyErr
				cmLogError("LEGACY navigation also failed: " & legacyErr)
				display dialog ¬
					"Both navigation systems failed. Please restart the script." with title "Navigation Error" buttons {"OK"} default button "OK"
				return "error"
			end try
		else
			-- Legacy system failed
			display dialog "Navigation system error: " & menuErr ¬
				with title "Menu Error" buttons {"OK"} default button "OK"
			return "error"
		end if
	end try
end showMenuWithFallback

-- ============================================
-- Handler: showNewMenuSystem
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Route to appropriate new menu based on type
-- INPUTS:  menuType (text) - menu type identifier
-- RETURNS: text - menu result
-- ============================================
on showNewMenuSystem(menuType)
	if menuType is "main" then
		return showMasterMenu()
	else if menuType is "cleaning" then
		return showCleaningMenu()
	else if menuType is "group" then
		return showGroupMenu()
	else if menuType is "stats" then
		return showStatsMenu()
	else if menuType is "settings" then
		return showSettingsMenu()
	else if menuType is "performance" then
		return showPerformanceMenu()
	else
		cmLogError("Unknown menu type in new system: " & menuType)
		return "error"
	end if
end showNewMenuSystem

-- ============================================
-- Handler: showCleaningMenu
-- VERSION: 1.2.0-preview-default-simulation-mode (2025-07-08)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Contact cleaning sub-menu with Preview-only (simulation) as default
-- ENHANCEMENT: Preview-only pre-selected for safe simulation mode by default
-- CHANGELOG:
--   • 1.2.0-preview-default-simulation-mode: Changed default from Standard Clean to Preview-only
--   • Simulation mode now selected by default for safety
--   • Maintains all existing functionality with safer default behavior
--   • Comprehensive error handling for menu and handler execution failures
-- REPLACES: handleContactCleaning() when useNewNavigation = true
-- DEPENDENCIES: cmStandardClean(), cmForceClean(), cmPreviewClean() wrappers
-- ============================================
on showCleaningMenu()
	try
		set handlerName to "Contact Cleaning"
		set dialogTitle to getDialogTitleForHandler(handlerName)
		
		-- Menu structure as per UX specification
		set itemList to {¬
			"Standard Clean", ¬
			"Force Re-clean", ¬
			"Preview-only", ¬
			"Main Menu"}
		
		set handlerList to {¬
			"cmStandardClean", ¬
			"cmForceClean", ¬
			"cmPreviewClean", ¬
			"main_menu"}
		
		set promptText to "Select a cleaning mode:" & return & return & ¬
			"• Standard Clean: Skip contacts already bearing a 'CCC Summary' footer." & return & ¬
			"• Force Re-clean: Re‑process all contacts, footer or not." & return & ¬
			"• Preview-only: Execute full pipeline without writing; produces diff report."
		
		-- ✅ DIRECT APPROACH: Simple menu loop with Preview-only (simulation) as default
		repeat
			try
				set picked to choose from list itemList ¬
					with prompt promptText ¬
					with title dialogTitle ¬
					default items {"Preview-only"} ¬
					OK button name ¬
					"Select" cancel button name "Main Menu"
				
				if picked is false then return "main_menu"
				
				-- Find selected handler
				set selectedItem to item 1 of picked
				set handlerIndex to 0
				
				repeat with i from 1 to count of itemList
					if item i of itemList is selectedItem then
						set handlerIndex to i
						exit repeat
					end if
				end repeat
				
				-- Execute selected handler with error handling
				if handlerIndex > 0 and handlerIndex ≤ (count of handlerList) then
					set handlerName to item handlerIndex of handlerList
					
					if handlerName is "main_menu" then
						return "main_menu"
					else if handlerName is not "" then
						try
							-- Execute the cleaning operation
							set result to run script handlerName of me
							
							-- Handle result appropriately
							if result is not missing value then
								return result
							else
								-- Continue menu loop if no specific result
							end if
							
						on error handlerErr
							cmLogError("Cleaning handler execution failed: " & handlerName & " - " & handlerErr)
							display dialog "Operation failed: " & handlerErr & return & return & "Please try again or contact support." with title "Cleaning Error" buttons {"OK"} default button "OK"
							-- Continue to next iteration
						end try
					end if
				else
					cmLogWarning("Invalid menu selection index: " & handlerIndex)
					-- Continue to next iteration
				end if
				
			on error menuErr
				cmLogError("Cleaning menu error: " & menuErr)
				display dialog "Menu error occurred: " & menuErr & return & return & "Returning to main menu." with title "Menu Error" buttons {"OK"} default button "OK"
				return "main_menu"
			end try
		end repeat
		
	on error totalErr
		cmLogError("showCleaningMenu total failure: " & totalErr)
		display dialog "Cleaning menu system error: " & totalErr & return & return & "Returning to main menu." with title "System Error" buttons {"OK"} default button "OK"
		return "main_menu"
	end try
end showCleaningMenu

-------------------------------------------------------------------------------
-- Handler: cmStandardClean
-- PURPOSE: Wrapper → runCleaningPipeline(simulate:false, force:false)
-------------------------------------------------------------------------------
on cmStandardClean()
	return runCleaningPipeline(false, false)
end cmStandardClean

-------------------------------------------------------------------------------
-- Handler: cmForceClean
-- PURPOSE: Wrapper → runCleaningPipeline(simulate:false, force:true)
-------------------------------------------------------------------------------
on cmForceClean()
	return runCleaningPipeline(false, true)
end cmForceClean

-------------------------------------------------------------------------------
-- Handler: cmPreviewClean
-- PURPOSE: Wrapper → runCleaningPipeline(simulate:true, force:false)
-------------------------------------------------------------------------------
on cmPreviewClean()
	return runCleaningPipeline(true, false)
end cmPreviewClean

-- ============================================
-- Handler: showGroupMenu
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Display the “Group Management” sub‑menu and dispatch to its actions
--          per the UX specification (see project wiki).
-- REPLACES: handleGroupManagement() when useNewNavigation = true
-- INPUTS:   none (interactive dialog)
-- RETURNS:  text – result from dispatched handler, or "main_menu" to exit
-- DEPENDENCIES:
--   • chooseAndDispatch()  – common dispatcher pattern (dispatcher.applescript)
--   • repairEmptyGroups(), mergeDuplicateGroups(), deleteOrphanedSmartGroups()
--     implemented in contact-operations.txt
-- ============================================
on showGroupMenu()
	set handlerName to "Group Management"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	-- Visible rows in declared order (no headers in this submenu)
	set itemList to {¬
		"Repair Empty Groups", ¬
		"Merge Duplicate Groups", ¬
		"Delete Orphaned Smart Groups", ¬
		"Main Menu"}
	
	-- Matching handler list ("main_menu" sentinel on last row)
	set handlerList to {¬
		"gmRepairEmptyGroups", ¬
		"gmMergeDuplicateGroups", ¬
		"gmDeleteOrphanedSmartGroups", ¬
		"main_menu"}
	
	set promptText to "Choose a group maintenance action:" & return & return & ¬
		"• Repair Empty Groups: remove ghost contact groups created by sync glitches." & return & ¬
		"• Merge Duplicate Groups: consolidate groups with identical names." & return & ¬
		"• Delete Orphaned Smart Groups: purge Smart Groups whose query returns no contacts." & return
	
	return chooseAndDispatch(itemList, handlerList, dialogTitle, promptText)
end showGroupMenu

-------------------------------------------------------------------------------
-- Wrapper: gmRepairEmptyGroups -> repairEmptyGroups()
-------------------------------------------------------------------------------
on gmRepairEmptyGroups()
	return repairEmptyGroups()
end gmRepairEmptyGroups

-------------------------------------------------------------------------------
-- Wrapper: gmMergeDuplicateGroups -> mergeDuplicateGroups()
-------------------------------------------------------------------------------
on gmMergeDuplicateGroups()
	return mergeDuplicateGroups()
end gmMergeDuplicateGroups

-------------------------------------------------------------------------------
-- Wrapper: gmDeleteOrphanedSmartGroups -> deleteOrphanedSmartGroups()
-------------------------------------------------------------------------------
on gmDeleteOrphanedSmartGroups()
	return deleteOrphanedSmartGroups()
end gmDeleteOrphanedSmartGroups

-- ============================================
-- Handler: showStatsMenu
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Display the “Statistics” sub‑menu, including two dynamic header
--          rows (session + cumulative stats) and actionable lines per the
--          Contact‑Manager UX Specification.
-- REPLACES: handleStatisticsManagement() when useNewNavigation = true
-- INPUTS:   none (interactive dialog)
-- RETURNS:  text – result from dispatched handler, or "main_menu" to exit
-- DEPENDENCIES:
--   • chooseAndDispatch() – common dispatcher pattern
--   • getSessionStatsString(), getCumulativeStatsString()
--   • exportStatistics(), resetStatistics(), rebuildCumulativeStats()
--   • showPerformanceMenu() (nested)
-- ============================================
on showStatsMenu()
	set handlerName to "Statistics"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	-- Dynamic header rows built at runtime
	set sessionRow to "» Session: " & getSessionStatsString()
	set cumulRow to "» Cumulative: " & getCumulativeStatsString()
	
	-- Visible rows (≤6 actionable)
	set itemList to {¬
		sessionRow, ¬
		cumulRow, ¬
		"Export Statistics", ¬
		"Reset Statistics", ¬
		"Rebuild Statistics", ¬
		"Performance (advanced)", ¬
		"Main Menu"}
	
	-- Parallel handler list ("" for header rows, "main_menu" to return)
	set handlerList to {¬
		"", ¬
		"", ¬
		"stExportStatistics", ¬
		"stResetStatistics", ¬
		"stRebuildStatistics", ¬
		"showPerformanceMenu", ¬
		"main_menu"}
	
	set promptText to "Statistics dashboard – choose an action:"
	
	return chooseAndDispatch(itemList, handlerList, dialogTitle, promptText)
end showStatsMenu

-------------------------------------------------------------------------------
-- Wrapper: stExportStatistics → exportStatistics()
-------------------------------------------------------------------------------
on stExportStatistics()
	return exportStatistics()
end stExportStatistics

-------------------------------------------------------------------------------
-- Wrapper: stResetStatistics → resetStatistics()
-------------------------------------------------------------------------------
on stResetStatistics()
	return resetStatistics()
end stResetStatistics

-------------------------------------------------------------------------------
-- Wrapper: stRebuildStatistics → rebuildCumulativeStats()
-------------------------------------------------------------------------------
on stRebuildStatistics()
	return rebuildCumulativeStats()
end stRebuildStatistics

-- ============================================
-- PERFORMANCE TRACKING SYSTEM
-- ============================================




-- ============================================
-- Handler: showPerformanceMenu
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Nested "Performance" sub‑menu (advanced) under Statistics.
-- INPUTS:   none (interactive dialog)
-- RETURNS:  text – result from dispatched handler, or "back_stats" to exit
-- DEPENDENCIES:
--   • chooseAndDispatch()
--   • showPerformanceBaselines(), resetPerformanceHistory(), runSystemCalibration()
-- ============================================
on showPerformanceMenu()
	set handlerName to "Performance"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	set itemList to {¬
		"Show Baselines", ¬
		"Reset Performance History", ¬
		"System Calibration", ¬
		"Back to Statistics"}
	
	set handlerList to {¬
		"perfShowBaselines", ¬
		"perfResetHistory", ¬
		"perfRunCalibration", ¬
		"back_stats"}
	
	set promptText to "Performance tools – advanced users only:"
	
	return chooseAndDispatch(itemList, handlerList, dialogTitle, promptText)
end showPerformanceMenu

-------------------------------------------------------------------------------
-- Wrapper: perfShowBaselines → showPerformanceBaselines()
-------------------------------------------------------------------------------
on perfShowBaselines()
	return showPerformanceBaselines()
end perfShowBaselines

-------------------------------------------------------------------------------
-- Wrapper: perfResetHistory → resetPerformanceHistory()
-------------------------------------------------------------------------------
on perfResetHistory()
	return resetPerformanceHistory()
end perfResetHistory

-------------------------------------------------------------------------------
-- Wrapper: perfRunCalibration → runSystemCalibration()
-------------------------------------------------------------------------------
on perfRunCalibration()
	return runSystemCalibration()
end perfRunCalibration

-- =============================================================================
-- Helper: invalidatePerformanceCache
-- VERSION : 1.0.0  (2025-07-10)
-- PURPOSE : Flush the in-memory cache that Utilities keeps for
--           performance_history.txt, so the next read pulls fresh data.
-- DEPENDS : global utilitiesScript (loaded at ContactManager launch)
-- =============================================================================
on invalidatePerformanceCache()
	try
		set utilitiesScript's performanceHistoryLoaded to false
		set utilitiesScript's cachedPerformanceHistory to missing value
	end try
end invalidatePerformanceCache

-- =============================================================================
-- Handler : showPerformanceBaselines
-- VERSION : 3.1.0  (2025-07-10)
-- PURPOSE : Present current baseline statistics, allow Export or Calibration.
-- NOTE    : Division-by-zero guarded, uses "<=" for portability.
-- =============================================================================
on showPerformanceBaselines()
	if utilitiesScript is missing value then
		display dialog "Performance tracking not available." buttons {"OK"} with icon caution
		return ""
	end if
	
	try
		set perfHistory to utilitiesScript's loadPerformanceHistory()
		set simData to perfHistory's simulationMode
		set updData to perfHistory's updateMode
		
		set stats to "📊 PERFORMANCE BASELINES" & return & return
		set stats to stats & "System profile: " & perfHistory's systemPerformanceProfile & return & return
		
		-- ── Simulation stats ──────────────────────────────────────────────
		set stats to stats & "🔍 Simulation (" & simData's sessionCount & " sessions)" & return
		if simData's sessionCount > 0 and simData's avgSecondsPerContact > 0 then
			set speed to utilitiesScript's formatNumber(1 / (simData's avgSecondsPerContact), 1)
			set stats to stats & "• " & speed & " contacts/sec  • " & simData's totalContacts & " processed" & return
		else
			set stats to stats & "• ~25 contacts/sec (estimated)" & return
		end if
		
		-- ── Update stats ──────────────────────────────────────────────────
		set stats to stats & return & "✏️ Update (" & updData's sessionCount & " sessions)" & return
		if updData's sessionCount > 0 and updData's avgSecondsPerContact > 0 then
			set speed to utilitiesScript's formatNumber(1 / (updData's avgSecondsPerContact), 1)
			set stats to stats & "• " & speed & " contacts/sec  • " & updData's totalContacts & " processed" & return
		else
			set stats to stats & "• ~12 contacts/sec (estimated)" & return
		end if
		
		-- ── Dialog & choices ──────────────────────────────────────────────
		display dialog stats buttons {"Export", "Calibrate", "OK"} default button "OK"
		set choice to button returned of result
		
		if choice is "Calibrate" then
			return runSystemCalibration()
			
		else if choice is "Export" then
			set filePath to reportsFolder & "Performance_" & utilitiesScript's formatTimestamp(current date) & ".txt"
			if utilitiesScript's saveTextToFile(stats, filePath) then
				try
					tell application "Finder" to open file filePath
				end try
			end if
		end if
		
	on error errMsg
		cmLogError("Performance data error: " & errMsg)
		display dialog "Error: " & errMsg buttons {"OK"} with icon caution
	end try
end showPerformanceBaselines

-- =============================================================================
-- Handler : resetPerformanceHistory
-- VERSION : 2.0.0  (2025-07-10)
-- PURPOSE : Restore a pristine history record built from Utilities' template.
-- =============================================================================
on resetPerformanceHistory()
	if button returned of (display dialog "Reset ALL performance data?" & return & return & ¬
		"This cannot be undone." buttons {"Cancel", "Reset"} default button "Cancel" with icon caution) is "Cancel" then return
	
	try
		-- obtain full default record from Utilities so we keep every key in sync
		set fresh to utilitiesScript's buildPerformanceHistoryTemplate()
		set fresh's lastUpdated to (current date)
		
		if utilitiesScript's savePerformanceHistoryWithSession(fresh, missing value) then
			invalidatePerformanceCache()
			display dialog "Performance history has been reset." buttons {"OK"}
		end if
		
	on error errMsg
		cmLogError("Reset failed: " & errMsg)
		display dialog "Reset failed: " & errMsg buttons {"OK"} with icon stop
	end try
end resetPerformanceHistory



-- =============================================================================
-- Handler: runSystemCalibration
-- VERSION: 3.0.0-baseline-protection (2025-09-09)
-- PURPOSE: Time a short synthetic workload (~2s) to determine system performance profile
-- STRATEGY: Run synthetic test, determine profile, record WITHOUT updating baselines
-- 
-- CHANGELOG:
--   • 3.0.0-baseline-protection (2025-09-09):
--     - REMOVED direct baseline modification that corrupted real performance data
--     - Added proper recordSessionPerformance calls with updateBaseline:false
--     - Records both simulation and update calibration sessions for audit trail
--     - Profile still saved but baselines preserved from real processing
--   • 2.0.0 (2025-07-10): Previous version that directly modified baselines
-- 
-- BEHAVIOR:
--   • Runs synthetic processing loop for ~2 seconds
--   • Determines system performance profile (Slow/Medium/Fast)
--   • Records calibration sessions WITHOUT updating baselines
--   • Updates only systemPerformanceProfile in performance history
-- 
-- IMPORTANT: Calibration is synthetic and should NEVER update real baselines
-- =============================================================================
on runSystemCalibration()
	-- Validate dependencies
	if contactOpsScript is missing value then
		display dialog "Contact operations not available." buttons {"OK"} with icon caution
		return ""
	end if
	
	-- Confirm with user
	if button returned of (display dialog "Run calibration test (~2 seconds)?" & return & ¬
		"No contacts will be modified." buttons {"Cancel", "Start"} default button "Start") is "Cancel" then return
	
	try
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 1: Build synthetic test data
		-- ═══════════════════════════════════════════════════════════════
		cmLogInfo("Starting system calibration test...")
		
		-- Build a moderately heavy note for testing
		set testNote to "Test Contact" & return & "Engineer"
		set baseNote to testNote
		repeat 5 times
			set testNote to testNote & return & baseNote
		end repeat
		
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 2: Timed processing loop (~2 seconds)
		-- ═══════════════════════════════════════════════════════════════
		set targetSeconds to 2
		set iterations to 0
		set startTime to current date
		
		repeat
			contactOpsScript's processNoteContent(testNote)
			set iterations to iterations + 1
			if ((current date) - startTime) ≥ targetSeconds then exit repeat
		end repeat
		
		set elapsed to (current date) - startTime
		if elapsed = 0 then set elapsed to 1 -- Safety fallback
		set speed to iterations / elapsed -- Operations per second
		
		cmLogDebug("Calibration: " & iterations & " iterations in " & elapsed & "s = " & ¬
			(round (speed * 10)) / 10 & " ops/sec")
		
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 3: Determine performance profile
		-- ═══════════════════════════════════════════════════════════════
		set profile to "Slow"
		if speed > 30 then
			set profile to "Fast"
		else if speed > 15 and speed ≤ 30 then
			set profile to "Medium"
		end if
		
		cmLogInfo("System performance profile: " & profile & " (" & ¬
			(round (speed * 10)) / 10 & " ops/sec)")
		
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 4: Update ONLY the system profile (not baselines!)
		-- ═══════════════════════════════════════════════════════════════
		-- Load current performance history
		set perfHistory to utilitiesScript's loadPerformanceHistory()
		
		-- Update ONLY the system performance profile
		set perfHistory's systemPerformanceProfile to profile
		
		-- Save the updated profile (without modifying baselines)
		utilitiesScript's savePerformanceHistoryWithSession(perfHistory, missing value)
		
		cmLogDebug("System profile updated to: " & profile)
		
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 5: Record calibration sessions (WITHOUT updating baselines)
		-- ═══════════════════════════════════════════════════════════════
		-- Record as simulation calibration (audit trail only)
		try
			cmLogDebug("Recording calibration as simulation (baseline not updated)")
			
			-- CRITICAL: updateBaseline:false prevents baseline corruption
			utilitiesScript's ¬
				¬
					recordSessionPerformance({mode:"simulation", contacts:iterations, elapsedSec:elapsed, updateBaseline:false} ¬
						) -- Never update baseline from calibration
			
		on error simErr
			cmLogWarning("Could not record simulation calibration: " & simErr)
		end try
		
		-- Also record as update calibration for comparison (audit trail only)
		try
			cmLogDebug("Recording calibration as update (baseline not updated)")
			
			-- Simulate slightly slower update performance (typical 20% overhead)
			set updateElapsed to elapsed * 1.2
			set updateIterations to round (iterations / 1.2)
			
			-- CRITICAL: updateBaseline:false prevents baseline corruption
			utilitiesScript's ¬
				¬
					recordSessionPerformance({mode:"update", contacts:updateIterations, elapsedSec:updateElapsed, updateBaseline:false} ¬
						) -- Never update baseline from calibration
			
		on error updateErr
			cmLogWarning("Could not record update calibration: " & updateErr)
		end try
		
		-- ═══════════════════════════════════════════════════════════════
		-- PHASE 6: Invalidate cache and show results
		-- ═══════════════════════════════════════════════════════════════
		-- Clear any cached performance data
		try
			invalidatePerformanceCache()
		on error
			-- Cache invalidation is optional
		end try
		
		-- User feedback
		display dialog "Calibration complete!" & return & return & ¬
			"Speed: " & utilitiesScript's formatNumber(speed, 1) & " contacts/sec" & return & ¬
			"Profile: " & profile & return & return & ¬
			"Note: Baselines preserved (synthetic test)" buttons {"OK"}
		
		cmLogInfo("Calibration completed successfully - profile: " & profile)
		
	on error errMsg
		cmLogError("Calibration failed: " & errMsg)
		display dialog "Calibration failed: " & errMsg buttons {"OK"} with icon stop
	end try
end runSystemCalibration


-- ============================================
-- Handler: showLegacyMenuSystem
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Route to appropriate legacy menu based on type
-- INPUTS:  menuType (text) - menu type identifier
-- RETURNS: text - menu result
-- MAPS TO: Existing menu handlers (preserve current functionality)
-- ============================================
on showLegacyMenuSystem(menuType)
	if menuType is "main" then
		return showMainMenu() -- Current implementation
	else if menuType is "cleaning" then
		return handleContactCleaning() -- Current implementation
	else if menuType is "group" then
		return handleGroupManagement() -- Current implementation
	else if menuType is "stats" then
		return handleStatisticsManagement() -- Current implementation
	else if menuType is "settings" then
		return handleToolsAndSettings() -- Current implementation
	else if menuType is "performance" then
		-- Performance menu doesn't exist in legacy, route to stats
		return handleStatisticsManagement()
	else
		cmLogError("Unknown menu type in legacy system: " & menuType)
		return "error"
	end if
end showLegacyMenuSystem

-- ============================================
-- Handler: toggleNavigationSystem
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Toggle between old and new navigation systems for testing
-- RETURNS: text - current navigation system status
-- SAFETY:  Provides easy way to switch systems during development
-- ============================================
on toggleNavigationSystem()
	global useNewNavigation, menuSystemVersion
	
	set useNewNavigation to not useNewNavigation
	
	set currentSystem to "LEGACY"
	if useNewNavigation then set currentSystem to "NEW (" & menuSystemVersion & ")"
	
	cmLogInfo("Navigation system toggled to: " & currentSystem)
	
	display dialog "Navigation System Changed" & return & return & ¬
		"Current system: " & currentSystem & return & return & ¬
		"• NEW: Flat menu structure with dispatcher pattern" & return & ¬
		"• LEGACY: Current nested dialog system" & return & return & ¬
		¬
			"The change takes effect immediately." with title "Navigation Toggle" buttons {"OK"} default button "OK"
	
	return currentSystem
end toggleNavigationSystem

-- ============================================
-- Handler: enableNavigationTestMode
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Enable navigation test mode for comprehensive testing
-- SAFETY:  Forces new navigation and adds extra logging
-- ============================================
on enableNavigationTestMode()
	global navigationTestMode, useNewNavigation
	
	set navigationTestMode to true
	set useNewNavigation to true
	
	cmLogInfo("Navigation test mode ENABLED - forced to new system with enhanced logging")
	
	display dialog "Navigation Test Mode ENABLED" & return & return & ¬
		"• Forced to NEW navigation system" & return & ¬
		"• Enhanced error logging active" & return & ¬
		"• Automatic fallback to legacy if errors occur" & return & return & ¬
		¬
			"Use this mode to thoroughly test new navigation." with title "Test Mode Active" buttons {"OK"} default button "OK"
	
	return "test_mode_enabled"
end enableNavigationTestMode

-- ============================================
-- Handler: disableNavigationTestMode
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Disable navigation test mode and return to normal operation
-- ============================================
on disableNavigationTestMode()
	global navigationTestMode
	
	set navigationTestMode to false
	
	cmLogInfo("Navigation test mode DISABLED - returned to normal operation")
	
	display dialog "Navigation Test Mode DISABLED" & return & return & ¬
		"• Test mode logging disabled" & return & ¬
		"• Navigation system returned to user preference" & return & ¬
		¬
			"• Normal operation restored" with title "Test Mode Disabled" buttons {"OK"} default button "OK"
	
	return "test_mode_disabled"
end disableNavigationTestMode

-- ==============================================
-- CORE MENUS (OLD UX)
-- ==============================================

-- ============================================
-- Handler: showMainMenu
-- VERSION: 1.3.0-revamp-failsafe (2025-07-07)
-- PURPOSE: Main menu with failsafe navigation (maintains exact same return values)
-- RETURNS: "clean_contacts", "group_management", "tools_settings", "exit_script"
-- CHANGES: Added optional new navigation system with automatic fallback
-- SAFETY:  Identical behavior to original when useNewNavigation = false
-- ============================================
on showMainMenu()
	global useNewNavigation, navigationTestMode
	
	-- FAILSAFE: If new navigation is enabled, try it first with fallback
	if useNewNavigation then
		try
			cmLogDebug("showMainMenu: Using NEW navigation system")
			return showMainMenuNew()
		on error newNavErr
			cmLogError("NEW navigation failed, falling back to LEGACY: " & newNavErr)
			
			-- Show user that fallback occurred (only if not in test mode)
			if not navigationTestMode then
				display dialog ¬
					"New navigation system encountered an error. Using legacy system." with title "Navigation Fallback" buttons {"OK"} default button "OK"
			end if
			
			-- Fall through to legacy system below
		end try
	end if
	
	-- LEGACY SYSTEM (original implementation preserved exactly)
	cmLogDebug("showMainMenu: Using LEGACY navigation system")
	return showMainMenuLegacy()
end showMainMenu

-- ============================================
-- Handler: showMainMenuLegacy
-- VERSION: 1.3.2-contact-cleaning-default-verified (2025-07-08)  
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Legacy main menu with VERIFIED Contact Cleaning as first default selection
-- FIX: Ensured Contact Cleaning is always pre-selected when menu appears
-- CHANGELOG:
--   • 1.3.2-contact-cleaning-default-verified: Verified and fixed default selection
--   • Contact Cleaning guaranteed to be highlighted when menu opens
--   • Added verification logging for default selection behavior
-- ============================================
on showMainMenuLegacy()
	try
		set handlerName to "Main Menu"
		set dialogTitle to getDialogTitleForHandler(handlerName)
		
		-- Enhanced main menu dialog with navigation system indicator
		set menuText to "Contact Management System" & return & return
		set menuText to menuText & "Navigation: LEGACY SYSTEM" & return & return
		set menuText to menuText & "Choose an action:" & return & return
		set menuText to menuText & "• Contact Cleaning: Deduplicate and clean contact notes" & return
		set menuText to menuText & "• Group Management: Organize and manage contact groups" & return
		set menuText to menuText & "• Tools & Settings: Backup, settings, and system tools"
		
		-- ✅ VERIFIED: Contact Cleaning as first item and default selection
		cmLogDebug("Displaying legacy main menu with Contact Cleaning as default selection")
		
		set userSelection to choose from list {"Contact Cleaning", "Group Management", "Tools & Settings", "Quit"} ¬
			with title dialogTitle ¬
			with prompt menuText ¬
			default items {"Contact Cleaning"} ¬
			OK button name ¬
			"Select" cancel button name "Quit"
		
		-- Log the selection for verification
		if userSelection is not false then
			cmLogDebug("Legacy menu selection: " & (item 1 of userSelection))
		end if
		
		-- Handle user selection
		if userSelection is false then
			cmLogDebug("User selected Quit from legacy main menu")
			return "exit_script"
		else
			try
				set selectedOption to item 1 of userSelection
				
				if selectedOption is "Contact Cleaning" then
					cmLogDebug("Legacy menu: Contact Cleaning selected")
					return "clean_contacts"
				else if selectedOption is "Group Management" then
					cmLogDebug("Legacy menu: Group Management selected")
					return "group_management"
				else if selectedOption is "Tools & Settings" then
					cmLogDebug("Legacy menu: Tools & Settings selected")
					return "tools_settings"
				else if selectedOption is "Quit" then
					cmLogDebug("Legacy menu: Quit selected")
					return "exit_script"
				else
					cmLogWarning("Legacy menu: Unknown selection - " & selectedOption)
					return "exit_script"
				end if
				
			on error selectionErr
				cmLogError("Legacy menu selection processing failed: " & selectionErr)
				return "exit_script"
			end try
		end if
		
	on error totalErr
		cmLogError("showMainMenuLegacy total failure: " & totalErr)
		return "exit_script"
	end try
end showMainMenuLegacy

-- ============================================
-- Handler: showMasterMenu
-- VERSION: 1.1.1-contact-cleaning-default-verified (2025-07-08)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Master menu with VERIFIED Contact Cleaning as first default selection
-- FIX: Ensured Contact Cleaning is always pre-selected when menu appears
-- CHANGELOG:
--   • 1.1.1-contact-cleaning-default-verified: Verified and fixed default selection
--   • Contact Cleaning guaranteed to be highlighted when menu opens
--   • Added verification logging for default selection behavior
-- ============================================
on showMasterMenu()
	try
		set handlerName to "Master Menu"
		set dialogTitle to getDialogTitleForHandler(handlerName)
		
		-- Menu structure - Contact Cleaning is FIRST item
		set itemList to {¬
			"Contact Cleaning", ¬
			"Group Management", ¬
			"Statistics", ¬
			"Settings & Tools", ¬
			"Navigation Controls", ¬
			"Quit"}
		
		set handlerList to {¬
			"routeToCleaningMenu", ¬
			"routeToGroupMenu", ¬
			"routeToStatsMenu", ¬
			"routeToSettingsMenu", ¬
			"showNavigationControls", ¬
			"signalScriptExit"}
		
		-- Build navigation status
		set navigationStatus to "LEGACY SYSTEM"
		try
			global useNewNavigation
			if useNewNavigation is true then
				set navigationStatus to "NEW SYSTEM"
			end if
		on error navErr
			cmLogDebug("Navigation status detection failed: " & navErr)
		end try
		
		set promptText to "Contact Management System" & return & return & ¬
			"Navigation: " & navigationStatus & return & return & ¬
			"Select an operation:" & return & return & ¬
			"• Contact Cleaning: Deduplicate notes and clean contact data" & return & ¬
			"• Group Management: Repair, merge, and organize contact groups" & return & ¬
			"• Statistics: View processing statistics and performance data" & return & ¬
			"• Settings & Tools: Backup, restore, and system configuration" & return & ¬
			"• Navigation Controls: Switch between old/new menu systems" & return & ¬
			"• Quit: Exit the Contact Management System"
		
		-- ✅ VERIFIED: Contact Cleaning as first item and default selection
		repeat
			try
				cmLogDebug("Displaying master menu with Contact Cleaning as default selection")
				
				set picked to choose from list itemList ¬
					with prompt promptText ¬
					with title dialogTitle ¬
					default items {"Contact Cleaning"} ¬
					OK button name ¬
					"Select" cancel button name "Quit"
				
				-- Log the selection for verification
				if picked is not false then
					cmLogDebug("Master menu selection: " & (item 1 of picked))
				end if
				
				if picked is false then
					cmLogDebug("User selected Quit from master menu")
					return "exit_script"
				end if
				
				-- Find and execute handler
				set selectedItem to item 1 of picked
				set handlerIndex to 0
				
				repeat with i from 1 to count of itemList
					if item i of itemList is selectedItem then
						set handlerIndex to i
						exit repeat
					end if
				end repeat
				
				if handlerIndex > 0 and handlerIndex ≤ (count of handlerList) then
					set handlerName to item handlerIndex of handlerList
					
					try
						if handlerName is "signalScriptExit" then
							return "exit_script"
						else if handlerName is "showNavigationControls" then
							-- Handle navigation controls locally, return to main loop
							my showNavigationControls()
							-- Stay in menu loop
						else if handlerName is not "" then
							-- Execute the handler
							set returnValue to run script handlerName of me
							
							-- Handle return values appropriately
							if returnValue is "exit_script" then
								return "exit_script"
							else if returnValue is "main_menu" or returnValue is "" then
								-- Stay in main menu loop
							else
								cmLogDebug("Master menu returning: " & returnValue)
								return returnValue
							end if
						end if
						
					on error handlerErr
						cmLogError("Master menu handler execution failed: " & handlerName & " - " & handlerErr)
						display dialog "Operation failed: " & handlerErr & return & return & "Please try again." with title "Operation Error" buttons {"OK"} default button "OK"
						-- Continue to next iteration
					end try
				else
					cmLogError("Invalid selection in master menu: " & selectedItem)
					-- Continue to next iteration
				end if
				
			on error menuErr
				cmLogError("Master menu error: " & menuErr)
				display dialog "Menu error occurred: " & menuErr & return & return & "Please try again." with title "Menu Error" buttons {"OK"} default button "OK"
				-- Continue to next iteration
			end try
		end repeat
		
	on error totalErr
		cmLogError("showMasterMenu total failure: " & totalErr)
		return "exit_script"
	end try
end showMasterMenu

-- ============================================
-- Handler: testDefaultSelections
-- VERSION: 1.0.0-verification (2025-07-08)
-- PURPOSE: Test handler to verify default selections are working correctly
-- USAGE: Call this from anywhere to test menu default behavior
-- ============================================
on testDefaultSelections()
	try
		cmLogInfo("Testing default menu selections...")
		
		-- Test simple choose from list with default
		set testResult to choose from list {"Contact Cleaning", "Group Management", "Tools & Settings"} ¬
			with prompt ¬
			"Test: Contact Cleaning should be highlighted by default" with title ¬
			"Default Selection Test" default items {"Contact Cleaning"} ¬
			OK button name ¬
			"OK" cancel button name "Cancel"
		
		if testResult is not false then
			set selectedItem to item 1 of testResult
			cmLogInfo("Test result: User selected '" & selectedItem & "'")
			
			if selectedItem is "Contact Cleaning" then
				cmLogInfo("✅ DEFAULT SELECTION WORKING: Contact Cleaning was properly highlighted")
			else
				cmLogWarning("⚠️ DEFAULT SELECTION ISSUE: User selected '" & selectedItem & "' instead of default")
			end if
		else
			cmLogInfo("Test cancelled by user")
		end if
		
		return true
		
	on error testErr
		cmLogError("Default selection test failed: " & testErr)
		return false
	end try
end testDefaultSelections

-- ============================================
-- Handler: chooseAndDispatchWithDefault (FIXED)
-- PURPOSE: Enhanced dispatcher with default item support
-- ENHANCEMENT: Supports default selection for improved UX
-- FIX: Proper AppleScript syntax for choose from list command
-- ============================================
on chooseAndDispatchWithDefault(itemList, handlerList, menuTitle, promptText, defaultItem)
	repeat
		try
			-- ✅ FIXED: Proper AppleScript syntax for choose from list
			set picked to missing value
			
			if defaultItem is not missing value and defaultItem is not "" then
				-- Version with default item
				set picked to choose from list itemList ¬
					with prompt promptText ¬
					with title menuTitle ¬
					default items {defaultItem} ¬
					OK button name ¬
					"Select" cancel button name "Main Menu"
			else
				-- Version without default item
				set picked to choose from list itemList ¬
					with prompt promptText ¬
					with title menuTitle ¬
					OK button name ¬
					"Select" cancel button name "Main Menu"
			end if
			
			if picked is false then return "main_menu"
			
			-- Find and execute handler
			set selectedItem to item 1 of picked
			set handlerIndex to 0
			
			if utilitiesScript is not missing value then
				set handlerIndex to utilitiesScript's indexOfItem(selectedItem, itemList)
			else
				-- Fallback: local search
				repeat with i from 1 to count of itemList
					if item i of itemList is selectedItem then
						set handlerIndex to i
						exit repeat
					end if
				end repeat
			end if
			
			if handlerIndex > 0 and handlerIndex ≤ (count of handlerList) then
				set handlerName to item handlerIndex of handlerList
				
				if handlerName is "main_menu" then
					return "main_menu"
				else if handlerName is not "" then
					-- Execute the handler
					try
						return run script handlerName of me
					on error handlerErr
						cmLogError("Handler execution failed: " & handlerName & " - " & handlerErr)
						-- Continue to next iteration
					end try
				end if
			end if
			
		on error dispatchErr
			cmLogError("Dispatcher error: " & dispatchErr)
			return "error"
		end try
	end repeat
end chooseAndDispatchWithDefault

-- ============================================
-- Handler: showMainMenuNew
-- VERSION: 1.0.1-contact-cleaning-default-fix (2025-07-08)
-- PURPOSE: New navigation system implementation with Contact Cleaning default
-- RETURNS: "clean_contacts", "group_management", "tools_settings", "exit_script"
-- NOTES:   Must return EXACT same values as legacy for compatibility
-- CHANGES: Added missing default items {"Contact Cleaning"} parameter
-- ============================================
on showMainMenuNew()
	set handlerName to "Main Menu"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	-- Menu structure with navigation controls
	set itemList to {¬
		"Contact Cleaning", ¬
		"Group Management", ¬
		"Tools & Settings", ¬
		"Navigation Controls", ¬
		"Quit"}
	
	-- Map to EXACT same return values as legacy system
	set returnValueMap to {¬
		"clean_contacts", ¬
		"group_management", ¬
		"tools_settings", ¬
		"navigation_controls", ¬
		"exit_script"}
	
	-- Build navigation status string properly
	global useNewNavigation, menuSystemVersion
	set navigationStatus to "LEGACY SYSTEM"
	if useNewNavigation then
		set navigationStatus to "NEW SYSTEM (" & menuSystemVersion & ")"
	end if
	
	set promptText to "Contact Management System" & return & return & ¬
		"Navigation: " & navigationStatus & return & return & ¬
		"Select an operation:" & return & return & ¬
		"• Contact Cleaning: Deduplicate notes and clean contact data" & return & ¬
		"• Group Management: Repair, merge, and organize contact groups" & return & ¬
		"• Tools & Settings: Backup, restore, and system configuration" & return & ¬
		"• Navigation Controls: Switch between menu systems" & return & ¬
		"• Quit: Exit the Contact Management System"
	
	repeat
		try
			-- ✅ FIXED: Added missing default items parameter
			set picked to choose from list itemList ¬
				with prompt promptText ¬
				with title dialogTitle ¬
				default items {"Contact Cleaning"} ¬
				OK button name ¬
				"Select" cancel button name "Quit"
			
			if picked is false then
				cmLogDebug("User selected Quit from new main menu")
				return "exit_script"
			end if
			
			-- Find the return value for the selected item
			set selectedItem to item 1 of picked
			set handlerIndex to 0
			
			if utilitiesScript is not missing value then
				set handlerIndex to utilitiesScript's indexOfItem(selectedItem, itemList)
			else
				-- Fallback: local search
				repeat with i from 1 to count of itemList
					if item i of itemList is selectedItem then
						set handlerIndex to i
						exit repeat
					end if
				end repeat
			end if
			
			if handlerIndex > 0 and handlerIndex ≤ (count of returnValueMap) then
				set returnValue to item handlerIndex of returnValueMap
				
				-- Handle navigation controls locally, return others to main loop
				if returnValue is "navigation_controls" then
					my showNavigationControls()
					-- Stay in menu loop
				else
					cmLogDebug("New main menu returning: " & returnValue)
					return returnValue
				end if
			else
				cmLogWarning("New main menu: Invalid selection - " & selectedItem)
				-- Continue to next iteration
			end if
			
		on error newMenuErr
			cmLogError("New main menu error: " & newMenuErr)
			display dialog "Menu error: " & newMenuErr & return & return & ¬
				"Please try again." with title "Menu Error" buttons {"OK"} default button "OK"
			-- Continue to next iteration
		end try
	end repeat
end showMainMenuNew

-- ============================================
-- Handler: handleContactCleaning
-- VERSION: 1.3.0-edit-warning-clean-simulation (2025-07-08)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Contact cleaning workflow with ⚠️ Edit warnings and clean Simulation display
-- ENHANCEMENT: 
--   • Window titles show ⚠️ for Edit mode, clean display for Simulation
--   • Removed simulation warning from final dialog (shown in title instead)
--   • Edit mode default with clear visual warning system
-- CHANGELOG:
--   • 1.3.0-edit-warning-clean-simulation: Added Edit warning emoji + clean Simulation
--   • Real-time title changes with appropriate warning levels
--   • Enhanced error handling for title generation failures
--   • Maintains all existing functionality with improved UX safety indicators
-- ============================================
on handleContactCleaning()
	try
		global testMode, reportsFolder, contactOpsScript, scriptVersion, debugMode
		set handlerName to "Contact Cleaning"
		
		-- Loop for "Run Again" and "Open Session Folder" functionality
		repeat
			try
				-- 1) Mode selection with base title
				set dialogTitle to getDialogTitleForHandler(handlerName)
				
				set modeRes to display dialog ¬
					"Select whether to run in Simulation (no changes) or Edit (apply changes) mode." & return & return & ¬
					"Simulation: Preview only. No contact notes will be modified." & return & ¬
					"Edit: Changes will be applied to your contacts." with title ¬
					dialogTitle buttons {"Simulation", "Edit"} ¬
					default button "Simulation"
				
				set modeChoice to button returned of modeRes
				set testMode to (modeChoice is "Simulation")
				
				-- ✅ ENHANCED: Update dialog title to show selected mode with appropriate warnings
				try
					if testMode then
						set dialogTitle to getDialogTitleWithMode(handlerName, "Simulation")
					else
						set dialogTitle to getDialogTitleWithMode(handlerName, "Edit") -- Automatically adds ⚠️
					end if
				on error titleUpdateErr
					-- Failsafe: Continue with original title if update fails
					cmLogDebug("Title update failed: " & titleUpdateErr)
				end try
				
				-- Calculate processingMode for consistent baseline comparison
				set processingMode to "simulation"
				if not testMode then set processingMode to "update"
				
				-- 2) Force cleanup dialog with mode-aware title
				set forceRes to display dialog ¬
					"Process notes with existing CCC footers?" & return & return & ¬
					"• Skip: Ignore contacts already processed" & return & ¬
					"• Force: Re-process all selected contacts" with title ¬
					dialogTitle buttons {"Skip", "Force"} ¬
					default button "Skip"
				
				set forceOption to button returned of forceRes
				
				-- Set the global in ContactOperations with error handling
				try
					if contactOpsScript is not missing value then
						if forceOption is "Skip" then
							contactOpsScript's setForceCleanupMode("No, skip processed notes")
						else
							contactOpsScript's setForceCleanupMode("Yes, force cleanup")
						end if
					end if
				on error forceErr
					cmLogWarning("Failed to set force cleanup mode: " & forceErr)
				end try
				
				-- 3) Scope selection with mode-aware title (shows ⚠️ for Edit)
				set scopeRes to display dialog ¬
					"Choose which contacts to process:" & return & return & ¬
					"• Selected: Only currently highlighted contacts." & return & ¬
					"• All: Every contact in your Contacts app." with title ¬
					dialogTitle buttons {"Selected", "All"} ¬
					default button "Selected"
				
				set scopeChoice to button returned of scopeRes
				if scopeChoice is "Selected" then
					set selectionScope to "selected"
				else
					set selectionScope to "all"
				end if
				
				-- 4) Run cleanup with error handling
				try
					set batchResult to contactOpsScript's processContactsWithScopeOptimized(selectionScope, testMode)
					
					if batchResult's report is not missing value then
						set fullReport to batchResult's report
					else
						set fullReport to contactOpsScript's generateStatsReport()
					end if
				on error processErr
					cmLogError("Contact processing failed: " & processErr)
					set fullReport to "❌ Processing Error: " & processErr
				end try
				
				-- 5) Save report and display results with error handling
				try
					set timestamp to utilitiesScript's formatTimestamp(current date)
					set reportFilePath to reportsFolder & "Cleanup_Report_" & timestamp & ".txt"
					set ok to contactOpsScript's saveReportToFile(fullReport, reportFilePath)
					
					generateConsoleSummary(fullReport, reportFilePath, processingMode)
				on error reportErr
					cmLogWarning("Report generation failed: " & reportErr)
					set reportFilePath to "Report generation failed"
				end try
				
				-- ✅ ENHANCED: Final dialog shows mode in title (⚠️ for Edit, clean for Simulation)
				-- No simulation warning in dialog content - it's clear from the title
				set dialogButtons to {"Run Again", "Main Menu", "Open Session Folder"}
				set dlgRes to display dialog ¬
					fullReport & return & return & ¬
					"Report file saved to:" & return & reportFilePath ¬
					with title dialogTitle buttons dialogButtons default button "Main Menu"
				
				set chosenBtn to button returned of dlgRes
				
				-- 6) Handle user choice with error handling
				if chosenBtn is "Open Session Folder" then
					try
						tell application "Finder"
							open folder (reportsFolder as alias)
						end tell
					on error finderErr
						cmLogWarning("Failed to open session folder: " & finderErr)
						display dialog "Could not open session folder. Check the Console for details." buttons {"OK"} default button "OK"
					end try
					-- Continue loop for next operation
					
				else if chosenBtn is "Run Again" then
					-- Reset modes for next run with error handling
					try
						global defaultDebugMode, defaultTestMode
						set debugMode to defaultDebugMode
						set testMode to defaultTestMode
						contactOpsScript's setForceCleanupMode(contactOpsScript's defaultForceCleanupMode)
					on error resetErr
						cmLogWarning("Mode reset failed: " & resetErr)
					end try
					-- Continue loop for fresh run
					
				else
					-- Main Menu: break out to parent loop
					exit repeat
				end if
				
			on error dialogErr
				cmLogError("Contact cleaning dialog error: " & dialogErr)
				display dialog "Contact cleaning encountered an error: " & dialogErr & return & return & "Returning to main menu." buttons {"OK"} default button "OK"
				exit repeat
			end try
		end repeat
		
		-- Returning empty string tells run() to show the main menu again
		return ""
		
	on error totalErr
		cmLogError("handleContactCleaning total failure: " & totalErr)
		display dialog "Contact cleaning system error: " & totalErr & return & return & "Please restart the application." buttons {"OK"} default button "OK"
		return ""
	end try
end handleContactCleaning

-------------------------------------------------------------------------------
-- Handler: handleContactCleaningEnhanced
-- VERSION: 0.9.13-performance-milestone (2025-06-26)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Modernized contact cleaning workflow with performance intelligence
-- REPLACES: handleContactCleaning() with enhanced UX and time estimation
-- FEATURES: Performance baseline display, intelligent time estimates, mode-aware processing
-- DEPENDENCIES: Performance Tracking System (utilities.txt), existing contact operations
-- CHANGELOG: 
--   • 0.9.13-performance-milestone: Added mode-aware performance baseline milestone
-------------------------------------------------------------------------------
on handleContactCleaningEnhanced()
	global testMode, reportsFolder, contactOpsScript, shouldExitScript, scriptVersion, utilitiesScript
	set handlerName to "Contact Cleaning"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	repeat
		-- 1) ENHANCED MODE SELECTION WITH PERFORMANCE INFO
		set performanceInfo to my getPerformanceInfoForDialog()
		
		set modePrompt to "Select processing mode:" & return & return
		set modePrompt to modePrompt & "🔍 Simulation: Preview changes (no contact modifications)" & return
		set modePrompt to modePrompt & "   " & performanceInfo's simulationInfo & return & return
		set modePrompt to modePrompt & "✏️  Edit: Apply changes to your contacts" & return
		set modePrompt to modePrompt & "   " & performanceInfo's updateInfo & return & return
		set modePrompt to modePrompt & "💻 System Performance: " & performanceInfo's profileInfo
		
		set modeRes to display dialog modePrompt with title dialogTitle buttons {"Simulation", "Edit"} default button "Simulation"
		set modeChoice to button returned of modeRes
		set testMode to (modeChoice is "Simulation")
		set processingMode to "simulation"
		if not testMode then set processingMode to "update"
		
		-- ✅ NEW: Mode-aware performance baseline milestone (Step 2)
		try
			if utilitiesScript is not missing value then
				set baseline to utilitiesScript's getPerformanceBaseline(processingMode)
				if baseline's hasHistory then
					set baselineRate to (round ((1 / (baseline's avgSecondsPerContact)) * 10)) / 10
					cmLogMilestone("⚡ Performance baseline: " & baselineRate & " contacts/s (" & baseline's sessionCount & " " & processingMode & " sessions)")
				else
					cmLogMilestone("⚡ Performance tracking: Learning mode (no " & processingMode & " baseline yet)")
				end if
			end if
		on error
			-- Silent fallback - don't break the workflow
		end try
		
		-- 2) FORCE CLEANUP DIALOG
		set forceRes to display dialog ¬
			"Process contacts with existing CCC footers?" & return & return & ¬
			"🔄 Skip: Process only unprocessed contacts" & return & ¬
			"🔀 Force: Re-process all selected contacts" with title ¬
			dialogTitle buttons {"Skip", "Force"} default button "Skip"
		set forceOption to button returned of forceRes
		
		-- Set the global in ContactOperations
		if contactOpsScript is not missing value then
			if forceOption is "Skip" then
				contactOpsScript's setForceCleanupMode("No, skip processed notes")
			else
				contactOpsScript's setForceCleanupMode("Yes, force cleanup")
			end if
		end if
		
		-- 3) ENHANCED SCOPE SELECTION WITH SMART ESTIMATION
		set scopeSelection to my showScopeSelectionWithEstimates(processingMode)
		if scopeSelection's cancelled then exit repeat
		
		set selectionScope to scopeSelection's scope
		set contactCount to scopeSelection's contactCount
		
		-- 4) FINAL CONFIRMATION WITH TIME ESTIMATE
		set estimates to utilitiesScript's estimateProcessingTime(contactCount, 0, 0, processingMode)
		set confirmationResult to my showProcessingConfirmation(contactCount, estimates, processingMode)
		if confirmationResult's cancelled then exit repeat
		
		-- 5) RUN PROCESSING WITH ENHANCED PROGRESS
		set batchResult to my runProcessingWithProgressTracking(selectionScope, testMode, processingMode)
		
		-- 6) SHOW RESULTS AND HANDLE NEXT ACTION
		set nextAction to my showResultsWithPerformanceData(batchResult, processingMode)
		
		if nextAction is "run_again" then
			-- Continue loop for another run
		else if nextAction is "open_folder" then
			tell application "Finder" to open folder (reportsFolder as alias)
		else
			-- Return to main menu
			exit repeat
		end if
	end repeat
	
	return ""
end handleContactCleaningEnhanced

-- ============================================
-- Handler: handlePerformanceAndStatistics
-- VERSION: 1.0.0-dispatcher (2025-07-01)
-- PURPOSE: Simple 3-button dispatcher for Performance and Statistics
-- ============================================
on handlePerformanceAndStatistics()
	set handlerName to "Performance & Statistics"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	set menuText to "Select the area you want to manage:" & return & return
	set menuText to menuText & "• Performance: View processing performance, manage baselines, system calibration" & return & return
	set menuText to menuText & "• Statistics: View and export contact processing statistics"
	
	-- ✅ CONSISTENT BUTTON POSITIONING: "Main Menu" first, actions follow
	set userChoice to button returned of (display dialog menuText with title dialogTitle buttons {"Main Menu", "Statistics", "Performance"} default button "Performance")
	
	if userChoice is "Performance" then
		return handlePerformanceManagement()
	else if userChoice is "Statistics" then
		return handleStatisticsManagement()
	else
		return "" -- Main Menu
	end if
end handlePerformanceAndStatistics

-------------------------------------------------------------------------------
-- Handler: handlePerformanceManagement
-- VERSION: 0.9.12 (2025-06-25)
-- PURPOSE: Performance system management and statistics viewing
-- LOCATION: Add to Tools & Settings menu in Contact-Manager
-------------------------------------------------------------------------------
on handlePerformanceManagement()
	set handlerName to "Performance Management"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	set menuLabels to {"View Performance Stats", "Reset Performance History", "System Calibration", "Main Menu"}
	set menuDescriptions to {¬
		"View Performance Stats: Display processing performance history and system profile.", ¬
		"Reset Performance History: Clear all performance data and start fresh.", ¬
		"System Calibration: Run performance test to establish baseline.", ¬
		"Main Menu: Return to the main menu."}
	
	set menuText to "Performance Management Options:" & return & return
	repeat with i from 1 to count of menuLabels
		set menuText to menuText & "• " & item i of menuDescriptions & return
	end repeat
	
	repeat
		set userSelection to choose from list menuLabels with title dialogTitle with prompt menuText default items {"View Performance Stats"} OK button name "Select" cancel button name "Main Menu"
		
		if userSelection is false or (item 1 of userSelection is "Main Menu") then
			return ""
		else if item 1 of userSelection is "View Performance Stats" then
			my handlePerformanceAndStatistics()
		else if item 1 of userSelection is "Reset Performance History" then
			my resetPerformanceHistory()
		else if item 1 of userSelection is "System Calibration" then
			my runSystemCalibration()
		end if
	end repeat
end handlePerformanceManagement

-- ============================================
-- Handler: handleGroupManagement
-- VERSION: 1.2.0-consistent-titles (2025-06-11)
-- PURPOSE: Group Management menu using mutualized handlerName/dialogTitle.
-- ============================================
on handleGroupManagement()
	global scriptVersion
	set handlerName to "Group Management"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	set menuLabels to {"Analyze Tags", "Synchronize Groups", "Main Menu"}
	set menuDescriptions to {¬
		"Analyze Tags: Scan your contacts to find and report group/tag mismatches (planned).", ¬
		"Synchronize Groups: Automatically align group assignments and #tags in contact notes (planned).", ¬
		"Main Menu: Return to the main menu."}
	set menuText to "Group Management Options:" & return & return
	repeat with i from 1 to count of menuLabels
		set menuText to menuText & "• " & item i of menuDescriptions & return
	end repeat
	set menuText to menuText & return & "Select a group management action:"
	
	repeat
		set userSelection to choose from list menuLabels with title dialogTitle with prompt menuText default items {"Analyze Tags"} OK button name "Select" cancel button name "Main Menu"
		if userSelection is false or (item 1 of userSelection is "Main Menu") then
			return ""
		else if item 1 of userSelection is "Analyze Tags" then
			display dialog "Tag Analysis: This feature will scan your contacts and highlight mismatches between tags and group assignments. (Planned for future release.)" with title dialogTitle buttons {"OK"} default button "OK"
		else if item 1 of userSelection is "Synchronize Groups" then
			display dialog "Group Synchronization: This feature will automatically create or update groups and tags for your contacts. (Planned for future release.)" with title dialogTitle buttons {"OK"} default button "OK"
		end if
	end repeat
end handleGroupManagement

-- ============================================
-- Handler: handleToolsAndSettings
-- VERSION: 1.1.0-unified-perf-stats (2025-07-01)
-- PURPOSE: Tools & Settings menu with unified Performance & Statistics
-- CHANGES: Replaced "Performance Management" + removed "Pipeline Comparison"
--          Added unified "Performance & Statistics" dispatcher
-- ============================================
on handleToolsAndSettings()
	global scriptVersion
	set handlerName to "Tools & Settings"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	-- Updated menu labels - removed Pipeline Comparison, unified Performance & Statistics
	set menuLabels to {"System Settings", "Performance & Statistics", "Backup Operations", "Main Menu"}
	set menuDescriptions to {¬
		"System Settings: Configure logging, debug mode, simulation mode, version info.", ¬
		"Performance & Statistics: View processing performance and contact statistics.", ¬
		"Backup Operations: Backup or restore scripts and contacts.", ¬
		"Main Menu: Return to the main menu."}
	
	set menuText to "Tools & Settings Options:" & return & return
	repeat with i from 1 to count of menuLabels
		set menuText to menuText & "• " & item i of menuDescriptions & return
	end repeat
	set menuText to menuText & return & "Select a tool or setting:"
	
	repeat
		set userSelection to choose from list menuLabels with title dialogTitle with prompt menuText default items {"System Settings"} OK button name "Select" cancel button name "Main Menu"
		
		if userSelection is false or (item 1 of userSelection is "Main Menu") then
			return ""
		else if item 1 of userSelection is "System Settings" then
			handleSystemSettings()
		else if item 1 of userSelection is "Performance & Statistics" then
			handlePerformanceAndStatistics() -- NEW: Routes to dispatcher
		else if item 1 of userSelection is "Backup Operations" then
			handleBackupOperations()
		end if
	end repeat
end handleToolsAndSettings

-- ============================================
-- Handler: handleSystemSettings
-- VERSION: 1.1.0-statistics-removed (2025-07-01)
-- PURPOSE: System settings menu with Statistics moved to Performance & Statistics
-- CHANGES: Removed Statistics from More Options submenu - now in unified menu
-- INPUTS:  None
-- RETURNS: Empty string to return to main menu, or "exit_script"
-- ============================================
on handleSystemSettings()
	global scriptVersion
	set handlerName to "System Settings"
	set dialogTitle to getDialogTitleForHandler(handlerName)
	
	-- Initialize operationResult
	set operationResult to ""
	
	-- Log entry to function
	cmLogInfo("Entering System Settings menu (direct mode)")
	
	-- System settings dialog - text clearly matches the 3 available buttons
	set settingsText to "System Settings:" & return & return
	set settingsText to settingsText & "Select from the following options:" & return & return
	set settingsText to settingsText & "• Version Info: View system version and statistics" & return
	set settingsText to settingsText & "• More Options: Access logging and configuration features" & return
	set settingsText to settingsText & "• Main Menu: Return to main menu"
	
	-- Updated button label from "Go Back" to "Main Menu" for clarity
	set settingsChoice to button returned of (display dialog settingsText with title dialogTitle buttons {"Main Menu", "More Options", "Version Info"} default button "More Options")
	
	-- Handle Main Menu - return directly to main menu
	if settingsChoice is "Main Menu" then
		cmLogDebug("User returning to main menu from System Settings")
		return operationResult
	end if
	
	-- Handle version info - ENHANCED with Statistics access
	if settingsChoice is "Version Info" then
		cmLogDebug("Displaying Version Information with Statistics access")
		
		-- Get the version report
		set versionReport to getVersionReport()
		
		-- Check if statistics are empty to provide helpful guidance
		set hasStatistics to false
		if contactOpsScript is not missing value then
			try
				set statsReport to contactOpsScript's getCumulativeStatsReport()
				-- Simple check for non-zero statistics
				if not (statsReport contains "Total contacts optimized: 0") then
					set hasStatistics to true
				end if
			end try
		end if
		
		-- Add helpful guidance for empty statistics
		if not hasStatistics then
			set versionReport to versionReport & return & return
			set versionReport to versionReport & "💡 Tip: Statistics will appear after processing contacts via 'Contact Cleaning'."
		end if
		
		-- Enhanced dialog with Statistics access
		set versionChoice to button returned of (display dialog versionReport with title "System Version Information" buttons {"Close", "Statistics"} default button "Close")
		
		if versionChoice is "Statistics" then
			cmLogDebug("User requested statistics from Version Information")
			-- Route to the existing statistics handler
			set operationResult to handleStatisticsManagement()
			if operationResult is "exit_script" then
				return "exit_script"
			end if
		end if
		
		-- Return to system settings after viewing version info
		return handleSystemSettings()
	end if
	
	-- Handle More Options - simplified submenu with Statistics removed
	if settingsChoice is "More Options" then
		cmLogDebug("Entering Additional Options submenu")
		
		-- Simplified submenu - Statistics removed, now in Performance & Statistics
		set subMenuText to "Additional Options:" & return & return
		set subMenuText to subMenuText & "Select from the following features:" & return & return
		set subMenuText to subMenuText & "• Logging: Configure logging and debug mode" & return
		set subMenuText to subMenuText & "• Return: Go back to system settings menu"
		
		set subChoice to button returned of (display dialog subMenuText with title "Additional Options" buttons {"Return", "Logging"} default button "Logging")
		
		-- Log the user's submenu choice
		cmLogDebug("User selected: " & subChoice & " in Additional Options")
		
		if subChoice is "Return" then
			cmLogDebug("Returning to System Settings from Additional Options")
			-- Return to system settings menu
			return handleSystemSettings()
		end if
		
		if subChoice is "Logging" then
			set operationResult to handleLoggingOptions()
			-- Check for exit signal from logging options
			if operationResult is "exit_script" then
				cmLogDebug("Exit request received from Logging Options")
				return "exit_script"
			end if
		end if
		
		-- REMOVED: Statistics handling block - now in Performance & Statistics menu
		-- Statistics are now accessible via Tools & Settings → Performance & Statistics
	end if
	
	-- Return to system settings
	return handleSystemSettings()
end handleSystemSettings

-- ============================================
-- Handler: handleBackupOperationsDirect
-- VERSION: 0.9.0-alpha3 (2025-05-22)
-- PURPOSE: Backup operations menu with direct return to main menu
-- INPUTS:  None
-- RETURNS: Empty string to return to main menu, or "exit_script"
-- ============================================
on handleBackupOperations()
	-- Initialize operationResult
	set operationResult to ""
	
	-- Log entry to function
	cmLogDebug("Entering Backup Operations menu (direct mode)")
	
	-- Backup operations dialog
	set backupText to "Backup Operations:" & return & return
	set backupText to backupText & "• Script Backups: Backup and restore scripts" & return
	set backupText to backupText & "• Contact Backups: Backup and restore contacts" & return & return
	set backupText to backupText & "Choose an operation:"
	
	-- Updated from "Exit" to "Main Menu" for clarity and consistency
	set backupChoice to button returned of (display dialog backupText with title "Backup Operations" buttons {"Main Menu", "Contact Backups", "Script Backups"} default button "Script Backups")
	
	-- Log the user's choice
	cmLogDebug("User selected: " & backupChoice & " in Backup Operations")
	
	-- Handle Main Menu - return to main menu
	if backupChoice is "Main Menu" then
		cmLogDebug("User returning to main menu from Backup Operations")
		return operationResult
	end if
	
	-- Handle script backups
	if backupChoice is "Script Backups" then
		cmLogDebug("Entering Script Backups submenu")
		
		set operationResult to handleScriptBackups()
		-- Check for exit request passed up from deeper menus
		if operationResult is "exit_script" then
			cmLogDebug("Exit request received from Script Backups")
			return "exit_script"
		end if
	end if
	
	-- Handle contact backups
	if backupChoice is "Contact Backups" then
		cmLogDebug("Entering Contact Backups submenu")
		
		set operationResult to handleContactBackups()
		-- Check for exit request passed up from deeper menus
		if operationResult is "exit_script" then
			cmLogDebug("Exit request received from Contact Backups")
			return "exit_script"
		end if
	end if
	
	-- Return to backup operations (recursive call)
	return handleBackupOperations()
end handleBackupOperations

-- ============================================
-- Handler: handleLoggingOptions
-- VERSION: 1.2.0-enhanced-policy-3btn (2025-07-01)
-- PURPOSE: Enhanced logging options with detailed policy and log file access
-- CHANGES: Added logging policy details, replaced Test Logging with View Log Files
--          Fixed 3-button AppleScript limit, enhanced error handling
-- COMPATIBILITY: Maintains all existing functionality and global variable usage
-- DEPENDENCIES: global debugMode, logsFolder, utilitiesScript
-- INPUTS:  None
-- RETURNS: Empty string to return to menu, or "exit_script"
-- ============================================
on handleLoggingOptions()
	-- Initialize operationResult for consistent return handling
	set operationResult to ""
	
	-- Log entry to function with proper module context
	cmLogDebug("Entering Enhanced Logging Options menu")
	
	-- Determine current status with failsafe handling
	global debugMode
	set statusText to "Current logging level: "
	
	try
		if debugMode is missing value then
			set debugMode to false -- Failsafe default
			cmLogWarning("debugMode was missing value - set to false as default")
		end if
		
		if debugMode then
			set statusText to statusText & "DEBUG (verbose)"
		else
			set statusText to statusText & "INFO (standard)"
		end if
	on error statusErr
		-- Failsafe: assume INFO level if error determining status
		set statusText to statusText & "INFO (standard) - status check failed"
		cmLogError("Error determining debug mode status: " & statusErr)
	end try
	
	-- Log current status for debugging
	cmLogDebug("Current logging status: " & statusText)
	
	-- Build enhanced logging options dialog with detailed policy
	set loggingText to "Logging Options:" & return & return
	set loggingText to loggingText & statusText & return & return
	
	-- Add comprehensive logging policy explanation
	set loggingText to loggingText & "📋 Logging Policy:" & return
	set loggingText to loggingText & "• Console: Milestones + Errors always, Debug details when enabled" & return
	set loggingText to loggingText & "• Session File: Complete timestamped log with all operations" & return
	set loggingText to loggingText & "• Debug Mode: Enables verbose logging across all modules" & return & return
	
	set loggingText to loggingText & "Available Actions:" & return
	set loggingText to loggingText & "• Toggle Debug Mode: Switch between standard/verbose logging" & return
	set loggingText to loggingText & "• View Log Files: Open the session logs folder to examine files" & return & return
	set loggingText to loggingText & "Choose an operation:"
	
	-- FIXED: AppleScript 3-button maximum compliance
	set logChoice to button returned of (display dialog loggingText with title "Logging Options" buttons {"Go Back", "View Log Files", "Toggle Debug Mode"} default button "Toggle Debug Mode")
	
	-- Log user's selection with proper context
	cmLogDebug("User selected: " & logChoice & " in Enhanced Logging Options menu")
	
	-- Handle Go Back option with consistent return pattern
	if logChoice is "Go Back" then
		cmLogDebug("User returning to previous menu from Logging Options")
		return operationResult
	end if
	
	-- Handle Toggle Debug Mode with enhanced error handling and synchronization
	if logChoice is "Toggle Debug Mode" then
		try
			-- Log the action with details before execution
			set newDebugMode to not debugMode
			cmLogDebug("Toggling debug mode from " & (debugMode as string) & " to " & (newDebugMode as string))
			
			-- Update the global debug mode
			set debugMode to newDebugMode
			
			-- Handle enabling debug mode
			if debugMode then
				-- Enhanced debug mode activation
				if utilitiesScript is not missing value then
					try
						-- Log the action before executing it
						cmLogInfo("Setting debug mode to TRUE in Utilities module")
						
						-- Set debug mode in utilities with error handling
						utilitiesScript's setDebugMode(true)
						cmLogDebug("Debug mode successfully enabled in Utilities module")
						
						-- Display enhanced confirmation dialog
						cmLogInfo("Displaying debug mode enabled confirmation dialog")
						display dialog "Debug logging enabled. All messages including detailed debug information will be logged to both console and session file." & return & return & "📋 What this means:" & return & "• Console shows all operations" & return & "• Session file includes detailed debug traces" & return & "• Processing details are fully visible" with title "Debug Logging Enabled" buttons {"OK"} default button "OK"
						
						-- Force synchronization across all modules
						cmLogInfo("Synchronizing log settings across all modules")
						try
							synchronizeLogSettings()
						on error syncErr
							cmLogWarning("Log settings synchronization had issues: " & syncErr)
						end try
						
						-- Verification messages
						cmLogInfo("✅ DEBUG MODE ENABLED - Verbose logging activated")
						cmLogDebug("Sending test debug message to verify debug logging is working")
						
						-- Test debug logging with utilities
						if utilitiesScript is not missing value then
							utilitiesScript's moduleLogDebug("Contact Manager", "Test debug message after enabling debug mode - should appear in logs")
						end if
						
					on error debugEnableErr
						cmLogError("Error enabling debug mode in Utilities: " & debugEnableErr)
						-- Fallback dialog for partial success
						display dialog "Debug mode enabled locally, but utilities module had issues: " & debugEnableErr with title "Partial Debug Enable" buttons {"OK"} default button "OK" with icon caution
					end try
				else
					-- Utilities module not available - fallback handling
					cmLogWarning("Setting debug mode to TRUE but utilities module not available")
					display dialog "Debug logging enabled locally, but utilities module not available. Some logging features may not work correctly." with title "Limited Debug Enable" buttons {"OK"} default button "OK" with icon caution
				end if
			else
				-- Handle disabling debug mode
				if utilitiesScript is not missing value then
					try
						-- Log the action before executing it
						cmLogInfo("Setting debug mode to FALSE in Utilities module")
						
						-- Set debug mode in utilities with error handling
						utilitiesScript's setDebugMode(false)
						cmLogDebug("Debug mode successfully disabled in Utilities module")
						
						-- Display confirmation dialog with clear explanation
						cmLogInfo("Displaying debug mode disabled confirmation dialog")
						display dialog "Debug logging disabled. Only standard INFO, WARNING, and ERROR messages will be logged." & return & return & "📋 What this means:" & return & "• Console shows essential operations only" & return & "• Session file excludes debug details" & return & "• Cleaner, focused logging output" with title "Standard Logging Enabled" buttons {"OK"} default button "OK"
						
						-- Force synchronization across all modules
						cmLogInfo("Synchronizing log settings across all modules")
						try
							synchronizeLogSettings()
						on error syncErr
							cmLogWarning("Log settings synchronization had issues: " & syncErr)
						end try
						
						-- Verification messages
						cmLogInfo("✅ DEBUG MODE DISABLED - Standard logging activated")
						
						-- Test that debug messages are no longer visible
						cmLogDebug("This debug message should NOT appear in standard logging mode")
						cmLogInfo("This info message should still appear in standard logging mode")
						
					on error debugDisableErr
						cmLogError("Error disabling debug mode in Utilities: " & debugDisableErr)
						-- Fallback dialog for partial success
						display dialog "Debug mode disabled locally, but utilities module had issues: " & debugDisableErr with title "Partial Debug Disable" buttons {"OK"} default button "OK" with icon caution
					end try
				else
					-- Utilities module not available - fallback handling
					cmLogWarning("Setting debug mode to FALSE but utilities module not available")
					display dialog "Debug logging disabled locally, but utilities module not available. Some logging features may not work correctly." with title "Limited Debug Disable" buttons {"OK"} default button "OK" with icon caution
				end if
			end if
			
		on error toggleErr
			-- Comprehensive error handling for debug mode toggle failures
			cmLogError("Critical error during debug mode toggle: " & toggleErr)
			display dialog "Error changing debug mode: " & toggleErr & return & return & "Debug mode state may be inconsistent. Consider restarting the script." with title "Debug Toggle Error" buttons {"OK"} default button "OK" with icon stop
		end try
	end if
	
	-- Handle View Log Files - NEW enhanced functionality
	if logChoice is "View Log Files" then
		cmLogDebug("User requested to view log files")
		
		-- Enhanced log file access with comprehensive error handling
		try
			global logsFolder
			
			-- Validate logs folder availability
			if logsFolder is missing value or logsFolder is "" then
				cmLogError("Logs folder path not available - logsFolder is missing or empty")
				display dialog "Error: Logs folder path not available. This may indicate a system initialization problem." & return & return & "Try restarting the application to reinitialize folder paths." with title "Folder Path Error" buttons {"OK"} default button "OK" with icon caution
			else
				cmLogDebug("Attempting to open logs folder: " & logsFolder)
				
				-- Verify folder exists before trying to open
				try
					tell application "System Events"
						if not (exists folder logsFolder) then
							cmLogWarning("Logs folder does not exist, attempting to create: " & logsFolder)
							-- Try to create the folder if it doesn't exist
							if utilitiesScript is not missing value then
								utilitiesScript's createFolderPath(logsFolder)
							end if
						end if
					end tell
				on error folderCheckErr
					cmLogWarning("Could not verify logs folder existence: " & folderCheckErr)
				end try
				
				-- Open the logs folder in Finder
				try
					tell application "Finder"
						open folder (logsFolder as alias)
						activate
					end tell
					
					cmLogInfo("Successfully opened logs folder: " & logsFolder)
					
					-- Enhanced success dialog with helpful information
					display dialog "Logs folder opened in Finder." & return & return & "📂 What you'll find:" & return & "• Session log files contain complete timestamped records" & return & "• Each session creates a separate log file" & return & "• Debug mode affects the level of detail captured" with title "Log Files Opened" buttons {"OK"} default button "OK"
					
				on error finderErr
					cmLogError("Error opening logs folder in Finder: " & finderErr)
					display dialog "Error opening logs folder in Finder: " & finderErr & return & return & "Folder path: " & logsFolder with title "Finder Error" buttons {"OK"} default button "OK" with icon caution
				end try
			end if
			
		on error viewLogsErr
			-- Comprehensive error handling for log viewing failures
			cmLogError("Critical error accessing log files: " & viewLogsErr)
			display dialog "Unexpected error accessing log files: " & viewLogsErr & return & return & "Check that the application has proper file system permissions." with title "Log Access Error" buttons {"OK"} default button "OK" with icon stop
		end try
	end if
	
	-- Log returning to the logging options menu (recursive call pattern)
	cmLogDebug("Returning to Enhanced Logging Options menu")
	
	-- Consistent recursive return to logging options menu
	return handleLoggingOptions()
end handleLoggingOptions

-- ==============================================
-- BACKUP MENUS
-- ==============================================

-- Enhanced script backup management with improved logging and error handling
on handleScriptBackups()
	-- Initialize operationResult
	set operationResult to ""
	
	-- Log entry to function with module context
	cmLogDebug("Entering Script Backups menu")
	
	-- Script backups dialog
	set scriptText to "Script Backups:" & return & return
	set scriptText to scriptText & "• Backup Now: Create a new script backup immediately" & return
	set scriptText to scriptText & "• Browse Versions: View and restore script versions" & return & return
	set scriptText to scriptText & "Choose an operation:"
	
	-- Display dialog and capture user choice
	set scriptChoice to button returned of (display dialog scriptText with title "Script Backups" buttons {"Go Back", "Browse Versions", "Backup Now"} default button "Backup Now")
	
	-- Log user's selection with proper context
	cmLogDebug("User selected: " & scriptChoice & " in Script Backups menu")
	
	-- Handle Go Back option
	if scriptChoice is "Go Back" then
		cmLogDebug("User returning to previous menu from Script Backups")
		return operationResult
	end if
	
	-- Handle backup now
	if scriptChoice is "Backup Now" then
		if utilitiesScript is not missing value then
			-- Log the action before executing
			cmLogInfo("Initiating manual script backup")
			
			try
				-- Attempt the backup operation
				set backupResult to utilitiesScript's forceBackup(SYSTEM_VERSION)
				
				-- Log the result
				if backupResult's success then
					cmLogInfo("Script backup successful - Version: " & backupResult's version)
					
					-- Show success dialog
					cmLogInfo("Displaying backup success dialog")
					display dialog "Scripts backed up successfully." & return & "Version: " & backupResult's version with title "Backup Successful" buttons {"OK"} default button "OK"
				else
					-- Log failure with reason
					cmLogError("Script backup failed: " & backupResult's reason)
					
					-- Show failure dialog
					cmLogInfo("Displaying backup failure dialog")
					display dialog "Failed to back up scripts: " & backupResult's reason with title "Backup Failed" buttons {"OK"} default button "OK" with icon caution
				end if
			on error errMsg
				-- Log any unexpected errors
				cmLogError("Error during backup operation: " & errMsg)
				display dialog "An unexpected error occurred during backup: " & errMsg with title "Backup Error" buttons {"OK"} default button "OK" with icon stop
			end try
		else
			-- Log the module missing error
			cmLogError("Cannot perform backup - utilities module not available")
			display dialog "Utilities module not available" with title "Module Error" buttons {"OK"} default button "OK" with icon stop
		end if
	end if
	
	-- Handle browse versions
	if scriptChoice is "Browse Versions" then
		-- Log the action
		cmLogDebug("User selected Browse Versions (feature not yet implemented)")
		
		-- Implementation for browsing and restoring script versions
		display dialog "Script version browsing will be implemented in the next version." with title "Feature Notice" buttons {"OK"} default button "OK"
	end if
	
	-- Log returning to the script backups menu (recursion)
	cmLogDebug("Returning to Script Backups menu")
	
	-- Return to script backups recursively
	return handleScriptBackups()
end handleScriptBackups

-- Contact backup management with logging and error tracking
on handleContactBackups()
	-- Initialize operationResult
	set operationResult to ""
	
	-- Log entry to function with module context
	cmLogDebug("Entering Contact Backups menu")
	
	-- Contact backups dialog
	set contactText to "Contact Backups:" & return & return
	set contactText to contactText & "• Backup Contact: Create a backup of selected contact" & return
	set contactText to contactText & "• Restore Contact: Restore a contact from backup" & return & return
	set contactText to contactText & "Choose an operation:"
	
	-- Display dialog and capture user choice
	set contactChoice to button returned of (display dialog contactText with title "Contact Backups" buttons {"Go Back", "Restore Contact", "Backup Contact"} default button "Backup Contact")
	
	-- Log user's selection with proper context
	cmLogDebug("User selected: " & contactChoice & " in Contact Backups menu")
	
	-- Handle Go Back option
	if contactChoice is "Go Back" then
		cmLogDebug("User returning to previous menu from Contact Backups")
		return operationResult
	end if
	
	-- Handle backup contact
	if contactChoice is "Backup Contact" then
		cmLogDebug("User requested to backup a contact")
		
		try
			set backupResult to backupContact()
			
			-- Log the result if available
			if utilitiesScript is not missing value and backupResult is not missing value then
				if backupResult is record and backupResult contains "success" then
					if backupResult's success then
						cmLogInfo("Contact backup completed successfully")
					else
						cmLogError("Contact backup failed: " & backupResult's reason)
					end if
				end if
			end if
		on error errMsg
			-- Log error with context
			cmLogError("Error during contact backup: " & errMsg)
		end try
	end if
	
	-- Handle restore contact
	if contactChoice is "Restore Contact" then
		cmLogDebug("User requested to restore a contact")
		
		try
			set restoreResult to restoreContact()
			
			-- Log the result if available
			if utilitiesScript is not missing value and restoreResult is not missing value then
				if restoreResult is record and restoreResult contains "success" then
					if restoreResult's success then
						cmLogInfo("Contact restoration completed successfully")
					else
						cmLogError("Contact restoration failed: " & restoreResult's reason)
					end if
				end if
			end if
		on error errMsg
			-- Log error with context
			cmLogError("Error during contact restoration: " & errMsg)
		end try
	end if
	
	-- Log returning to the contact backups menu (recursion)
	cmLogDebug("Returning to Contact Backups menu")
	
	-- Return to contact backups
	return handleContactBackups()
end handleContactBackups

-- Create contact backup with enhanced logging and error handling
on backupContact()
	-- Initialize default return value
	set backupResult to {success:false, reason:"Not completed", path:""}
	
	-- Log entry to function with module context
	cmLogDebug("Starting contact backup operation")
	
	-- Wrap entire operation in error handling block
	try
		-- Backup contact dialog - work with Contacts
		tell application "Contacts"
			-- Log getting selection
			cmLogDebug("Getting selected contacts from Contacts app")
			
			set selectedContacts to selection
			
			-- Check if any contacts are selected
			if (count of selectedContacts) is 0 then
				cmLogError("No contacts selected for backup")
				
				-- Show error dialog
				display dialog "Please select a contact to backup." with title "No Selection" buttons {"OK"} default button "OK"
				set backupResult to {success:false, reason:"No contacts selected", path:""}
				return backupResult
			end if
			
			-- Check if multiple contacts are selected
			if (count of selectedContacts) > 1 then
				cmLogError("Multiple contacts selected (" & (count of selectedContacts) & ") - only one allowed")
				
				-- Show error dialog
				display dialog "Please select only one contact to backup." with title "Multiple Selection" buttons {"OK"} default button "OK"
				set backupResult to {success:false, reason:"Multiple contacts selected", path:""}
				return backupResult
			end if
			
			-- Get the selected contact
			set theContact to item 1 of selectedContacts
			
			-- Get contact name safely
			try
				set contactName to name of theContact
				cmLogDebug("Selected contact for backup: " & contactName)
			on error nameErr
				set contactName to "Unknown Contact"
				cmLogError("Error getting contact name: " & nameErr)
			end try
			
			-- Backup type selection dialog
			set backupTypeText to "Backup Type for " & contactName & ":" & return & return
			set backupTypeText to backupTypeText & "• Full Contact: Complete vCard backup" & return
			set backupTypeText to backupTypeText & "• Note Only: Just backup the contact note" & return & return
			set backupTypeText to backupTypeText & "Choose a backup type:"
			
			-- Log showing backup type dialog
			cmLogDebug("Displaying backup type selection dialog")
			
			set typeChoice to button returned of (display dialog backupTypeText with title "Contact Backup - Type Selection" buttons {"Cancel", "Note Only", "Full Contact"} default button "Full Contact")
			
			-- Log user's selection
			cmLogDebug("User selected backup type: " & typeChoice)
			
			-- Handle Cancel option
			if typeChoice is "Cancel" then
				cmLogDebug("Contact backup canceled by user")
				
				set backupResult to {success:false, reason:"Canceled by user", path:""}
				return backupResult
			end if
			
			-- Handle Full Contact backup
			if typeChoice is "Full Contact" then
				cmLogDebug("Creating full vCard backup for: " & contactName)
				
				-- Get vCard content safely
				try
					set contactNote to note of theContact
					set vcardContent to vcard of theContact as text
					
					cmLogDebug("Successfully extracted vCard content (" & (length of vcardContent) & " bytes)")
				on error vcardErr
					cmLogError("Error extracting vCard content: " & vcardErr)
					
					-- Show error dialog
					display dialog "Failed to extract vCard data: " & vcardErr with title "vCard Error" buttons {"OK"} default button "OK" with icon stop
					set backupResult to {success:false, reason:"Failed to extract vCard: " & vcardErr, path:""}
					return backupResult
				end try
				
				-- Create backup using utilities module
				if utilitiesScript is not missing value then
					-- Log the backup attempt
					cmLogInfo("Creating versioned backup for vCard")
					
					try
						set backupResult to utilitiesScript's createVersionedBackup(contactName, vcardContent, "vcard")
						
						-- Log the result
						if backupResult's success then
							cmLogInfo("Successfully created vCard backup at: " & backupResult's path)
							
							-- Show success dialog
							display dialog "Successfully created full backup for " & contactName & "." with title "Backup Successful" buttons {"OK"} default button "OK"
						else
							cmLogError("Failed to create vCard backup: " & backupResult's errorMessage)
							
							-- Show error dialog
							display dialog "Failed to create backup: " & backupResult's errorMessage with title "Backup Failed" buttons {"OK"} default button "OK" with icon stop
						end if
					on error backupErr
						cmLogError("Error during vCard backup: " & backupErr)
						
						-- Show error dialog
						display dialog "Error creating backup: " & backupErr with title "Backup Error" buttons {"OK"} default button "OK" with icon stop
						set backupResult to {success:false, reason:"Backup error: " & backupErr, path:""}
					end try
				else
					-- Log the missing utilities module
					log "Cannot create backup - utilities module not available"
					
					-- Show error dialog
					display dialog "Utilities module not available" with title "Module Error" buttons {"OK"} default button "OK" with icon stop
					set backupResult to {success:false, reason:"Utilities module not available", path:""}
				end if
			else if typeChoice is "Note Only" then
				-- Log the note-only backup
				cmLogDebug("Creating note-only backup for: " & contactName)
				
				-- Get note content safely
				try
					set contactNote to note of theContact
					
					if contactNote is missing value then
						set contactNote to ""
						cmLogDebug("Note is empty, will create backup with empty note")
					else
						cmLogDebug("Successfully extracted note content (" & (length of contactNote) & " bytes)")
					end if
				on error noteErr
					cmLogError("Error extracting note content: " & noteErr)
					
					-- Show error dialog
					display dialog "Failed to extract note data: " & noteErr with title "Note Error" buttons {"OK"} default button "OK" with icon stop
					set backupResult to {success:false, reason:"Failed to extract note: " & noteErr, path:""}
					return backupResult
				end try
				
				-- Create backup using utilities module
				if utilitiesScript is not missing value then
					-- Log the backup attempt
					cmLogInfo("Creating versioned backup for note")
					
					try
						set backupResult to utilitiesScript's createVersionedBackup(contactName, contactNote, "note")
						
						-- Log the result
						if backupResult's success then
							cmLogInfo("Successfully created note backup at: " & backupResult's path)
							
							-- Show success dialog
							display dialog "Successfully created note backup for " & contactName & "." with title "Backup Successful" buttons {"OK"} default button "OK"
						else
							cmLogError("Failed to create note backup: " & backupResult's errorMessage)
							
							-- Show error dialog
							display dialog "Failed to create note backup: " & backupResult's errorMessage with title "Backup Failed" buttons {"OK"} default button "OK" with icon stop
						end if
					on error backupErr
						cmLogError("Error during note backup: " & backupErr)
						
						-- Show error dialog
						display dialog "Error creating note backup: " & backupErr with title "Backup Error" buttons {"OK"} default button "OK" with icon stop
						set backupResult to {success:false, reason:"Backup error: " & backupErr, path:""}
					end try
				else
					-- Log the missing utilities module
					log "Cannot create note backup - utilities module not available"
					
					-- Show error dialog
					display dialog "Utilities module not available" with title "Module Error" buttons {"OK"} default button "OK" with icon stop
					set backupResult to {success:false, reason:"Utilities module not available", path:""}
				end if
			end if
		end tell
	on error generalErr
		-- Log any unexpected errors
		cmLogError("Unexpected error in backupContact: " & generalErr)
		
		-- Show error dialog
		display dialog "An unexpected error occurred during backup: " & generalErr with title "Backup Error" buttons {"OK"} default button "OK" with icon stop
		set backupResult to {success:false, reason:"Unexpected error: " & generalErr, path:""}
	end try
	
	-- Log function exit
	if utilitiesScript is not missing value then
		if backupResult's success then
			cmLogInfo("Contact backup operation completed successfully")
		else
			cmLogInfo("Contact backup operation completed with issues: " & backupResult's reason)
		end if
	end if
	
	return backupResult
end backupContact

-- Restore contact from backup with enhanced logging (placeholder for future implementation)
on restoreContact()
	-- Initialize default return value
	set restoreResult to {success:false, reason:"Not implemented", path:""}
	
	-- Log entry to function with module context
	cmLogDebug("Starting contact restoration operation (placeholder)")
	
	-- Log that this is a placeholder function
	cmLogInfo("Contact restoration feature not yet implemented")
	
	-- Show feature notice dialog
	cmLogDebug("Displaying feature notice dialog")
	
	display dialog "Contact restoration will be implemented in the next version." with title "Feature Notice" buttons {"OK"} default button "OK"
	
	-- Log user acknowledgment
	cmLogDebug("User acknowledged feature notice dialog")
	
	-- Log function exit
	cmLogDebug("Contact restoration operation completed (placeholder)")
	
	-- Since this is a placeholder, return a consistent result structure
	return {success:false, reason:"Feature not implemented yet", path:""}
end restoreContact

-- ==============================================
-- HELPER FUNCTIONS
-- ==============================================

-------------------------------------------------------------------------------
-- Handler: getPerformanceInfoForDialog
-- VERSION: 0.9.12 (2025-06-25)
-- PURPOSE: Gather performance information for display in mode selection dialog
-- RETURNS: Record with formatted performance info strings
-------------------------------------------------------------------------------
on getPerformanceInfoForDialog()
	set handlerName to "getPerformanceInfoForDialog"
	
	try
		-- Get performance baselines for both modes
		set simBaseline to utilitiesScript's getPerformanceBaseline("simulation")
		set updateBaseline to utilitiesScript's getPerformanceBaseline("update")
		
		-- Format simulation info
		if simBaseline's hasHistory then
			set simRate to (round ((1 / (simBaseline's avgSecondsPerContact)) * 10)) / 10
			set simulationInfo to "Avg: " & simRate & " contacts/sec (" & simBaseline's sessionCount & " sessions)"
		else
			set simulationInfo to "Estimated: ~25 contacts/sec (no history)"
		end if
		
		-- Format update info  
		if updateBaseline's hasHistory then
			set updateRate to (round ((1 / (updateBaseline's avgSecondsPerContact)) * 10)) / 10
			set updateInfo to "Avg: " & updateRate & " contacts/sec (" & updateBaseline's sessionCount & " sessions)"
		else
			set updateInfo to "Estimated: ~12 contacts/sec (no history)"
		end if
		
		-- Get system performance profile
		set profileInfo to simBaseline's profile
		if profileInfo is "Unknown" then set profileInfo to "Not yet determined"
		
		return {simulationInfo:simulationInfo, updateInfo:updateInfo, profileInfo:profileInfo}
		
	on error perfErr
		cmLogWarning("Could not get performance info: " & perfErr)
		return {simulationInfo:"Performance data unavailable", updateInfo:"Performance data unavailable", profileInfo:"Unknown"}
	end try
end getPerformanceInfoForDialog

-------------------------------------------------------------------------------
-- Handler: showScopeSelectionWithEstimates
-- VERSION: 0.9.12 (2025-06-25)
-- PURPOSE: Enhanced scope selection with contact count and time estimates
-- INPUTS:  processingMode (text) - "simulation" or "update"
-- RETURNS: Record {scope, contactCount, cancelled}
-------------------------------------------------------------------------------
on showScopeSelectionWithEstimates(processingMode)
	set handlerName to "showScopeSelectionWithEstimates"
	
	try
		-- Get contact counts
		set selectedCount to 0
		set totalCount to 0
		
		tell application "Contacts"
			try
				set selectedCount to count of selection
				set totalCount to count of every person
			on error countErr
				cmLogWarning("Could not get contact counts: " & countErr)
			end try
		end tell
		
		-- Create scope selection dialog
		set scopePrompt to "Choose contacts to process:" & return & return
		set scopePrompt to scopePrompt & "📋 Selected: " & selectedCount & " contacts currently highlighted"
		
		if selectedCount > 0 then
			set estimates to utilitiesScript's estimateProcessingTime(selectedCount, 0, 0, processingMode)
			set scopePrompt to scopePrompt & return & "   Estimated time: ~" & utilitiesScript's formatTimeEstimate(estimates's estimatedTotalTime)
		end if
		
		set scopePrompt to scopePrompt & return & return & "📚 All: " & totalCount & " contacts in your address book"
		
		if totalCount > 0 then
			set estimates to utilitiesScript's estimateProcessingTime(totalCount, 0, 0, processingMode)
			set scopePrompt to scopePrompt & return & "   Estimated time: ~" & utilitiesScript's formatTimeEstimate(estimates's estimatedTotalTime)
		end if
		
		-- Show dialog with appropriate default
		set defaultChoice to "Selected"
		if selectedCount = 0 then set defaultChoice to "All"
		
		set scopeRes to display dialog scopePrompt with title "Contact Scope" buttons {"Cancel", "Selected", "All"} default button defaultChoice
		set scopeChoice to button returned of scopeRes
		
		if scopeChoice is "Cancel" then
			return {scope:"", contactCount:0, cancelled:true}
		else if scopeChoice is "Selected" then
			return {scope:"selected", contactCount:selectedCount, cancelled:false}
		else
			return {scope:"all", contactCount:totalCount, cancelled:false}
		end if
		
	on error scopeErr
		cmLogError("Scope selection error: " & scopeErr)
		return {scope:"", contactCount:0, cancelled:true}
	end try
end showScopeSelectionWithEstimates

-------------------------------------------------------------------------------
-- Handler: showProcessingConfirmation
-- VERSION: 0.9.12 (2025-06-25)
-- PURPOSE: Final confirmation dialog with detailed time estimate and performance info
-- INPUTS:  contactCount (integer), estimates (record), processingMode (text)
-- RETURNS: Record {cancelled}
-------------------------------------------------------------------------------
on showProcessingConfirmation(contactCount, estimates, processingMode)
	set handlerName to "showProcessingConfirmation"
	
	try
		set confirmPrompt to "Ready to process " & contactCount & " contacts" & return & return
		
		-- Add mode-specific info
		if processingMode is "simulation" then
			set confirmPrompt to confirmPrompt & "🔍 Mode: Simulation (preview only)" & return
		else
			set confirmPrompt to confirmPrompt & "✏️  Mode: Edit (changes will be applied)" & return
		end if
		
		-- Add time estimate
		set timeEstimate to utilitiesScript's formatTimeEstimate(estimates's estimatedTotalTime)
		set confirmPrompt to confirmPrompt & "⏱  Estimated time: " & timeEstimate & return
		
		-- Add performance context
		if estimates's hasHistory then
			set confirmPrompt to confirmPrompt & "📊 Based on your system's performance history"
		else
			set confirmPrompt to confirmPrompt & "📊 Based on average system performance"
		end if
		
		set confirmPrompt to confirmPrompt & return & return & "Continue with processing?"
		
		set confirmRes to display dialog confirmPrompt with title "Confirm Processing" buttons {"Cancel", "Start Processing"} default button "Start Processing"
		
		return {cancelled:(button returned of confirmRes is "Cancel")}
		
	on error confirmErr
		cmLogError("Confirmation dialog error: " & confirmErr)
		return {cancelled:true}
	end try
end showProcessingConfirmation

-------------------------------------------------------------------------------
-- Handler: generateConsoleSummary
-- VERSION: 1.3.0-mode-aware-baseline (2025-07-01)
-- PURPOSE: Generate enhanced console summary with mode-aware performance metrics
-- CHANGELOG:
--   • 1.3.0-mode-aware-baseline: FIXED - Added processingMode parameter for accurate baseline comparison
--     - Console report now uses actual processing mode (simulation vs update) for baseline lookup
--     - Eliminates incorrect baseline comparisons when user selects Edit mode
--     - Maintains all existing functionality with backward compatibility via optional parameter
--     - Enhanced mode validation and fallback to prevent errors
--   • 1.2.0-direct-data: Replaced unreliable text parsing with direct ContactOperations data access
--   • 1.1.0-performance: Added processing rate and performance comparison data
--   • Enhanced with baseline comparison and system performance profile
-------------------------------------------------------------------------------
on generateConsoleSummary(fullReport, reportFilePath, processingMode)
	set handlerName to "generateConsoleSummary"
	
	-- ✅ NEW: Handle optional processingMode parameter for backward compatibility
	if processingMode is missing value then
		set processingMode to "simulation" -- Safe default for backward compatibility
		cmLogDebug(handlerName & "(): No processingMode provided, defaulting to simulation")
	else
		-- Validate processingMode parameter
		if processingMode is not "simulation" and processingMode is not "update" then
			cmLogDebug(handlerName & "(): Invalid processingMode '" & processingMode & "', defaulting to simulation")
			set processingMode to "simulation"
		end if
	end if
	
	cmLogDebug(handlerName & "(): Generating enhanced console summary with direct data access for " & processingMode & " mode")
	
	-- Parse existing report data (preserved for other fields)
	set reportLines to paragraphs of fullReport
	set contactsExamined to ""
	set contactsModified to ""
	set charsRemoved to ""
	set percentReduction to ""
	set processingTime to ""
	set avgTimePerContact to ""
	
	repeat with reportLine in reportLines
		if reportLine contains "• Total contacts examined:" then
			set contactsExamined to reportLine
		else if reportLine contains "• Contacts modified:" then
			set contactsModified to reportLine
		else if reportLine contains "• Total characters removed:" then
			set charsRemoved to reportLine
		else if reportLine contains "• Percentage reduction:" then
			set percentReduction to reportLine
		else if reportLine contains "• Total processing time:" then
			set processingTime to reportLine
		else if reportLine contains "• Average per contact (all):" then
			set avgTimePerContact to reportLine
		end if
	end repeat
	
	-- ✅ ENHANCED: Get performance data directly from source instead of unreliable text parsing
	set performanceData to ""
	try
		if contactOpsScript is not missing value then
			-- Get fresh performance data from ContactOperations (same source as dialog report)
			try
				set perfData to contactOpsScript's getProcessingStatsRecord()
				set contactsProcessed to perfData's totalExamined
				set actualElapsedTime to perfData's elapsedSeconds
				
				cmLogDebug(handlerName & "(): Direct data access - contacts:" & contactsProcessed & ", time:" & actualElapsedTime & "s, mode:" & processingMode)
				
				if actualElapsedTime > 0 and contactsProcessed > 0 then
					set processingRate to contactsProcessed / actualElapsedTime
					set rateDisplay to contactOpsScript's formatProcessingRate(contactsProcessed, actualElapsedTime)
					
					-- ✅ FIXED: Use actual processing mode for baseline comparison instead of hardcoded "simulation"
					try
						if utilitiesScript is not missing value then
							set baseline to utilitiesScript's getPerformanceBaseline(processingMode)
							if baseline's hasHistory then
								set baselineRate to 1.0 / (baseline's avgSecondsPerContact)
								set comparisonPct to ((processingRate / baselineRate) * 100) as integer
								set profileInfo to baseline's profile
								
								if comparisonPct > 110 then
									set comparison to " (↗️ " & comparisonPct & "% of baseline)"
								else if comparisonPct < 90 then
									set comparison to " (↙️ " & comparisonPct & "% of baseline)"
								else
									set comparison to " (≈ baseline)"
								end if
								
								set performanceData to "• Processing rate: " & rateDisplay & comparison
								if profileInfo is not "Unknown" then
									set performanceData to performanceData & return & "                                   • System performance: " & profileInfo
								end if
								
								cmLogDebug(handlerName & "(): " & processingMode & " baseline comparison - current:" & processingRate & " contacts/s, baseline:" & baselineRate & " contacts/s, comparison:" & comparisonPct & "%")
							else
								set performanceData to "• Processing rate: " & rateDisplay & " (no " & processingMode & " baseline)"
								cmLogDebug(handlerName & "(): No " & processingMode & " baseline data available")
							end if
						else
							set performanceData to "• Processing rate: " & rateDisplay
							cmLogDebug(handlerName & "(): Utilities module unavailable for baseline comparison")
						end if
					on error baselineErr
						cmLogDebug(handlerName & "(): Baseline comparison failed: " & baselineErr)
						set performanceData to "• Processing rate: " & rateDisplay
					end try
				else
					-- Handle edge cases with improved messaging
					if contactsProcessed = 0 then
						set performanceData to "• Processing rate: no contacts processed"
					else
						set performanceData to "• Processing rate: calculating... (time data unavailable)"
					end if
					cmLogDebug(handlerName & "(): Invalid performance data - contacts:" & contactsProcessed & ", time:" & actualElapsedTime)
				end if
				
			on error dataAccessErr
				cmLogDebug(handlerName & "(): Direct data access failed: " & dataAccessErr)
				-- ✅ FALLBACK: Use legacy text parsing approach if direct access fails
				set performanceData to my generateFallbackPerformanceData(processingTime)
			end try
		else
			cmLogDebug(handlerName & "(): ContactOperations module unavailable")
			set performanceData to "• Processing rate: module unavailable"
		end if
	on error perfErr
		cmLogDebug(handlerName & "(): Performance data extraction failed: " & perfErr)
		set performanceData to ""
	end try
	
	-- Build enhanced console summary (unchanged)
	set reportFileName to utilitiesScript's getFilenameFromPath(reportFilePath)
	set reportSpacing to "                                   "
	
	set consoleSummary to "📊 CLEANUP COMPLETE:" & return & ¬
		reportSpacing & contactsExamined & return & ¬
		reportSpacing & contactsModified & return & ¬
		reportSpacing & charsRemoved & return & ¬
		reportSpacing & percentReduction & return & ¬
		reportSpacing & processingTime & return
	
	-- ✅ ADD PERFORMANCE DATA if available
	if performanceData is not "" then
		set consoleSummary to consoleSummary & reportSpacing & performanceData & return
	end if
	
	set consoleSummary to consoleSummary & reportSpacing & "📂 Report saved: " & reportFileName
	
	-- Output as single milestone log
	cmLogMilestone(consoleSummary)
end generateConsoleSummary

-- ✅ PRESERVED: Fallback performance data generation using text parsing (legacy compatibility)
on generateFallbackPerformanceData(processingTimeText)
	set handlerName to "generateFallbackPerformanceData"
	
	try
		cmLogDebug(handlerName & "(): Using fallback text parsing method")
		
		-- Access global variables as fallback
		global contactsProcessed, totalCharsRemoved
		if contactsProcessed > 0 then
			-- Parse time from text (legacy approach preserved)
			set actualElapsedTime to 2.0 -- Safe fallback
			
			try
				if processingTimeText contains ":" then
					set colonPos to offset of ":" in processingTimeText
					if colonPos > 0 then
						set timeStr to text (colonPos + 1) thru -1 of processingTimeText
						
						-- Clean text before parsing
						set cleanTimeStr to timeStr
						set cleanTimeStr to utilitiesScript's replaceText(cleanTimeStr, " seconds", "")
						set cleanTimeStr to utilitiesScript's replaceText(cleanTimeStr, " second", "")
						set cleanTimeStr to utilitiesScript's replaceText(cleanTimeStr, "seconds", "")
						set cleanTimeStr to utilitiesScript's replaceText(cleanTimeStr, "second", "")
						
						-- Trim spaces
						repeat while cleanTimeStr starts with " "
							set cleanTimeStr to text 2 thru -1 of cleanTimeStr
						end repeat
						repeat while cleanTimeStr ends with " "
							set cleanTimeStr to text 1 thru -2 of cleanTimeStr
						end repeat
						
						set actualElapsedTime to utilitiesScript's parseLocaleNumber(cleanTimeStr)
						if actualElapsedTime ≤ 0 then set actualElapsedTime to 2.0
					end if
				end if
			on error timeParseErr
				cmLogDebug(handlerName & "(): Text parsing failed: " & timeParseErr)
				set actualElapsedTime to 2.0
			end try
			
			-- Calculate rate using fallback method
			set processingRate to contactsProcessed / actualElapsedTime
			set rateDisplay to contactOpsScript's formatProcessingRate(contactsProcessed, actualElapsedTime)
			
			return "• Processing rate: " & rateDisplay & " (fallback calculation)"
		else
			return "• Processing rate: no data available"
		end if
	on error fallbackErr
		cmLogDebug(handlerName & "(): Fallback method failed: " & fallbackErr)
		return ""
	end try
end generateFallbackPerformanceData


-- ============================================
-- Handler: getISOTimestamp
-- VERSION: 0.9.9 (2025-06-16)
-- PURPOSE: Returns the current date/time as YYYY-MM-DD hh:mm:ss (ISO 8601)
-- INPUTS:  dateObj (date), optional (defaults to current date)
-- RETURNS: text
-- ============================================
on getISOTimestamp(optionalDate)
	try
		if optionalDate is missing value then
			set theDate to (current date)
		else if class of optionalDate is date then
			set theDate to optionalDate
		else if class of optionalDate is text then
			-- fallback: return the string, don't try to extract fields
			return optionalDate
		else
			return "unknown-date"
		end if
		set y to year of theDate as string
		set m to text -2 thru -1 of ("0" & (month of theDate as integer))
		set d to text -2 thru -1 of ("0" & (day of theDate as string))
		set h to text -2 thru -1 of ("0" & (hours of theDate as string))
		set min to text -2 thru -1 of ("0" & (minutes of theDate as string))
		set s to text -2 thru -1 of ("0" & (seconds of theDate as string))
		return y & "-" & m & "-" & d & " " & h & ":" & min & ":" & s
	on error
		return "unknown-date"
	end try
end getISOTimestamp

-- PURPOSE: Toggle simulation mode with enhanced logging and status tracking
on toggleSimulationMode()
	-- Log entry to function with module context
	cmLogDebug("Toggle simulation mode requested")
	
	-- Access global mode variable
	global testMode
	
	-- Log the current state before change
	cmLogDebug("Current simulation mode: " & testMode)
	
	-- Toggle the mode
	set testMode to not testMode
	
	-- Log the state change with detailed context
	if utilitiesScript is not missing value then
		if testMode then
			cmLogInfo("Simulation mode ENABLED - No changes will be made to contacts")
		else
			cmLogInfo("Simulation mode DISABLED - Changes will be applied to contacts")
		end if
	end if
	
	-- Inform ContactOperations module of the change if available
	try
		if contactOpsScript is not missing value then
			-- Log the propagation attempt
			cmLogDebug("Propagating simulation mode to ContactOperations module")
			
			contactOpsScript's setDebugMode(testMode)
			
			-- Log successful propagation
			cmLogDebug("Simulation mode successfully propagated to ContactOperations")
		end if
	on error propagateErr
		-- Log propagation error
		cmLogError("Error propagating simulation mode: " & propagateErr)
	end try
	
	-- Display confirmation dialog
	cmLogDebug("Displaying simulation mode confirmation dialog")
	
	if testMode then
		display dialog "Simulation mode ENABLED. No changes will be made to your contacts." buttons {"OK"} default button "OK"
	else
		display dialog "Simulation mode DISABLED. Changes will be applied to your contacts." buttons {"OK"} default button "OK"
	end if
	
	-- Log user acknowledgment
	cmLogDebug("User acknowledged simulation mode change dialog")
	
	-- Return the new mode status for reference by caller
	return testMode
end toggleSimulationMode

-- ==============================================
-- STATISTICS MANAGEMENT MENU
-- ==============================================

-- ============================================
-- Handler: handleStatisticsManagement  
-- VERSION: 1.2.0-export-simplified (2025-07-03)
-- PURPOSE: Statistics management with simplified export handling
-- CHANGES: Integrated modern rebuildCumulativeStats() with comprehensive results handling
-- CHANGES: Streamlined export logic to rely on enhanced saveTextToFile()
-- REPLACES: Complex export error handling with simple saveTextToFile() call
-- ============================================
on handleStatisticsManagement()
	-- Initialize return value
	set operationResult to ""
	
	-- Log entry to function with module context
	cmLogDebug("Entering Statistics Management menu")
	
	-- Enhanced statistics management dialog
	set statsText to "Statistics Management:" & return & return
	set statsText to statsText & "Select from the following options:" & return & return
	set statsText to statsText & "• View Statistics: See current contact processing statistics" & return
	set statsText to statsText & "• Export Statistics: Save statistics report to file" & return
	set statsText to statsText & "• Rebuild Statistics: Scan all contacts to rebuild stats from CCC footers"
	
	-- Enhanced 3-button menu with Rebuild Statistics prominently featured
	set statsChoice to button returned of (display dialog statsText with title "Statistics Management" buttons {"Go Back", "Rebuild Statistics", "View Statistics"} default button "View Statistics")
	
	-- Log user's selection with proper context
	cmLogDebug("User selected: " & statsChoice & " in Statistics Management")
	
	-- Handle Go Back
	if statsChoice is "Go Back" then
		cmLogDebug("User returning to previous menu from Statistics Management")
		return operationResult
	end if
	
	-- Handle view statistics (COMPLETE IMPLEMENTATION)
	if statsChoice is "View Statistics" then
		cmLogDebug("User requested to view optimization statistics")
		
		-- Check if ContactOperations module is available
		if contactOpsScript is missing value then
			cmLogError("Cannot view statistics - ContactOperations module not available")
			display dialog "Statistics module not available." with title "Module Error" buttons {"OK"} default button "OK" with icon caution
		else
			try
				-- Get the statistics report
				set statsReport to contactOpsScript's getCumulativeStatsReport()
				
				-- Display the statistics with export option
				set statsResult to display dialog statsReport with title "Contact Processing Statistics" buttons {"Close", "Export to File"} default button "Close"
				
				-- Handle export option
				if button returned of statsResult is "Export to File" then
					cmLogDebug("User requested to export statistics to file")
					
					-- Create export filename with timestamp
					set currentDate to current date
					set exportFilename to "Contact_Statistics_" & my formatDateForFilename(currentDate) & ".txt"
					
					-- Build full export path
					if utilitiesScript is not missing value then
						global reportsFolder
						set exportPath to utilitiesScript's buildFilePath(reportsFolder, exportFilename)
						
						-- Create export text with header
						set exportText to "Contact Management System - Statistics Report" & return
						set exportText to exportText & "Generated: " & (currentDate as string) & return
						set exportText to exportText & "================================================" & return & return
						set exportText to exportText & statsReport
						
						-- ✅ SIMPLIFIED: Single call to enhanced saveTextToFile
						set saveResult to utilitiesScript's saveTextToFile(exportText, exportPath)
						if saveResult then
							cmLogInfo("Statistics exported successfully to: " & exportPath)
							tell application "Finder" to open file exportPath
							display dialog "Statistics exported successfully and opened." with title "Export Complete" buttons {"OK"} default button "OK"
						else
							cmLogError("Failed to save statistics export file")
							display dialog "Error saving statistics file." with title "Export Failed" buttons {"OK"} default button "OK" with icon caution
						end if
					else
						cmLogError("Utilities module not available for export operation")
						display dialog "Cannot export - Utilities module not available." with title "Export Error" buttons {"OK"} default button "OK" with icon stop
					end if
				end if
				
			on error statsErr
				-- Log statistics retrieval error
				cmLogError("Error retrieving statistics: " & statsErr)
				-- Show error dialog
				display dialog "Error retrieving statistics: " & statsErr with title "Statistics Error" buttons {"OK"} default button "OK" with icon caution
			end try
		end if
	end if
	
	-- ✅ NEW: Handle Rebuild Statistics with modern implementation
	if statsChoice is "Rebuild Statistics" then
		cmLogDebug("User requested statistics rebuild")
		
		-- Check module availability
		if contactOpsScript is missing value then
			cmLogError("Cannot rebuild statistics - ContactOperations module not available")
			display dialog "Statistics module not available." with title "Module Error" buttons {"OK"} default button "OK" with icon caution
			return handleStatisticsManagement()
		end if
		
		-- Enhanced confirmation with operation details
		set confirmText to "This will scan all contacts in your address book to rebuild statistics from CCC footers." & return & return
		set confirmText to confirmText & "📋 What this does:" & return
		set confirmText to confirmText & "• Scans every contact for CCC Summary footers" & return
		set confirmText to confirmText & "• Extracts character savings data" & return
		set confirmText to confirmText & "• Rebuilds cumulative statistics" & return
		set confirmText to confirmText & "• May take time with large address books" & return & return
		set confirmText to confirmText & "Continue with statistics rebuild?"
		
		set confirmRebuild to button returned of (display dialog confirmText with title "Confirm Statistics Rebuild" buttons {"Cancel", "Continue"} default button "Continue")
		
		cmLogDebug("User selected: " & confirmRebuild & " for statistics rebuild confirmation")
		
		if confirmRebuild is "Continue" then
			-- Show operation starting notification
			cmLogInfo("Beginning statistics rebuild operation")
			display notification "Starting statistics rebuild..." with title "Contact Management System"
			
			-- Call the modern rebuild function
			try
				cmLogDebug("Calling modern rebuildCumulativeStats in ContactOperations")
				set rebuildResult to contactOpsScript's rebuildCumulativeStats()
				
				-- Handle comprehensive results
				if rebuildResult's success then
					cmLogInfo("Statistics rebuild completed successfully")
					
					-- Format comprehensive success message
					set resultText to "✅ Statistics Rebuild Complete!" & return & return
					set resultText to resultText & "📊 Scan Results:" & return
					set resultText to resultText & "• Contacts scanned: " & rebuildResult's scannedContacts & return
					set resultText to resultText & "• CCC contacts found: " & rebuildResult's cccContacts & return
					
					if rebuildResult's errors > 0 then
						set resultText to resultText & "• Contacts with errors: " & rebuildResult's errors & return
					end if
					
					set resultText to resultText & return & "📈 Updated Statistics:" & return
					set resultText to resultText & "• Total contacts optimized: " & rebuildResult's stats's totalContacts & return
					set resultText to resultText & "• Total characters saved: " & rebuildResult's stats's totalChars & return
					
					set avgFormatted to (round ((rebuildResult's stats's avgCharsPerContact) * 10)) / 10
					set resultText to resultText & "• Average savings: " & avgFormatted & " characters per contact" & return
					
					-- Add processing performance
					if rebuildResult's processingTime > 0 then
						set processingRate to (rebuildResult's scannedContacts) / (rebuildResult's processingTime)
						set resultText to resultText & return & "⚡ Performance: " & (round (processingRate * 10)) / 10 & " contacts/second"
					end if
					
					cmLogDebug("Displaying comprehensive rebuild success dialog")
					display dialog resultText with title "Statistics Rebuild Complete" buttons {"OK"} default button "OK"
					
					-- Show completion notification
					display notification "Statistics rebuild completed successfully!" with title "Contact Management System"
					
				else
					-- Handle rebuild failure with detailed error reporting
					cmLogError("Statistics rebuild failed: " & rebuildResult's reason)
					
					set errorText to "❌ Statistics Rebuild Failed" & return & return
					set errorText to errorText & "Reason: " & rebuildResult's reason & return & return
					set errorText to errorText & "📊 Partial Results:" & return
					set errorText to errorText & "• Contacts scanned: " & rebuildResult's scannedContacts & return
					set errorText to errorText & "• Errors encountered: " & rebuildResult's errors
					
					if rebuildResult's errors > 0 and (count of rebuildResult's errorContacts) > 0 then
						set errorText to errorText & return & return & "Problem contacts: "
						-- Show first few error contacts
						set errorCount to count of rebuildResult's errorContacts
						if errorCount > 3 then
							set errorText to errorText & (items 1 thru 3 of rebuildResult's errorContacts as string) & "... (and " & (errorCount - 3) & " more)"
						else
							set errorText to errorText & (rebuildResult's errorContacts as string)
						end if
					end if
					
					display dialog errorText with title "Statistics Rebuild Failed" buttons {"OK"} default button "OK" with icon caution
				end if
				
			on error rebuildErr
				-- Handle critical rebuild errors
				cmLogError("Critical error during statistics rebuild: " & rebuildErr)
				display dialog "An unexpected error occurred during statistics rebuild:" & return & return & rebuildErr with title "Rebuild Error" buttons {"OK"} default button "OK" with icon stop
			end try
		else
			cmLogDebug("Statistics rebuild cancelled by user")
		end if
	end if
	
	-- Return to statistics management menu
	return handleStatisticsManagement()
end handleStatisticsManagement

-- ==============================================
-- MAIN ENTRY POINT
-- ==============================================

-------------------------------------------------------------------------------
--  run()                             ▸  Entrypoint
--  v6.0.0-beta1-mergedInit  (2025-05-12)
-------------------------------------------------------------------------------
on run {}
	-- log "🟦 ENTRY POINT: ContactManager.run {} called at " & (current date)
	
	-- Create consistent starting message format (even without Utilities)
	set startTime to current date
	set formattedStart to getISOTimestamp(startTime) & " ✅ 🚦 Contact Management System starting: v" & SYSTEM_VERSION
	
	if utilitiesScript is not missing value then
		-- Direct logging if utilities ready (should not happen at startup)
		utilitiesScript's milestoneLog("ContactManager", "🚦 Contact Management System starting: v" & SYSTEM_VERSION)
	else
		-- log "🟦 DISCOVERY: Utilities not available at run() start"
		-- SINGLE-BUFFER APPROACH: Only use buffered startup message
		cmLogMilestone("🚦 Contact Management System starting: v" & SYSTEM_VERSION)
	end if
	
	------------------------------------------------------------
	-- 0 ▸  Full initialization (covers steps 1–4 + backup + self-test)
	------------------------------------------------------------
	if not initializeSystem() then
		-- initializeSystem handles its own errors & dialogs
		return "Initialization failed."
	end if
	
	cmLogMilestone("🟢 System ready. Opening main menu...")
	
	------------------------------------------------------------
	-- 1 ▸  Welcome dialog
	------------------------------------------------------------
	
	cmLogDebug("Displaying welcome message")
	display dialog "Welcome to " & scriptName & " !" & return & return & ¬
		"This script suite provides utilities for the macOS Contacts app." & return & return & ¬
		¬
			"⚠️  Please back up your Contacts database before making changes." with title scriptTitle buttons {"Exit", "Continue"} default button "Continue"
	set initialChoice to button returned of result
	if initialChoice is "Exit" then
		cmLogInfo("User canceled script at welcome screen")
		return "Script canceled by user."
	end if
	
	------------------------------------------------------------
	-- 2 ▸  Main menu loop
	------------------------------------------------------------
	repeat until shouldExitScript
		
		try
			set menuResult to my showMainMenu()
		on error menuErr
			cmLogError("showMainMenu() error: " & menuErr)
			display dialog "Menu Error: " & menuErr buttons {"OK"}
			return "Menu error: " & menuErr
		end try
		
		if menuResult is "clean_contacts" then
			cmLogDebug("Dispatch → Contact Cleaning")
			my handleContactCleaning()
			
		else if menuResult is "group_management" then
			cmLogDebug("Dispatch → Group Management")
			my handleGroupManagement()
			
		else if menuResult is "tools_settings" then
			cmLogDebug("Dispatch → Tools & Settings")
			my handleToolsAndSettings()
			
		else if menuResult is "exit_script" then
			cmLogDebug("Exit requested – terminating loop")
			exit repeat
		end if
	end repeat
	
	------------------------------------------------------------
	-- 3 ▸  Final cleanup & exit
	------------------------------------------------------------
	cmLogInfo("Script execution completed successfully")
	return "Script completed successfully."
end run




