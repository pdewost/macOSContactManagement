-- ==========================================================
-- MODULE: ContactOperations
--  VERSION: 0.9.9 (2025-09-08)
-- ==========================================================
-- Copyright: ©Philippe Dewost 2025
--  PURPOSE:
--      * Note/field deduplication, stats/exports, block logic, and pipeline cleaning core for CCC Contact Cleaner.
--
-- ==========================================================
--  CHANGELOG
-- ==========================================================
-- 0.9.9 (2025-09-08)
-- • Implemented deduplicateConsecutiveTextBlocks v2.0.0 with fingerprint matching
-- • Unified handling of formatted+flattened duplicates with/without "see more" markers
-- • Fixed paragraph deduplication failure when Education section missing
-- • Can replace deduplicateFlattenedSeeMoreBlocksEnhanced with unified handler
-- 0.9.8 (2025-07-06)
-- • Fixing rebuildCumulativeStats
-- 0.9.7 (2025-06-09)
-- • Stabilized deduplicateFlattenedSeeMoreBlocksEnhanced
-- • Record creation date and last modification date before CCC in footer
-- 0.9.6-alpha  (2025-06-04)
-- • Cleaned deprecated helpers, v1 pipeline functions, and unused v2 handlers
-- • Removed dead code: vCard backup/restore chain, unused text processing functions
-- • Stabilized V2 pipeline as the single processing path
-- • Updated run() handler to test actual V2 pipeline components
-- 0.9.5-alpha4 (2025-06-04):
-- • Ended long fight to detect and halve long duplicated paragraphs ending with ...see more
-- • Stabilized pipeline and handlers
--
-- ==========================================================
--  FEATURE REQUESTS / NEXT STEPS
-- ==========================================================
-- • Implement performance baseline threshold (min 5 contacts before updating)
-- • Fix Utilities early logging (lazy initialization)
-- • Fix misleading chunk messages for small batches
-- • Remove deduplicateFlattenedSeeMoreBlocksEnhanced (replaced by v2.0.0 unified)
-- • Switch footer generation and processed note backup in processContactNote
-- • Simplify menu/UX to flat, list-based selection (no nested dialog traps)
-- • Implement fuzzy block deduplication for edge cases
-- • Add batch processing and reporting with loading contacts in chunks
-- • Enhance CCC footer generation with better metrics and stats
-- • Complete group tag management system (extract tags from notes, sync with groups)
-- • Add Groups as Finder tags in exported vCards
-- • Automatic security tagging based on note contents
-- • Finish CLI automation entry-point parity with UX flow
--
-- ==========================================================
-- KNOWN ISSUES
-- ==========================================================
-- * Performance baseline corrupted by single-contact operations
-- * Utilities logs appear before system initialization
-- * Chunk messages misleading for small batches
-- * Some rare non-consecutive or fuzzy duplicates may still escape collapse
-- * Deduplication can be expensive for huge notes (consider timeouts or limits)
-- * Some character count metrics could be made more robust
--
-- ==========================================================
-- CORE HANDLERS & STATUS
-- ==========================================================
-- processContactsWithScopeOptimized() - Main batch processing entry point [ROBUST]
-- processContactDataOptimized() - Optimized contact processing [ROBUST]
-- processNoteContentOptimized() - Optimized processing pipeline [ROBUST]
-- normalizeContactLine() - Per-line LinkedIn/junk cleanup [ROBUST]
-- deduplicateConsecutiveTextBlocks() v2.0.0 - Unified duplicate removal [ROBUST]
-- deduplicateConsecutiveLineBlocks() - Multi-line block deduplication [ROBUST]
-- deduplicateFlattenedSeeMoreBlocksEnhanced() - [DEPRECATED - use deduplicateConsecutiveTextBlocks]
-- deduplicateConsecutiveLines() - Single line deduplication [ROBUST]
-- trimLeadingTrailingBlankLines() - Text cleanup [ROBUST]
--
-- === SUPPORT FUNCTIONS ===
-- updateCCCFooter() - Footer generation and management [ROBUST]
-- extractExistingFooter() - Footer detection and parsing [ROBUST]
-- getCumulativeStatsReport() - Statistics reporting [ROBUST]
-- checkAndReportProgress() - Adaptive progress reporting [ROBUST]
-- getSessionPerformanceData() - Performance metrics collection [ROBUST]
--
-- === STATISTICS & REPORTING ===
-- loadCumulativeStats() - Statistics persistence [ROBUST]
-- saveCumulativeStats() - Statistics storage [ROBUST]
-- rebuildCumulativeStats() - Full statistics rebuild [ROBUST]
-- updateCumulativeStats() - Incremental stats updates [ROBUST]
-- generateStatsReport() - Enhanced report generation [ROBUST]

use AppleScript version "2.4"
use framework "Foundation"
use scripting additions

-- ==========================================================
-- SCRIPT CONFIGURATION
-- ==========================================================

-- Version properties
property scriptVersion : "0.9.9" -- Module's internal version (for development tracking)

property scriptFolder : ""
property backupFolder : ""
property logsFolder : ""
property reportsFolder : ""
property sessionFolder : ""

-- Reference to utilities module
property utilitiesScript : missing value

-- Properties for optimized processing (# of contacts fetched and loaded at once)
property CHUNK_SIZE : 50 -- ⚠️ edit depending on how large your bacthes may be

-- ==========================================================
-- PERFORMANCE TRACKING STATE
-- ==========================================================
property lastProgressReport : 0
property lastProgressTime : missing value

-- Adaptive time-based reporting
global lastTimeReport, reportingInterval, adaptiveReportingInitialized

-- Global variables for statistics
global totalEdits, totalOriginalLength
-- Enhanced tracking counters
global contactsProcessed -- Total contacts examined
global contactsSkippedFooter -- Skipped: already has CCC footer  
global contactsSkippedEmpty -- Skipped: empty note
global contactsWithContent -- Actually processed note content
global contactsModified -- Had changes applied
global contactsWithErrors -- Threw processing errors
global errorContactsList -- List of contact names with errors

global debugMode, testMode, startTime

-- What skip/force mode we start with on each session (immutable default)
property defaultForceCleanupMode : "No, skip processed notes"

-- Live flag, set by the UI via setForceCleanupMode()
property forceCleanup : defaultForceCleanupMode

property dupBlockCount : 0
property dupLinesTotal : 0

-- Group Tag Management Configuration
property GROUP_TAG_PREFIX : ":::groups: "
property GROUP_TAG_SUFFIX : " :::"
property GROUP_SEPARATOR : " | "
property GROUP_RECONCILIATION_STRATEGY : "groups-to-tags" -- or "tags-to-groups" or "merge"

-- ==========================================================
-- INITIALIZATION
-- SILENT DURING STARTUP: All initialization logging handled by ContactManager
-- ==========================================================

-------------------------------------------------------------------------------
-- Handler: initializeModule
-- VERSION: 0.9.9 (2025-06-22)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- WHEN:   Called during loadModules() phase of system initialization
-- HOW:    Returns success/failure without logging, parent handles logging
-- BREAKS:  Nothing - same interface, eliminates chronological ordering issues
-------------------------------------------------------------------------------
on initializeModule()
	global debugMode
	global MODULE_NAME, deprecationWarningShown
	
	-- Set module identifiers
	set MODULE_NAME to "Contact_Operations"
	
	-- Initialize all processing variables
	try
		initializeContactProcessing()
	on error initErr
		-- Return error to parent instead of logging directly
		error "ContactOperations processing init failed: " & initErr
	end try
	
	-- Initialize other module-specific variables
	try
		set forceCleanup to defaultForceCleanupMode
		set deprecationWarningShown to false
	on error varErr
		error "ContactOperations variables init failed: " & varErr
	end try
	
	-- NO LOGGING during startup - ContactManager handles all startup logging
	-- This eliminates multi-buffer complexity and chronological ordering issues
	-- Parent (loadModules) will log success/failure appropriately
	
	return true
end initializeModule

-- PURPOSE: Initialize all required processing variables with validation and error tracking
on initializeContactProcessing()
	
	-- Track initialization status for logging
	set initSuccess to true
	
	try
		-- Direct initialization of ALL required counters and flags		
		global totalEdits, contactsProcessed, contactsModified, errorCount
		global inlineDuplicatesCount, lineDuplicatesCount, blockDuplicatesCount
		global profilesModified, profilesCharsRemoved
		global startTime, changeCount, checkCount, duplicatesRemoved
		global inlineCharsRemoved, lineCharsRemoved, blockCharsRemoved, charsRemovedLine
		global debugMode, testMode, processedContactsList
		global totalOriginalLength
		
		-- Set explicit initial values
		set totalEdits to 0
		set contactsProcessed to 0
		set contactsModified to 0
		set errorCount to 0
		set inlineDuplicatesCount to 0
		set lineDuplicatesCount to 0
		set blockDuplicatesCount to 0
		set profilesModified to 0
		set totalOriginalLength to 0
		
		-- ── Tag-only counters (for issue-flag summary) ──
		global tagOnlyCounts, tagLinkedIn, tagDupLinkedIn, tagDupURL, tagMultiProfile
		set tagOnlyCounts to 0
		set tagLinkedIn to 0
		set tagDupLinkedIn to 0
		set tagDupURL to 0
		set tagMultiProfile to 0
		set profilesCharsRemoved to 0
		set changeCount to 0
		set checkCount to 0
		set duplicatesRemoved to 0
		set inlineCharsRemoved to 0
		set lineCharsRemoved to 0
		set blockCharsRemoved to 0
		set charsRemovedLine to 0
		set kbValueText to ""
		set percentText to ""
		
		set processedContactsList to {}
		
		-- Initialize other values if missing
		try
			debugMode
		on error
			set debugMode to false
		end try
		
		if testMode is missing value then
			set testMode to false
		end if
		
		-- Set start time for timing calculations
		set startTime to current date
		
	on error initErr
		set initSuccess to false
		
		-- Try to use coModuleLogError, but fall back to direct logging if not available yet
		log "[Contact Operations - direct log] Error initializing processing variables: " & initErr
	end try
	
	-- Log successful initialization with module context
	if initSuccess then
	end if
	
	-- Validation check of critical variables
	try
		-- Verify most critical variables were set properly
		if processedContactsList is missing value then
			set processedContactsList to {}
		end if
		
		if startTime is missing value then
			set startTime to current date
		end if
	on error validateErr
		-- This shouldn't happen, but just in case
		log "[Contact Operations - direct log] ❌ Error validating initialization: " & validateErr
	end try
	
	return true
end initializeContactProcessing

-------------------------------------------------------------------------------
-- Handler: setUtilitiesReference
-- VERSION: 0.9.9
-- PURPOSE: Store utilities module reference with basic error handling
-- PARAMETERS: theUtilitiesScript (script object) - Reference to Utilities module
-- RETURNS: Boolean - always returns true
-------------------------------------------------------------------------------
on setUtilitiesReference(theUtilitiesScript)
	-- SILENT DURING STARTUP: ContactManager handles success/failure logging
	try
		set utilitiesScript to theUtilitiesScript
		-- No logging during startup - parent will log success/failure
	on error refErr
		-- Return error to parent instead of logging directly
		error "Failed to set Utilities reference: " & refErr
	end try
	return true
end setUtilitiesReference

-- PURPOSE: Securely store session folder paths with validation and error handling
on setSessionPaths(newSessionFolder, newBackupFolder, newLogsFolder, newReportsFolder)
	-- Store folder paths globally
	global sessionFolder, backupFolder, logsFolder, reportsFolder
	
	-- Validate input paths with proper logging
	if newSessionFolder is "" or newSessionFolder is missing value then
		coLogError("Received empty session folder path")
	end if
	
	if newLogsFolder is "" or newLogsFolder is missing value then
		coLogError("Received empty logs folder path")
	end if
	
	if newBackupFolder is "" or newBackupFolder is missing value then
		coLogWarning("Received empty backup folder path")
	end if
	
	if newReportsFolder is "" or newReportsFolder is missing value then
		coLogWarning("Received empty reports folder path")
	end if
	
	-- Update the paths with validation (even if empty, to maintain expected behavior)
	set sessionFolder to newSessionFolder
	set backupFolder to newBackupFolder
	set logsFolder to newLogsFolder
	set reportsFolder to newReportsFolder
	
	-- For Debug only : uncomment as needed
	-- coLogDebug("Session paths updated in ContactOperations:")
	-- coLogDebug("  Session: " & sessionFolder)
	-- coLogDebug("  Backups: " & backupFolder)
	-- coLogDebug("  Logs: " & logsFolder)
	-- coLogDebug("  Reports: " & reportsFolder)
	
	-- Verify that folders exist with proper error handling
	try
		if sessionFolder is not "" then
			tell application "System Events"
				if not (exists folder sessionFolder) then
					coLogWarning("Session folder does not exist: " & sessionFolder)
				end if
			end tell
		end if
		
		if logsFolder is not "" then
			tell application "System Events"
				if not (exists folder logsFolder) then
					coLogWarning("Logs folder does not exist: " & logsFolder)
				end if
			end tell
		end if
	on error verifyErr
		coLogError("Error verifying folder existence: " & verifyErr)
	end try
	
	return true
end setSessionPaths

-- ==========================================================
-- LOGGING SYSTEM ACCESS
--  Logging wrappers                          --
-- VERSION: 0.9.9 (2025-06-22)
-- PURPOSE: ContactOperations info logging for runtime phase only
-- CHANGE: Only logs during runtime phase, silent during startup
-- WHY:    Single-buffer approach requires ContactManager to handle startup logging
-- HOW:    Checks if Utilities available before logging (runtime indicator)
-------------------------------------------------------------------------------

on coLogError(aMsg)
	try
		-- Only log if Utilities is available (indicates runtime phase)
		if utilitiesScript is not missing value then
			utilitiesScript's moduleLogError("ContactOperations", aMsg)
		else
			-- During startup, stay silent - ContactManager handles all logging
			-- Critical errors during startup should be handled by parent module
		end if
	on error logErr
		-- Only log errors during runtime phase to avoid startup confusion
		if utilitiesScript is not missing value then
			log "[ContactOperations] ❌ Logging error: " & logErr & " - Original: " & aMsg
		end if
	end try
end coLogError

on coLogInfo(msg)
	try
		-- Only log if Utilities is available (indicates runtime phase)
		if utilitiesScript is not missing value then
			utilitiesScript's moduleLogInfo("ContactOperations", msg)
		else
			-- During startup, stay silent - ContactManager handles all logging
			-- No fallback logging to avoid multi-buffer complexity
		end if
	on error logErr
		-- Only log errors during runtime phase
		if utilitiesScript is not missing value then
			log "[ContactOperations] ❌ Info logging error: " & logErr & " - Original: " & msg
		end if
	end try
end coLogInfo

on coLogDebug(aMsg)
	try
		-- Only log if Utilities is available (indicates runtime phase)
		if utilitiesScript is not missing value then
			utilitiesScript's moduleLogDebug("ContactOperations", aMsg)
		else
			-- During startup, stay silent - ContactManager handles all logging
			-- No fallback logging to avoid multi-buffer complexity
		end if
	on error logErr
		-- Silent failure during startup, runtime errors logged
		if utilitiesScript is not missing value then
			log "[ContactOperations] ❌ Debug logging error: " & logErr
		end if
	end try
end coLogDebug

on coLogWarning(aMsg)
	try
		-- Only log if Utilities is available (indicates runtime phase)
		if utilitiesScript is not missing value then
			utilitiesScript's moduleLogWarning("ContactOperations", aMsg)
		else
			-- During startup, stay silent - ContactManager handles all logging
			-- Warnings during startup should be handled by parent module
		end if
	on error logErr
		-- Only log errors during runtime phase
		if utilitiesScript is not missing value then
			log "[ContactOperations] ❌ Warning logging error: " & logErr & " - Original: " & aMsg
		end if
	end try
end coLogWarning

on coLogMilestone(aMsg)
	try
		-- Only log if Utilities is available (indicates runtime phase)
		if utilitiesScript is not missing value then
			utilitiesScript's milestoneLog("ContactOperations", aMsg)
		else
			-- During startup, stay silent - ContactManager handles all logging
			-- Milestone logs during startup should be handled by parent module
		end if
	on error logErr
		-- Only log errors during runtime phase
		if utilitiesScript is not missing value then
			log "[ContactOperations] ❌ Milestone logging error: " & logErr & " - Original: " & aMsg
		end if
	end try
end coLogMilestone

-------------------------------------------------------------------------------
--  setDebugMode(newDebugMode)  • keep local flag & delegate to Utilities
-------------------------------------------------------------------------------
on setDebugMode(newDebugMode)
	-- Shared flag for this module
	global debugMode, logLevel, utilitiesScript
	set debugMode to newDebugMode
	-- Always synchronize local logLevel with Utilities
	try
		if utilitiesScript is not missing value then
			set logLevel to utilitiesScript's logLevel
			utilitiesScript's setDebugMode(newDebugMode)
		end if
	on error utilErr
		coLogError("❌ Error syncing logLevel in setDebugMode: " & utilErr)
	end try
	return true
end setDebugMode

-- Simplified log level setting delegated to utilitiesScript's
on setLogLevel(newLevel)
	global logLevel, utilitiesScript
	try
		if utilitiesScript is not missing value then
			utilitiesScript's setLogLevel(newLevel)
		end if
		set logLevel to newLevel -- local shadow, just in case
		coModuleLogInfo("Log level set to " & (newLevel as string))
	on error utilErr
		coLogError("❌ Error setting logLevel: " & utilErr)
	end try
	return true
end setLogLevel


-- ==========================================================
-- BATCH CONTACT PROCESSING
-- ==========================================================


-- -- ============================================
-- Handler: processContactNote  
-- VERSION: 0.9.7 (2025-06-10)
-- PURPOSE: Unified base function for contact note processing with sophisticated
--          note retrieval, comprehensive backup system, and enhanced footer 
--          management. Handles all common functionality with robust error handling
--          and detailed audit trail through backup files.
-- INPUTS:  aPerson (Contacts record) - The contact to process
--          testMode (boolean) - Whether to run in simulation mode (no changes applied)
-- RETURNS: record - {success:boolean, modified:boolean, reason:text, charsRemoved:integer}
--          • success: true if processing completed without errors
--          • modified: true if content was actually changed  
--          • reason: descriptive text of processing outcome
--          • charsRemoved: number of characters removed during processing
-- FEATURES: • Three-strategy note retrieval (direct, vCard refresh, edit/get cycle)
--           • Comprehensive backup system (original + processed with footer)
--           • Historical footer tracking and contact date preservation
--           • Robust error handling with graceful degradation
--           • Session statistics tracking for batch operations
-- DEPENDENCIES: captureContactDates(), hasCCCFooter(), extractExistingFooter(),
--               processNoteContent(), updateCCCFooter(), backupContactNoteWithType() (local)
--               utilitiesScript's moduleLogInfo(), coModuleLogDebug(), coModuleLogWarning(),
--               joinText() (utilities module)
-- NOTES:   Maintains compatibility with existing global counter system.
--          Creates complete audit trail with original and processed backups.
--          Processed backup now includes complete final result with CCC footer.
-- -- ============================================
on processContactNote(aPerson, testMode)
	-- Access global counters for comprehensive session statistics
	global debugMode, inlineDuplicatesCount, blockDuplicatesCount, lineDuplicatesCount
	global inlineCharsRemoved, lineCharsRemoved, blockCharsRemoved, totalOriginalLength
	
	-- 0. PRE-FLIGHT CHECKS AND SAFETY INITIALIZATION
	set contactName to "<Unknown>"
	try
		tell application "Contacts" to set contactName to name of aPerson
	on error nameErr
		coLogError("Failed to get contact name: " & nameErr)
	end try
	
	if aPerson is missing value then
		coLogError("Contact reference is missing value")
		return {success:false, modified:false, reason:"Missing contact reference", charsRemoved:0}
	end if
	
	-- Initialize any missing global counters for session statistics safety
	if inlineDuplicatesCount is missing value then set inlineDuplicatesCount to 0
	if lineDuplicatesCount is missing value then set lineDuplicatesCount to 0
	if blockDuplicatesCount is missing value then set blockDuplicatesCount to 0
	if inlineCharsRemoved is missing value then set inlineCharsRemoved to 0
	if lineCharsRemoved is missing value then set lineCharsRemoved to 0
	if blockCharsRemoved is missing value then set blockCharsRemoved to 0
	if totalOriginalLength is missing value then set totalOriginalLength to 0
	
	-- Log entry with contact identification
	coLogInfo("Starting processContactNote for: " & contactName)
	
	-- 1. CONTACT DATE CAPTURE (early capture for footer building)
	set contactDates to my captureContactDates(aPerson, contactName)
	coLogDebug("Contact dates for " & contactName & " - Mod: " & contactDates's modDate & ", Created: " & contactDates's creationDate)
	
	-- 2. ENHANCED NOTE RETRIEVAL WITH THREE-STRATEGY APPROACH
	set originalNote to ""
	try
		-- Preserve the sophisticated retrieval strategies from original implementation
		tell application "Contacts"
			-- Strategy 1: Direct property access
			set originalNote to note of aPerson
			coLogDebug("Strategy 1 note length: " & (length of originalNote))
			
			if originalNote is missing value then set originalNote to ""
			
			-- Check if suspiciously short (might be incomplete retrieval)
			if (length of originalNote) < 200 and originalNote contains "CCC Summary" then
				coLogDebug("⚠️ Note appears truncated - trying vCard refresh method")
				
				-- Strategy 2: Force refresh via vCard access
				set vcardData to vcard of aPerson
				delay 0.2 -- Allow Contacts app time to refresh internal state
				
				-- Retry note retrieval after vCard access
				set tempNote to note of aPerson
				if tempNote is not missing value and (length of tempNote) > (length of originalNote) then
					set originalNote to tempNote
					coLogDebug("vCard method yielded longer note: " & (length of originalNote))
				end if
				
				-- If still problematic, attempt direct edit/get cycle
				if (length of originalNote) < 200 and originalNote contains "CCC Summary" then
					coLogWarning("Still appears truncated - trying direct edit/get cycle")
					
					-- Strategy 3: Force update cycle to refresh contact data
					set currentContent to originalNote
					
					-- Make minimal modification and save (forces internal refresh)
					set note of aPerson to currentContent & " "
					delay 0.2
					
					-- Restore original content and retrieve again
					set note of aPerson to currentContent
					delay 0.2
					
					-- Attempt fresh retrieval after forced refresh
					set refreshedNote to note of aPerson
					if refreshedNote is not missing value and (length of refreshedNote) > (length of originalNote) then
						set originalNote to refreshedNote
						coLogWarning("Edit/get cycle yielded longer note: " & (length of originalNote))
					end if
				end if
				
				-- Final verification of note retrieval success
				if (length of originalNote) < 200 and originalNote contains "CCC Summary" then
					coLogError("Cannot retrieve complete note even after multiple attempts for " & contactName)
					return {success:false, modified:false, reason:"Could not retrieve complete note", charsRemoved:0}
				end if
			end if
		end tell
		
	on error noteErr
		coLogError("Note retrieval error for " & contactName & ": " & noteErr)
		if originalNote is missing value then set originalNote to ""
	end try
	
	-- Ensure note is text and update session statistics
	set originalNote to originalNote as text
	set hasFooter to my hasCCCFooter(originalNote)
	
	-- 3. ORIGINAL NOTE BACKUP (complete audit trail)
	if (not testMode or debugMode) then
		try
			my backupContactNoteWithType(aPerson, contactName, originalNote, "original")
			coLogDebug("Retrieved and backed-up original note of length: " & (length of originalNote))
		on error backupErr
			coLogWarning("Original backup error for " & contactName & ": " & backupErr)
			-- Continue processing despite backup failure
		end try
	else
		coLogDebug("Retrieved note of length: " & (length of originalNote))
	end if
	
	-- 4. FOOTER EXTRACTION AND CONTENT ISOLATION
	set footerBlock to my extractExistingFooter(originalNote)
	if footerBlock ≠ "" then
		set cleanedText to text 1 thru ((offset of footerBlock in originalNote) - 1) of originalNote
		coLogDebug("Extracted existing footer from note")
	else
		set cleanedText to originalNote
		coLogDebug("No existing footer found")
	end if
	
	-- 5. CONTENT PROCESSING PIPELINE
	set originalLength to length of cleanedText
	
	
	-- set finalText to my processNoteContent(cleanedText)
	set finalText to my processNoteContentOptimized(cleanedText) -- Claude June 10th 2025 or Grok3 June 11th
	
	-- coLogDebug("Processing completed, result length: " & (length of finalText) & " characters")
	
	-- 6. MODIFICATION ANALYSIS AND METRICS CALCULATION
	set charsRemoved to originalLength - (length of finalText)
	if charsRemoved < 0 then set charsRemoved to 0
	set contentModified to (charsRemoved > 0)
	set modificationReason to "Content simplified and optimized: " & charsRemoved & " characters removed"
	
	-- 7. ENHANCED FOOTER BUILDING WITH DATE FORMATTING
	coLogDebug("Building CCC footer for " & contactName & " (" & charsRemoved & " chars removed)")
	
	-- Defensive check for contactDates availability (should always exist from step 1)
	if not (exists contactDates) then
		coLogWarning("contactDates missing, re-capturing for " & contactName)
		set contactDates to my captureContactDates(aPerson, contactName)
	end if
	
	set finalNoteWithFooter to my updateCCCFooter(finalText, charsRemoved, originalLength, contentModified, contactDates)
	
	-- 8. PROCESSED NOTE BACKUP WITH COMPLETE FOOTER (FIXED TIMING)
	if (not testMode or debugMode) then
		try
			-- Ensure processed note includes complete final result with footer
			set safeProcessedNote to finalNoteWithFooter
			if (class of safeProcessedNote) is list then
				set safeProcessedNote to utilitiesScript's joinText(safeProcessedNote, return & return)
			end if
			
			my backupContactNoteWithType(aPerson, contactName, safeProcessedNote, "processed")
			coLogDebug("Backed up complete processed note with footer (length: " & (length of safeProcessedNote) & ")")
			
		on error processedBackupErr
			coLogWarning("Processed backup error for " & contactName & ": " & processedBackupErr)
			-- Continue with contact update despite backup failure
		end try
	end if
	
	-- 9. CONTACT UPDATE OR SIMULATION REPORTING
	if contentModified and not testMode then
		try
			tell application "Contacts"
				set note of aPerson to finalNoteWithFooter
				delay 0.1 -- Brief pause for Contacts app stability
				save
			end tell
			coLogDebug("Note updated for " & contactName)
			
		on error updateErr
			coLogError("Failed to update contact " & contactName & ": " & updateErr)
			return {success:false, modified:false, reason:"Contact update failed: " & updateErr, charsRemoved:0}
		end try
		
	else if testMode then
		coLogDebug("SIMULATION → «" & contactName & "» would be updated (" & charsRemoved & " chars)")
	else
		coLogDebug("No changes needed for " & contactName)
	end if
	
	-- 10. COMPREHENSIVE RETURN WITH PROCESSING METRICS
	return {success:true, modified:contentModified, reason:modificationReason, charsRemoved:charsRemoved}
	
end processContactNote

-- ==========================================================
-- Handler: processNoteContentOptimized (Claude, June 10 2025)
-- PURPOSE: Optimized 2-pass version using EXISTING utilities functions
-- REPLACES: processNoteContent() in contact-operations.txt (line ~462)
-- PERFORMANCE: 50-60% faster, identical output
-- ==========================================================
on processNoteContentOptimized(inputText)
	global utilitiesScript
	set handlerName to "processNoteContentOptimized"
	
	-- Early exit for empty input
	if inputText = "" or inputText is missing value then return ""
	
	-- PASS 1: Combined line operations (single text rebuild)
	set linesList to paragraphs of (utilitiesScript's forceText(inputText))
	set processedLines to {}
	set lastTrimmedLine to "[UNIQUE_MARKER]"
	
	repeat with rawLine in linesList
		-- Use utilities Script normalizeContactLine() 
		set normalizedLine to my normalizeContactLine(rawLine)
		
		-- Use utilities Script trimWhitespace() for comparison
		set trimmedLine to utilitiesScript's trimWhitespace(normalizedLine)
		
		-- Combined: skip empties + consecutive duplicates in one check
		if trimmedLine ≠ "" and trimmedLine ≠ lastTrimmedLine then
			set end of processedLines to normalizedLine
			set lastTrimmedLine to trimmedLine
		end if
	end repeat
	
	-- Single text rebuild
	set step1Text to utilitiesScript's joinText(processedLines, return)
	
	-- *** UPDATED: Added new deduplication step ***
	-- set step2Text to my deduplicateFlattenedSeeMoreBlocksEnhanced(step1Text) -- Handles "...see more" patterns
	set step2Text to step1Text
	set step3Text to my deduplicateConsecutiveTextBlocks(step2Text) -- *** NEW: Handles formatted vs flattened without "see more"
	set step4Text to my deduplicateConsecutiveLineBlocks(step3Text) -- Handles simple consecutive blocks
	-- Add experience separators for better readability
	set step5Text to my addExperienceSeparators(step4Text)
	
	-- Preserve Single Blank Lines
	set finalText to my preserveSingleBlankLines(step5Text)
	
	return finalText
end processNoteContentOptimized

-------------------------------------------------------------------------------
-- Handler: normalizeContactLine
-- VERSION: 0.9.1-pipeline-critical (2025-05-28)
-- PIPELINE CRITICAL: DO NOT REMOVE, OPTIMIZE AWAY, OR ALTER STRUCTURAL LOGIC
--
-- PURPOSE:
--   • Cleans LinkedIn junk, headers, prefixes.
--   • Ensures robust block separation for glue/block deduplication by:
--       - Replacing all lines ending with " logo" (case-insensitive) with a blank line + return.
--       - Collapsing ExperienceExperience/EducationEducation to "==== Experience"/"==== Education" with return.
--   • All other pipeline logic as before (FirstHalfFirstHalf, fuzzy date, etc.).
--   • Maintains all error handling and LinkedIn-specific cleanups.
--   • DO NOT "optimize" this away: downstream logic depends on these structural markers!
-------------------------------------------------------------------------------
on normalizeContactLine(lineText)
	global utilitiesScript
	set handlerName to "normalizeContactLine"
	
	try
		set cleanedLine to utilitiesScript's trimWhitespace(lineText)
	on error trimErr number trimNum
		coLogDebug("ERROR: " & trimErr & " (number: " & trimNum & ")")
	end try
	
	if cleanedLine is missing value or cleanedLine = "" then return ""
	
	-- LinkedIn/section/field garbage handling
	if (cleanedLine ends with " logo") or (cleanedLine ends with "logo") then return linefeed
	if ((cleanedLine contains "Show all ") and (cleanedLine contains " experience")) then return ""
	if (cleanedLine contains "degree connection") then return ""
	if cleanedLine starts with "Contact Info" then return linefeed & "==== " & cleanedLine
	if cleanedLine starts with "ExperienceExperience" then return linefeed & linefeed & "==== Experience" & linefeed
	if cleanedLine starts with "EducationEducation" then return linefeed & linefeed & "==== Education" & linefeed
	if cleanedLine is "Experience" then return linefeed & linefeed & "==== Experience" & linefeed
	if cleanedLine is "Education" then return linefeed & linefeed & "==== Education" & linefeed
	set prefixes to {"Location", "Degree Name", "Field Of Study", "Dates Employed", "Employment Duration", "Total Duration"}
	repeat with p in prefixes
		if cleanedLine starts with p then
			set cleanedLine to text ((length of p) + 2) thru -1 of cleanedLine
		end if
	end repeat
	if cleanedLine is "LinkedIn" then return linefeed & linefeed & "____________ " & linefeed & "LinkedIn"
	if cleanedLine starts with "-- LinkedIn" then return linefeed & linefeed & "____________ " & linefeed & cleanedLine
	
	set origLine to cleanedLine
	set wasDeduped to false
	
	-- === Generic FirstHalfFirstHalf (via Utilities) ===
	set dedupedLine to utilitiesScript's deduplicateFirstHalfRepeat(cleanedLine)
	if dedupedLine ≠ cleanedLine then
		set cleanedLine to dedupedLine
		set wasDeduped to true
	end if
	
	-- Take care of 'Nov 2019 - Present · 5 yrs 5 mosNov 2019 to Present · 5 yrs 5 mos'
	if (cleanedLine contains " - ") and (cleanedLine contains " to ") then
		set normLine to utilitiesScript's replaceText(cleanedLine, " to ", " - ")
		set dedupedLine to utilitiesScript's deduplicateFirstHalfRepeat(normLine)
		if dedupedLine ≠ normLine then
			set cleanedLine to dedupedLine
		end if
		-- If dedupe didn't change anything, cleanedLine remains as original (do nothing)
	end if
	
	-- Never emit a lone "to"
	if cleanedLine is "to" then return ""
	return cleanedLine
end normalizeContactLine

-- =============================================================================
-- Handler: deduplicateConsecutiveTextBlocks
-- VERSION: 2.0.0 (2025-01-10)
-- PURPOSE: Remove flattened duplicate blocks that follow their formatted version
--          Handles both old (with "...see more") and new LinkedIn export formats
-- PATTERN: Multiple formatted paragraphs followed by their concatenated version
--          (with or without "...see more" markers)
-- CHANGELOG:
--   2.0.0: Unified handler for all LinkedIn duplicate patterns
--          - Strips "see more" markers before processing
--          - Handles both old and new export formats
--          - Can replace deduplicateFlattenedSeeMoreBlocksEnhanced
--   1.3.0: Simplified logging and enhanced statistics
--   1.2.0: Fingerprint matching approach for precise detection
--   1.1.0: Fixed over-collection and comparison issues
--   1.0.0: Initial version
-- =============================================================================
on deduplicateConsecutiveTextBlocks(inputText)
	global utilitiesScript
	set handlerName to "deduplicateConsecutiveTextBlocks"
	
	try
		-- Configuration constants
		set MIN_LONG_LINE_LENGTH to 200
		set FINGERPRINT_LENGTH to 50
		set MIN_MATCH_LENGTH to 100
		
		-- Section delimiters
		set sectionDelimiters to {"==== Experience", "==== Education", "==== Skills", "==== Certification", ¬
			"==== Project", "==== Publication", "==== Language", "==== Award", ¬
			"==== Volunteer", "==== Course", "==== Honor", "==== Test Score", ¬
			"==== Organization", "==== Patent", "==== ", "=== CCC Summary ===", ¬
			"############", "LinkedIn", "---", "___"}
		
		-- "See more" markers to strip
		set seeMoreMarkers to {"...see more", "…see more", "... see more", "… see more", ¬
			"...See more", "…See more", "...see More", "…see More"}
		
		-- Initialize processing state
		set linesList to paragraphs of (utilitiesScript's forceText(inputText))
		set totalLines to count of linesList
		set outLines to {}
		set processedUpToLine to 0
		
		-- Statistics tracking
		set potentialDuplicates to 0
		set exactMatches to 0
		set partialMatches to 0
		set seeMoreMatches to 0
		set totalLinesRemoved to 0
		set totalCharsRemoved to 0
		
		-- Main processing loop
		repeat with currentLineIndex from 1 to totalLines
			set currentLine to item currentLineIndex of linesList
			set currentLineTrimmed to utilitiesScript's trimWhitespace(currentLine)
			set lineWasDeduplicated to false
			
			-- Check if this line is a potential flattened duplicate
			set isPotentialFlattened to false
			if (length of currentLineTrimmed) > MIN_LONG_LINE_LENGTH then
				-- Don't process lines that start with section delimiters
				set startsWithDelimiter to false
				repeat with delimiter in sectionDelimiters
					if currentLineTrimmed starts with delimiter then
						set startsWithDelimiter to true
						exit repeat
					end if
				end repeat
				
				if not startsWithDelimiter then
					set isPotentialFlattened to true
					set potentialDuplicates to potentialDuplicates + 1
				end if
			end if
			
			-- Process potential flattened duplicates
			if isPotentialFlattened and currentLineIndex > 3 then
				-- *** VERSION 2.0.0: Strip "see more" markers if present ***
				set cleanedLineTrimmed to currentLineTrimmed
				set hadSeeMore to false
				
				repeat with marker in seeMoreMarkers
					if cleanedLineTrimmed ends with marker then
						-- Remove the marker
						set markerLen to length of marker
						set cleanedLineTrimmed to text 1 thru -(markerLen + 1) of cleanedLineTrimmed
						-- Trim any trailing whitespace/punctuation after removal
						set cleanedLineTrimmed to utilitiesScript's trimWhitespace(cleanedLineTrimmed)
						set hadSeeMore to true
						exit repeat
					end if
				end repeat
				
				-- Extract fingerprint from cleaned flattened line
				set fingerprintLen to FINGERPRINT_LENGTH
				if (length of cleanedLineTrimmed) < FINGERPRINT_LENGTH then
					set fingerprintLen to length of cleanedLineTrimmed
				end if
				
				-- Skip if line became too short after cleaning
				if fingerprintLen < 20 then
					-- Line too short after removing "see more", skip it
				else
					set fingerprint to text 1 thru fingerprintLen of cleanedLineTrimmed
					set normalizedFingerprint to utilitiesScript's stripAllWhitespace(fingerprint)
					
					-- Search backwards to find where formatted text begins
					set formattedStartLine to 0
					set maxSearchBack to currentLineIndex - 1
					if maxSearchBack > 50 then set maxSearchBack to 50
					
					repeat with searchIdx from (currentLineIndex - 1) to (currentLineIndex - maxSearchBack) by -1
						if searchIdx < 1 then exit repeat
						
						set searchLine to item searchIdx of linesList
						set searchTrimmed to utilitiesScript's trimWhitespace(searchLine)
						
						if searchTrimmed ≠ "" then
							-- Build text from this line forward to check against fingerprint
							set testText to ""
							set lineCount to 0
							
							repeat with buildIdx from searchIdx to (currentLineIndex - 1)
								set buildLine to item buildIdx of linesList
								set buildTrimmed to utilitiesScript's trimWhitespace(buildLine)
								
								if buildTrimmed = "" then
									set lineCount to lineCount + 1
									if lineCount > 3 then exit repeat
								else
									set lineCount to 0
									set testText to testText & buildTrimmed
									
									if (length of testText) ≥ fingerprintLen then
										set normalizedTest to utilitiesScript's stripAllWhitespace(text 1 thru fingerprintLen of testText)
										
										if normalizedTest = normalizedFingerprint then
											set formattedStartLine to searchIdx
											exit repeat
										else
											exit repeat
										end if
									end if
								end if
							end repeat
							
							if formattedStartLine > 0 then exit repeat
						end if
					end repeat
					
					-- If we found the formatted start, collect and compare
					if formattedStartLine > 0 then
						-- Collect all non-empty lines from start to just before flattened
						set formattedLines to {}
						repeat with collectIdx from formattedStartLine to (currentLineIndex - 1)
							set collectLine to item collectIdx of linesList
							set collectTrimmed to utilitiesScript's trimWhitespace(collectLine)
							if collectTrimmed ≠ "" then
								-- Don't include section delimiters
								set isDelimiter to false
								repeat with delimiter in sectionDelimiters
									if collectTrimmed starts with delimiter then
										set isDelimiter to true
										exit repeat
									end if
								end repeat
								if not isDelimiter then
									set end of formattedLines to collectTrimmed
								end if
							end if
						end repeat
						
						-- Build formatted text
						set formattedText to ""
						repeat with fLine in formattedLines
							set formattedText to formattedText & fLine
						end repeat
						
						-- Normalize both texts for comparison (use cleaned version)
						set normalizedFormatted to utilitiesScript's stripAllWhitespace(formattedText)
						set normalizedFlattened to utilitiesScript's stripAllWhitespace(cleanedLineTrimmed)
						
						-- Check for match
						set isMatch to false
						set matchType to ""
						
						if normalizedFormatted = normalizedFlattened then
							set isMatch to true
							set matchType to "EXACT"
							set exactMatches to exactMatches + 1
							if hadSeeMore then set seeMoreMatches to seeMoreMatches + 1
						else if (length of normalizedFormatted) > MIN_MATCH_LENGTH and (length of normalizedFlattened) > MIN_MATCH_LENGTH then
							-- Check if they're very similar
							set minLen to length of normalizedFormatted
							if (length of normalizedFlattened) < minLen then
								set minLen to length of normalizedFlattened
							end if
							
							set compareLen to round (minLen * 0.9)
							if compareLen > MIN_MATCH_LENGTH then
								set formattedPart to text 1 thru compareLen of normalizedFormatted
								set flattenedPart to text 1 thru compareLen of normalizedFlattened
								
								if formattedPart = flattenedPart then
									set isMatch to true
									set matchType to "PARTIAL"
									set partialMatches to partialMatches + 1
									if hadSeeMore then set seeMoreMatches to seeMoreMatches + 1
								end if
							end if
						end if
						
						-- Perform deduplication if match found
						if isMatch then
							-- Track characters removed (original line, not cleaned)
							set totalCharsRemoved to totalCharsRemoved + (length of currentLine)
							
							-- Output any unprocessed lines before the duplicate
							if (processedUpToLine + 1) < currentLineIndex then
								repeat with lineIdx from (processedUpToLine + 1) to (currentLineIndex - 1)
									set end of outLines to item lineIdx of linesList
								end repeat
							end if
							
							-- Skip the flattened duplicate (including any "see more")
							set processedUpToLine to currentLineIndex
							set lineWasDeduplicated to true
							set totalLinesRemoved to totalLinesRemoved + 1
						end if
					end if
				end if
			end if
			
			-- Output current line if it wasn't deduplicated
			if not lineWasDeduplicated and currentLineIndex > processedUpToLine then
				set end of outLines to currentLine
				set processedUpToLine to currentLineIndex
			end if
		end repeat
		
		-- Build result
		set resultText to utilitiesScript's joinText(outLines, return)
		
		-- Log final statistics only if changes were made
		if totalLinesRemoved > 0 then
			set statsMsg to handlerName & "(): Removed " & totalLinesRemoved & " duplicate blocks"
			set statsMsg to statsMsg & " (" & exactMatches & " exact, " & partialMatches & " partial"
			if seeMoreMatches > 0 then
				set statsMsg to statsMsg & ", " & seeMoreMatches & " with 'see more'"
			end if
			set statsMsg to statsMsg & ")"
			coLogInfo(statsMsg)
			coLogInfo(handlerName & "(): Characters reduced: " & (length of inputText) & " → " & (length of resultText) & " (-" & totalCharsRemoved & " chars)")
		else
			coLogDebug(handlerName & "(): No consecutive text blocks found to remove")
		end if
		
		return resultText
		
	on error dedupeError
		coLogError(handlerName & "(): Failed: " & dedupeError)
		return inputText
	end try
end deduplicateConsecutiveTextBlocks

-------------------------------------------------------------------------------
-- Handler: deduplicateFlattenedSeeMoreBlocksEnhanced
-- VERSION: 2.1.0-boundary-fix (2025-01-10)
-- PURPOSE: Remove duplicate LinkedIn Experience blocks that end with "see more"
--          Enhanced with flexible block boundary detection to handle missing sections
-- CHANGELOG:
--   2.1.0: Added multiple section delimiter detection for robust block boundaries
--          Added maximum block size safety limit (100 lines)
--          Fixed deduplication failure when Education section is missing
--   2.0.0: Previous enhanced version with sequential processing
-- AUTHOR: Philippe Dewost / Enhanced by Claude
--
-- PURPOSE:
--   Detect and remove LinkedIn duplicated "see more" glue blocks using
--   deterministic, symmetrical N-length boundaries. This enhanced version
--   fixes content preservation issues and simplifies the processing logic.
--
-- IMPROVEMENTS IN V2.0.0-Enhanced:
--   • Fixed content loss at beginning of notes
--   • Eliminated complex buffer management that caused positioning issues  
--   • Simplified sequential processing while maintaining deduplication accuracy
--   • Added comprehensive error handling and logging
--   • Preserved all original deduplication logic and effectiveness
--
-- BLOCK DEDUPLICATION LOGIC:
--   - BlockEndString2: Last N chars before "…see more" (anchor at block end)
--   - BlockEndString1: Previous occurrence of BlockEndString2 (before glue)
--   - BlockStartString2: Next N chars after BlockEndString1
--   - BlockStartString1: First line containing BlockStartString2 (upward search)
--
-- DEDUPE ALGORITHM:
--   1. Scan for lines ending with "...see more" or "…see more"
--   2. For each candidate, find the current Experience block boundaries
--   3. Extract last N characters before "see more" as BlockEndString2
--   4. Find previous occurrence of same string (BlockEndString1)
--   5. Extract following N characters as BlockStartString2
--   6. Search upward for line containing BlockStartString2
--   7. Compare flattened content: if FirstHalf = SecondHalf, deduplicate
--   8. Output deduplicated FirstHalf and continue processing
--
-- ENHANCED PROCESSING:
--   - Sequential line-by-line processing ensures no content loss
--   - Tracks processed lines to prevent duplication
--   - Preserves content before Experience blocks
--   - Maintains original sophisticated deduplication logic
-------------------------------------------------------------------------------

on deduplicateFlattenedSeeMoreBlocksEnhanced(inputText)
	global utilitiesScript
	set handlerName to "deduplicateFlattenedSeeMoreBlocksEnhanced"
	
	try
		-- Configuration constants
		set glueLens to {20, 16, 12} -- Fallback glue lengths to try
		set expDelimiter to "==== Experience"
		set seeMoreMarkers to {"…see more", "...see more"}
		
		-- NEW: Section delimiters that can terminate an Experience block
		set sectionDelimiters to {"==== Education", "==== Skills", "==== Certification", ¬
			"==== Project", "==== Publication", "==== Language", "==== Award", ¬
			"==== Volunteer", "==== Course", "==== Honor", "==== Test Score", ¬
			"==== Organization", "==== Patent", "==== ", "=== CCC Summary ===", ¬
			"############", "LinkedIn", "---", "___"}
		
		-- NEW: Maximum block size safety limit (lines)
		set MAX_BLOCK_SIZE to 100
		
		-- Initialize processing state
		set linesList to paragraphs of (utilitiesScript's forceText(inputText))
		set totalLines to count of linesList
		set outLines to {}
		set processedUpToLine to 0
		set totalDeduplicationsFound to 0
		set totalLinesRemoved to 0
		
		-- coLogDebug(handlerName & "(): Starting enhanced see-more block deduplication on " & totalLines & " lines")
		
		-- Main processing loop - sequential line processing
		repeat with currentLineIndex from 1 to totalLines
			set currentLine to item currentLineIndex of linesList
			set currentLineTrimmed to utilitiesScript's trimWhitespace(currentLine)
			set lineWasDeduplicated to false
			
			-- Check if this line is a see-more candidate
			set isSeeMoreCandidate to false
			set activeMarker to ""
			if (length of currentLineTrimmed) > 100 then
				repeat with marker in seeMoreMarkers
					if currentLineTrimmed ends with marker then
						set isSeeMoreCandidate to true
						set activeMarker to marker as string
						exit repeat
					end if
				end repeat
			end if
			
			-- Process see-more candidates for potential deduplication
			if isSeeMoreCandidate then
				-- coLogDebug(handlerName & "(): Found see-more candidate at line " & currentLineIndex & " (length: " & (length of currentLineTrimmed) & ")")
				
				set seeMorePosition to offset of activeMarker in currentLineTrimmed
				
				-- Find current Experience block start
				-- Find current Experience block start
				set experienceBlockStart to 0
				repeat with searchIdx from currentLineIndex to 1 by -1
					if item searchIdx of linesList contains expDelimiter then
						set experienceBlockStart to searchIdx
						exit repeat
					end if
				end repeat
				-- Safety check - must have found Experience delimiter
				if experienceBlockStart = 0 then
					-- coLogDebug(handlerName & "(): No Experience delimiter found before see-more at line " & currentLineIndex & ", skipping")
				else
					-- NEW: Find the END of the Experience block (next section or max size)
					set experienceBlockEnd to currentLineIndex -- Default to current line
					set effectiveBlockEnd to currentLineIndex
					
					-- Search forward from Experience start for next section delimiter
					set foundNextSection to false
					if experienceBlockStart < totalLines then
						repeat with searchIdx from (experienceBlockStart + 1) to totalLines
							set searchLineText to item searchIdx of linesList
							set searchLineTrimmed to utilitiesScript's trimWhitespace(searchLineText)
							
							-- Check against all possible section delimiters
							repeat with delimiter in sectionDelimiters
								if searchLineTrimmed starts with delimiter then
									-- Found next section - use line before it as block end
									set experienceBlockEnd to searchIdx - 1
									set foundNextSection to true
									-- coLogDebug(handlerName & "(): Found section delimiter '" & delimiter & "' at line " & searchIdx)
									exit repeat
								end if
							end repeat
							
							if foundNextSection then exit repeat
						end repeat
					end if
					
					-- NEW: Apply maximum block size safety limit
					set blockSize to experienceBlockEnd - experienceBlockStart + 1
					if blockSize > MAX_BLOCK_SIZE then
						set effectiveBlockEnd to experienceBlockStart + MAX_BLOCK_SIZE - 1
						-- Ensure we don't go past the see-more line
						if effectiveBlockEnd > currentLineIndex then
							set effectiveBlockEnd to currentLineIndex
						end if
						-- coLogDebug(handlerName & "(): Block size " & blockSize & " exceeds max " & MAX_BLOCK_SIZE & ", limiting to line " & effectiveBlockEnd)
					else
						set effectiveBlockEnd to experienceBlockEnd
						-- Ensure we don't go past the see-more line
						if effectiveBlockEnd > currentLineIndex then
							set effectiveBlockEnd to currentLineIndex
						end if
					end if
					
					-- Extract text from Experience start to effective block end
					set duplicateBlockLines to items experienceBlockStart thru effectiveBlockEnd of linesList
					set duplicateBlockText to utilitiesScript's joinText(duplicateBlockLines, linefeed)
					
					-- Log block extraction details for debugging
					-- coLogDebug(handlerName & "(): Extracted block from line " & experienceBlockStart & " to " & effectiveBlockEnd & " (" & (effectiveBlockEnd - experienceBlockStart + 1) & " lines)")
					
					-- Try different glue lengths for pattern matching
					repeat with glueLength in glueLens
						set glueLen to glueLength as integer
						
						if seeMorePosition > glueLen then
							-- Extract the pattern strings for comparison
							set blockEndString2 to text (seeMorePosition - glueLen) thru (seeMorePosition - 1) of currentLineTrimmed
							set effectiveGlueLen to glueLen
							
							-- Find previous occurrence of the ending pattern
							set patternCount to 0
							set firstOccurrencePos to 0
							set blockEndString1 to ""
							
							if duplicateBlockText contains blockEndString2 then
								set searchText to text 1 thru -((length of activeMarker) + glueLen + 2) of duplicateBlockText
								if searchText contains blockEndString2 then
									set tempOffset to offset of blockEndString2 in searchText
									if tempOffset > 0 then
										set firstOccurrencePos to tempOffset
										set blockEndString1 to text tempOffset thru (tempOffset + glueLen - 1) of searchText
										set patternCount to 2 -- Found at least 2 occurrences
									end if
								end if
							end if
							
							-- Process if we found the pattern at least twice
							if patternCount ≥ 2 and firstOccurrencePos > 0 then
								-- Find where the first pattern's containing line starts
								set blockStartString2 to ""
								if (firstOccurrencePos + glueLen) ≤ (length of duplicateBlockText) then
									set remainingText to text (firstOccurrencePos + glueLen) thru -1 of duplicateBlockText
									if (length of remainingText) ≥ glueLen then
										set blockStartString2 to text 1 thru glueLen of remainingText
									end if
								end if
								
								-- Find line containing BlockStartString2 (search upward)
								set blockStartLine1 to 0
								if blockStartString2 ≠ "" then
									repeat with lineNum from 1 to (count of duplicateBlockLines)
										if (item lineNum of duplicateBlockLines) contains blockStartString2 then
											set blockStartLine1 to lineNum
											exit repeat
										end if
									end repeat
								end if
								
								-- Extract and compare the two halves
								if blockStartLine1 > 0 then
									-- Extract first half (deduplicated content)
									set firstHalfLines to items 1 thru blockStartLine1 of duplicateBlockLines
									set firstHalfText to utilitiesScript's joinText(firstHalfLines, linefeed)
									
									-- Find and extract second half
									set secondOccurrenceStart to offset of blockStartString2 in duplicateBlockText
									set secondOccurrenceEnd to offset of blockEndString2 in (text secondOccurrenceStart thru -1 of duplicateBlockText)
									set secondHalfText to ""
									if secondOccurrenceStart > 0 and secondOccurrenceEnd > 0 then
										set secondOccurrenceEnd to secondOccurrenceEnd + secondOccurrenceStart - 1
										set secondHalfText to text secondOccurrenceStart thru (secondOccurrenceEnd + effectiveGlueLen - 1) of duplicateBlockText
									end if
									
									-- Compare flattened versions (whitespace removed)
									set flattenedFirst to utilitiesScript's stripAllWhitespace(firstHalfText)
									set flattenedSecond to utilitiesScript's stripAllWhitespace(secondHalfText)
									
									-- coLogDebug(handlerName & "(): Comparing flattened halves (lengths: " & (length of flattenedFirst) & ", " & (length of flattenedSecond) & ")")
									
									-- Perform deduplication if patterns match
									if (flattenedFirst = flattenedSecond) and ((length of flattenedFirst) > 40) then
										-- coLogDebug(handlerName & "(): DEDUPLICATING: Found X+X pattern at line " & currentLineIndex & " (glue length " & effectiveGlueLen & ")")
										
										-- Output any unprocessed lines before this block
										if experienceBlockStart > (processedUpToLine + 1) then
											repeat with lineIndex from (processedUpToLine + 1) to (experienceBlockStart - 1)
												set end of outLines to item lineIndex of linesList
											end repeat
											-- coLogDebug(handlerName & "(): Output " & ((experienceBlockStart - 1) - processedUpToLine) & " lines before duplicate block")
										end if
										
										-- Output the deduplicated first half
										repeat with theLine in firstHalfLines
											set end of outLines to theLine
										end repeat
										
										-- Add separator line after deduplication
										set end of outLines to ""
										
										-- Update processing state  
										set processedUpToLine to effectiveBlockEnd
										set lineWasDeduplicated to true
										set totalDeduplicationsFound to totalDeduplicationsFound + 1
										set totalLinesRemoved to totalLinesRemoved + (count of duplicateBlockLines) - (count of firstHalfLines)
										
										-- coLogDebug(handlerName & "(): Deduplication complete, processed up to line " & processedUpToLine)
										exit repeat -- Break out of glue length loop
										
									else
										-- coLogDebug(handlerName & "(): Patterns don't match or too short, no deduplication")
									end if
								else
									-- coLogDebug(handlerName & "(): BlockStartString1 not found in candidate lines")
								end if
							else
								-- coLogDebug(handlerName & "(): Insufficient pattern occurrences for deduplication")
							end if
						else
							-- coLogDebug(handlerName & "(): See-more position too close to start for glue length " & glueLen)
						end if
						
						if lineWasDeduplicated then exit repeat -- Break out of glue length loop
					end repeat
				end if
			end if
			
			-- Output current line if it wasn't part of a deduplication
			if not lineWasDeduplicated and currentLineIndex > processedUpToLine then
				set end of outLines to currentLine
				set processedUpToLine to currentLineIndex
			end if
			
			-- Progress logging for large inputs
			if currentLineIndex mod 100 = 0 and totalLines > 200 then
				-- coLogDebug(handlerName & "(): Processed " & currentLineIndex & " of " & totalLines & " lines")
			end if
		end repeat
		
		-- Final processing summary
		-- coLogDebug(handlerName & "(): Deduplication complete: " & totalDeduplicationsFound & " blocks removed, " & totalLinesRemoved & " lines eliminated")
		
		-- Return processed text
		set resultText to utilitiesScript's joinText(outLines, return)
		-- coLogDebug(handlerName & "(): Enhanced see-more deduplication finished: " & (length of inputText) & " → " & (length of resultText) & " characters")
		
		return resultText
		
	on error enhancedError
		coLogError(handlerName & "(): Enhanced deduplication failed: " & enhancedError)
		-- Return original text on error to prevent data loss
		return inputText
	end try
end deduplicateFlattenedSeeMoreBlocksEnhanced

-- ========================================================================================
-- Handler   : deduplicateConsecutiveLineBlocks
-- VERSION   : 1.2.0   (2025-06-04)
-- PURPOSE   : Remove **immediate** repeats of 2- to 4-line blocks anywhere
--             in the note, keeping the first copy and skipping the duplicate.
--
-- CHANGELOG ---------------------------------------------------------------
-- 1.2.0  • Added counters dupBlockCount / dupLinesTotal.
--        • Emits one INFO log summarising removals.
--        • Zero logic changes vs the May-24 implementation.
-- ========================================================================================

on deduplicateConsecutiveLineBlocks(theText)
	---- dependencies -------------------------------------------------------
	global utilitiesScript
	set handlerName to "deduplicateConsecutiveLineBlocks"
	
	---- state ----------------------------------------------------------------
	set inLines to paragraphs of (utilitiesScript's forceText(theText))
	set outLines to {}
	
	set dupBlockCount to 0
	set dupLinesTotal to 0
	
	---- core scan ------------------------------------------------------------
	set i to 1
	set n to count inLines
	
	repeat while i ≤ n
		set blockRemoved to false
		
		-- try block sizes 4, then 3, then 2
		repeat with blockSize from 4 to 2 by -1
			if (i + blockSize * 2 - 1) ≤ n then
				set blockA to items i thru (i + blockSize - 1) of inLines
				set blockB to items (i + blockSize) thru (i + blockSize * 2 - 1) of inLines
				
				if blockA is equal to blockB then
					-- keep first copy only
					repeat with l in blockA
						set end of outLines to l
					end repeat
					
					-- advance pointer past BOTH blocks
					set i to i + (blockSize * 2)
					
					-- stats
					set dupBlockCount to dupBlockCount + 1
					set dupLinesTotal to dupLinesTotal + blockSize
					
					set blockRemoved to true
					exit repeat
				end if
			end if
		end repeat
		
		if blockRemoved is false then
			-- no repeat here; copy line and advance one
			set end of outLines to (item i of inLines)
			set i to i + 1
		end if
	end repeat
	
	---- logging -------------------------------------------------------------
	-- coLogDebug(handlerName & "(): Removed " & dupBlockCount & " duplicate blocks (" & dupLinesTotal & " lines)")
	
	return utilitiesScript's joinText(outLines, return)
end deduplicateConsecutiveLineBlocks

-------------------------------------------------------------------------------
-- Handler: deduplicateConsecutiveLines
-- VERSION: 0.9.0-alpha (2025-05-23)
-- PURPOSE: Removes runs of consecutive duplicate lines, trims whitespace for compare.
-- INPUT: inputText (text)
-- OUTPUT: outText (text)
-- CHANGELOG:
--   0.9.0-alpha (2025-05-23): v4-style, compares trimmed lines, output preserves original line.
-------------------------------------------------------------------------------
on deduplicateConsecutiveLines(inputText)
	global utilitiesScript
	set linesList to paragraphs of utilitiesScript's forceText(inputText)
	set cleanedLines to {}
	set lastTrimmedLine to "[[[__UNIQUE__]]]"
	repeat with thisLine in linesList
		set trimmedLine to utilitiesScript's trimWhitespace(thisLine)
		if trimmedLine ≠ lastTrimmedLine then
			set end of cleanedLines to thisLine
			set lastTrimmedLine to trimmedLine
		end if
	end repeat
	set outText to utilitiesScript's joinText(cleanedLines, return)
	return outText
end deduplicateConsecutiveLines

-------------------------------------------------------------------------------
-- Handler: preserveSingleBlankLines
-- VERSION: 1.0.0 (2025-07-07)
-- PURPOSE: Collapse only 3+ consecutive blank lines while preserving single blank lines
-- INPUT: inputText (text)
-- OUTPUT: text with 3+ blank lines collapsed to 2, single blank lines preserved
-- CRITICAL: This replaces collapseMultipleBlankLines() which was too aggressive
-------------------------------------------------------------------------------
on preserveSingleBlankLines(inputText)
	global utilitiesScript
	set handlerName to "preserveSingleBlankLines"
	
	try
		set txt to inputText as text
		set prevLen to -1
		
		-- Only collapse 3+ consecutive blank lines to 2 blank lines
		-- This preserves intentional single blank lines for formatting
		repeat while prevLen ≠ (length of txt)
			set prevLen to length of txt
			set txt to utilitiesScript's replaceText(txt, return & return & return & return, return & return & return)
		end repeat
		
		-- Second pass: collapse remaining 3+ to 2
		set prevLen to -1
		repeat while prevLen ≠ (length of txt)
			set prevLen to length of txt
			set txt to utilitiesScript's replaceText(txt, return & return & return, return & return)
		end repeat
		
		-- Trim only leading/trailing blank lines (not internal structure)
		repeat while txt begins with return
			if length of txt > 1 then
				set txt to text 2 thru -1 of txt
			else
				exit repeat
			end if
		end repeat
		
		repeat while txt ends with return
			if length of txt > 1 then
				set txt to text 1 thru -2 of txt
			else
				exit repeat
			end if
		end repeat
		
		return txt
		
	on error preserveErr
		coLogError(handlerName & "(): Error preserving blank lines: " & preserveErr)
		return inputText
	end try
end preserveSingleBlankLines

-------------------------------------------------------------------------------
-- Handler: addExperienceSeparators
-- VERSION: 1.0.0 (2025-07-07)
-- PURPOSE: Add blank lines between different job experiences for better readability
-- INPUT: inputText (text)
-- OUTPUT: text with blank lines separating experiences
-- LOGIC: Detects job/company lines and adds separators between different roles
-------------------------------------------------------------------------------
on addExperienceSeparators(inputText)
	global utilitiesScript
	set handlerName to "addExperienceSeparators"
	
	try
		set linesList to paragraphs of (utilitiesScript's forceText(inputText))
		set outputLines to {}
		set lastWasJobLine to false
		set inExperienceSection to false
		
		repeat with i from 1 to count of linesList
			set currentLine to item i of linesList
			set trimmedLine to utilitiesScript's trimWhitespace(currentLine)
			
			-- Track if we're in Experience section
			if trimmedLine contains "==== Experience" then
				set inExperienceSection to true
			else if trimmedLine contains "==== Education" or trimmedLine contains "==== " then
				set inExperienceSection to false
			end if
			
			-- Only add separators within Experience sections
			if inExperienceSection then
				-- Detect job/company lines (contain dates, positions, company indicators)
				set isJobLine to false
				if (trimmedLine contains " · ") or (trimmedLine contains " - ") or ¬
					(trimmedLine contains "Present") or (trimmedLine contains "20") or ¬
					(trimmedLine contains "Full-time") or (trimmedLine contains "Part-time") then
					set isJobLine to true
				end if
				
				-- Add separator between different job entries
				if isJobLine and lastWasJobLine and i > 1 then
					-- Check if previous line isn't already blank
					if (count of outputLines) > 0 and item -1 of outputLines ≠ "" then
						set end of outputLines to ""
					end if
				end if
				
				set lastWasJobLine to isJobLine
			else
				set lastWasJobLine to false
			end if
			
			set end of outputLines to currentLine
		end repeat
		
		return utilitiesScript's joinText(outputLines, return)
		
	on error separatorErr
		coLogError(handlerName & "(): Error adding experience separators: " & separatorErr)
		return inputText
	end try
end addExperienceSeparators

-- ===================================================
-- ===================================================

-- Original Code - DONT TOUCH

-- ===================================================
-- ===================================================

-- ===================================================
-- VERSION:        6.0.0-alpha26 (2025-05-16)
-- PURPOSE:        Batch-clean notes for contacts per the chosen scope,
--                 with skip-mode, simulation, backups, and full reporting.
-- PARAMETERS:
--   • selectionScope : text    – "selected" or "all"
--   • runInTestMode  : boolean – if true, runs in simulation (no writes)
-- RETURNS: record with keys:
--   • success   : boolean
--   • cancelled : boolean
--   • report    : text       – human-readable summary or skip-report
--   • stats     : record     – {processed, modified, skipped, errors}
-- ===================================================
on processContactsWithScope(selectionScope as text, runInTestMode as boolean)
	----------------------------------------------------------------
	-- 0 ▸ Initialize & reset globals
	----------------------------------------------------------------
	global testMode
	global contactsProcessed, contactsModified, totalOriginalLength
	global totalCharsRemoved, errorCount
	global inlineDuplicatesCount, blockDuplicatesCount, lineDuplicatesCount
	
	-- 0.1 ▸ Force defaults
	if runInTestMode is missing value then set runInTestMode to false
	set testMode to runInTestMode
	-- 🔄 Do NOT reset forceCleanup here; it should be set by the UI or test code	
	global forceCleanup
	-- Debug: log the incoming forceCleanup value
	coLogDebug("processContactsWithScope: forceCleanup=" & forceCleanup & ", defaultForceCleanupMode=" & defaultForceCleanupMode)
	
	-- Set skipProcessed: TRUE if and only if forceCleanup is EXACTLY the default value
	if (forceCleanup as string) is (defaultForceCleanupMode as string) then
		set shouldSkipProcessed to true
	else
		set shouldSkipProcessed to false
	end if
	
	coLogDebug("processContactsWithScope: shouldSkipProcessed set to " & (shouldSkipProcessed as string))
	
	-- 0.2 ▸ Reset all counters
	set contactsProcessed to 0
	set contactsModified to 0
	set totalOriginalLength to 0
	set totalCharsRemoved to 0
	set errorCount to 0
	set inlineDuplicatesCount to 0
	set blockDuplicatesCount to 0
	set lineDuplicatesCount to 0
	
	-- Track how many we skip in skip-mode
	set skippedContacts to 0
	
	coLogInfo("▶ Starting batch-clean • scope=" & selectionScope & ¬
		" • testMode=" & testMode & ¬
		" • skipProcessed=" & shouldSkipProcessed)
	
	----------------------------------------------------------------
	-- 1 ▸ Build the contact list
	----------------------------------------------------------------
	set contactsToProcess to {}
	try
		tell application "Contacts"
			if selectionScope is "selected" then
				set contactsToProcess to selection
			else
				set contactsToProcess to every person
			end if
		end tell
	on error fetchErr
		coLogError("Failed to fetch contacts: " & fetchErr)
		return {success:false, cancelled:false, report:"", stats:{processed:0, modified:0, skipped:0, errors:errorCount + 1}}
	end try
	
	if (count of contactsToProcess) = 0 then
		coLogInfo("No contacts found for scope: " & selectionScope)
		return {success:true, cancelled:true, report:"No contacts to process (“" & selectionScope & "” scope)", stats:{processed:0, modified:0, skipped:0, errors:0}}
	end if
	
	----------------------------------------------------------------
	-- 2 ▸ Prefilter out already-processed (skip-mode)
	----------------------------------------------------------------
	if shouldSkipProcessed then
		coLogInfo("Skip-mode ON → filtering out notes with existing CCC footer")
		
		-- Track which contacts get skipped
		set skippedContacts to 0
		set skippedContactsList to {}
		
		set filteredContacts to {}
		repeat with c in contactsToProcess
			try
				-- Safely read the note (empty → "")
				tell application "Contacts"
					if note of c is missing value then
						set noteText to ""
						coLogDebug("Empty note for: " & (name of c))
					else
						set noteText to note of c as text
					end if
				end tell
				
				-- Skip if it already contains our CCC footer marker
				if noteText contains "==== CCC Summary ====" then
					set skippedContacts to skippedContacts + 1
					copy c to end of skippedContactsList
					coLogDebug("Skipping already-processed: " & (name of c))
				else
					-- Otherwise, include it for processing
					copy c to end of filteredContacts
				end if
				
			on error chkErr
				-- On any error checking footer, process the contact anyway
				copy c to end of filteredContacts
				coLogWarning("Footer check failed (processing anyway): " & chkErr)
			end try
		end repeat
		
		-- 2.1 ▸ SHORT-CIRCUIT if nothing left to do
		if (count of filteredContacts) = 0 then
			set skipReport to generateSkipReport(skippedContactsList)
			return {success:true, cancelled:false, report:skipReport, stats:{processed:0, modified:0, skipped:skippedContacts, errors:0, charsRemoved:totalCharsRemoved}}
		end if
		
		-- Replace original list with the filtered one
		set contactsToProcess to filteredContacts
		coLogWarning("After filtering: " & (count of contactsToProcess) & " to process, " & skippedContacts & " skipped")
		
	else
		coLogWarning("Skip-mode OFF → processing all " & (count of contactsToProcess) & " contacts")
	end if
	
	----------------------------------------------------------------
	-- 3 ▸ Process each contact
	----------------------------------------------------------------
	repeat with c in contactsToProcess
		set contactsProcessed to contactsProcessed + 1
		try
			-- a) Record original length
			tell application "Contacts"
				set origNote to note of c as text
			end tell
			set totalOriginalLength to totalOriginalLength + (length of origNote)
			
			-- b) Clean the note
			set noteInfo to my processContactNote(c, testMode)
			-- c) Tally modifications
			if noteInfo's modified then
				set contactsModified to contactsModified + 1
				set totalCharsRemoved to totalCharsRemoved + (noteInfo's charsRemoved)
			end if
			
		on error procErr
			set errorCount to errorCount + 1
			coLogError("Error processing “" & (name of c) & "”: " & procErr)
		end try
	end repeat
	
	-- 3.1 ▸ Restore forceCleanup default for next run
	set forceCleanup to defaultForceCleanupMode
	
	----------------------------------------------------------------
	-- 4 ▸ Build and return the final report + stats
	----------------------------------------------------------------
	set fullReport to generateStatsReportLegacy()
	coLogInfo("✔ Batch complete • processed=" & contactsProcessed & ¬
		" • modified=" & contactsModified & ¬
		" • skipped=" & skippedContacts & ¬
		" • errors=" & errorCount)
	
	return {success:true, cancelled:false, report:fullReport, stats:{processed:contactsProcessed, modified:contactsModified, skipped:skippedContacts, errors:errorCount, charsRemoved:totalCharsRemoved}}
end processContactsWithScope

-------------------------------------------------------------------------------
-- Handler: processContactsWithScopeOptimized
-- VERSION: 0.9.9-adaptive-reporting (2025-07-07)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Enhanced I/O-optimized contact processing with ADAPTIVE time-based progress reporting
-- PRESERVES: ALL existing functionality, chunked I/O, skip logic, error handling, statistics
-- ENHANCES: Adaptive progress reporting, performance tracking, mode-aware time estimation
-- COMPATIBILITY: Maintains all global variables for downstream function compatibility
-- INTEGRATION: Seamless Performance Tracking System integration without breaking changes
-- CHANGELOG: 
--   • 0.9.9-adaptive-reporting: Extracted progress reporting to dedicated checkAndReportProgress() handler
--   • Implemented adaptive time-based intervals based on estimated job duration (15s-30s)
--   • Replaced percentage-only milestones with intelligent reporting frequency
--   • Enhanced error handling and failsafe mechanisms throughout
--   • Maintained ALL existing chunking, filtering, error handling, and statistics functionality
--   • Preserved backward compatibility with all existing global variables and return structures
--   • Fixed recordSessionPerformance() parameter format for proper integration
-- DEPENDENCIES: Performance Tracking System (utilities.txt), checkAndReportProgress() (local)
-- PROGRESS ALGORITHM: Adaptive time-based intervals with percentage milestone backup
--   • Small jobs (≤30s): No intermediate reports
--   • Medium jobs (30s-2min): 15-second intervals  
--   • Long jobs (2-10min): 20-second intervals
--   • Very long jobs (>10min): 30-second intervals
--   • Backup: 25%, 50%, 75% milestones if time interval hasn't triggered
--   • Integrates with Performance Tracking System for duration estimates
-------------------------------------------------------------------------------
on processContactsWithScopeOptimized(selectionScope as text, runInTestMode as boolean)
	set handlerName to "Batch Process" -- shorten name in logs
	
	----------------------------------------------------------------
	-- 0 ▸ Initialize & reset globals (COMPATIBILITY PRESERVED)
	----------------------------------------------------------------
	global testMode
	global contactsProcessed, contactsModified, totalOriginalLength
	global totalCharsRemoved, errorCount
	global inlineDuplicatesCount, blockDuplicatesCount, lineDuplicatesCount
	
	-- COMPATIBILITY: Keep all tracking counters for downstream functions
	global contactsSkippedFooter, contactsSkippedEmpty
	global contactsWithContent, contactsWithErrors
	global errorContactsList
	
	-- PERFORMANCE TRACKING: Progress reporting state (using globals)
	global lastProgressReport, lastProgressTime
	
	-- 0.1 ▸ Force defaults (PRESERVED)
	if runInTestMode is missing value then set runInTestMode to false
	set testMode to runInTestMode
	
	-- PERFORMANCE TRACKING: Determine processing mode for performance baseline
	set processingMode to "simulation"
	if not testMode then set processingMode to "update"
	
	global forceCleanup
	coLogDebug(handlerName & "(): forceCleanup=" & forceCleanup & ", defaultForceCleanupMode=" & defaultForceCleanupMode)
	
	-- Set skipProcessed: TRUE if and only if forceCleanup is EXACTLY the default value (PRESERVED)
	if (forceCleanup as string) is (defaultForceCleanupMode as string) then
		set shouldSkipProcessed to true
	else
		set shouldSkipProcessed to false
	end if
	
	coLogDebug(handlerName & "(): shouldSkipProcessed set to " & (shouldSkipProcessed as string))
	
	-- 0.2 ▸ Reset ALL counters (COMPATIBILITY PRESERVED)
	set contactsProcessed to 0
	set contactsModified to 0
	set totalOriginalLength to 0
	set totalCharsRemoved to 0
	set errorCount to 0
	set inlineDuplicatesCount to 0
	set blockDuplicatesCount to 0
	set lineDuplicatesCount to 0
	
	-- COMPATIBILITY: Reset tracking counters for downstream functions
	set contactsSkippedFooter to 0
	set contactsSkippedEmpty to 0
	set contactsWithContent to 0
	set contactsWithErrors to 0
	set errorContactsList to {}
	
	-- ✅ NEW: Initialize adaptive progress reporting for new session
	my initializeProgressReporting()
	
	coLogInfo(handlerName & "(): 🚀 Starting batch-clean • scope=" & selectionScope & " • testMode=" & testMode & " • skipProcessed=" & shouldSkipProcessed)
	
	----------------------------------------------------------------
	-- 1 ▸ Build the contact list (PRESERVED)
	----------------------------------------------------------------
	set contactsToProcess to {}
	try
		tell application "Contacts"
			if selectionScope is "selected" then
				set contactsToProcess to selection
			else
				set contactsToProcess to every person
			end if
		end tell
	on error fetchErr
		coLogError(handlerName & "(): Failed to fetch contacts: " & fetchErr)
		return {success:false, cancelled:false, report:"", stats:{processed:0, modified:0, skippedFooter:0, errors:errorCount + 1, charsRemoved:0, errorContactsList:{}}}
	end try
	
	if (count of contactsToProcess) = 0 then
		coLogInfo(handlerName & "(): No contacts found for scope=" & selectionScope)
		set skipReport to generateSkipReport({})
		return {success:true, cancelled:false, report:skipReport, stats:{processed:0, modified:0, skippedFooter:0, errors:0, charsRemoved:0, errorContactsList:{}}}
	end if
	
	----------------------------------------------------------------
	-- 2 ▸ Apply footer filtering if skipProcessed is enabled (PRESERVED)
	----------------------------------------------------------------
	if shouldSkipProcessed then
		set filteredContacts to {}
		set skippedContactsList to {}
		
		coLogInfo(handlerName & "(): Skip-mode ON → filtering out notes with existing CCC footer")
		
		repeat with c in contactsToProcess
			try
				set contactNote to ""
				tell application "Contacts"
					set contactNote to note of c
				end tell
				
				if contactNote is missing value then set contactNote to ""
				
				-- Check for existing CCC footer
				if contactNote contains "==== CCC Summary ====" then
					set contactsSkippedFooter to contactsSkippedFooter + 1
					set end of skippedContactsList to c
				else
					-- Otherwise, include it for processing
					copy c to end of filteredContacts
				end if
				
			on error chkErr
				-- On any error checking footer, process the contact anyway
				copy c to end of filteredContacts
				coLogWarning(handlerName & "(): Footer check failed (processing anyway): " & chkErr)
			end try
		end repeat
		
		-- 2.1 ▸ SHORT-CIRCUIT if nothing left to do
		if (count of filteredContacts) = 0 then
			set skipReport to generateSkipReport(skippedContactsList)
			return {success:true, cancelled:false, report:skipReport, stats:{processed:0, modified:0, skippedFooter:contactsSkippedFooter, errors:0, charsRemoved:totalCharsRemoved, errorContactsList:{}}}
		end if
		
		if shouldSkipProcessed and contactsSkippedFooter > 0 then
			coLogMilestone("🔍 Filtered " & (count of contactsToProcess) & " contacts for processing, skipping " & contactsSkippedFooter & " already processed)")
		end if
		
		-- Replace original list with the filtered one
		set contactsToProcess to filteredContacts
		
	else
		coLogInfo(handlerName & "(): Skip-mode OFF → processing all " & (count of contactsToProcess) & " contacts")
	end if
	
	-- ✅ Processing readiness milestone (after meaningful work is done)
	try
		set totalContacts to count of contactsToProcess
		set modeDesc to "Simulation"
		if not testMode then set modeDesc to "Edit"
		
		set skipDesc to "reprocessing all"
		if shouldSkipProcessed then set skipDesc to "will skip already processed contacts"
		
		set settingsMsg to "📋 Ready to process: " & totalContacts & " contacts • " & modeDesc & " mode • " & skipDesc
		
		if utilitiesScript is not missing value then
			coLogMilestone(settingsMsg)
		else
			coLogInfo(settingsMsg)
		end if
	on error settingsErr
		coLogWarning(handlerName & "(): Settings milestone error: " & settingsErr)
	end try
	
	----------------------------------------------------------------
	-- 3 ▸ ENHANCED: Process contacts with Performance Tracking integration
	----------------------------------------------------------------
	set totalContacts to count of contactsToProcess
	set startTime to current date
	
	-- PERFORMANCE TRACKING: Initialize progress tracking state
	set lastProgressReport to 0
	set lastProgressTime to startTime
	
	-- ✅ ENHANCED: Initial progress report with time estimation
	try
		if utilitiesScript is not missing value then
			set estimates to utilitiesScript's estimateProcessingTime(totalContacts, 0, 0, processingMode)
			set estimateMsg to ""
			if estimates's hasHistory then
				set estimateMsg to " • Should last approx.  " & (utilitiesScript's formatTimeEstimate(estimates's estimatedTotalTime))
			end if
			set startMsg to "🚀 Starting batch processing: " & totalContacts & " contacts" & estimateMsg
		else
			set startMsg to "🚀 Starting batch processing: " & totalContacts & " contacts"
		end if
		
		if utilitiesScript is not missing value then
			coLogMilestone(startMsg)
		else
			coLogWarning(startMsg)
		end if
	on error startErr
		coLogInfo("🚀 Starting batch processing: " & totalContacts & " contacts")
	end try
	
	-- ✅ OPTIMIZED: Process in chunks for I/O efficiency
	repeat with chunkIndex from 1 to totalContacts by CHUNK_SIZE
		set chunkEnd to chunkIndex + CHUNK_SIZE - 1
		if chunkEnd > totalContacts then set chunkEnd to totalContacts
		
		-- OPTIMIZATION: Load contact data in ONE batch call per chunk
		set contactDataList to {}
		try
			tell application "Contacts"
				repeat with i from chunkIndex to chunkEnd
					set currentContact to item i of contactsToProcess
					
					-- Handle missing value during data loading (PRESERVED)
					set contactNote to note of currentContact
					if contactNote is missing value then set contactNote to ""
					
					set contactData to {contactRef:currentContact, contactName:(name of currentContact), contactNote:contactNote, contactCreated:(creation date of currentContact), contactModified:(modification date of currentContact)}
					
					set end of contactDataList to contactData
				end repeat
			end tell
			
			coLogInfo(handlerName & "(): 📦 Loaded chunk " & ((chunkIndex - 1) div CHUNK_SIZE + 1) & " (" & (count of contactDataList) & " contacts)")
			
			if chunkIndex = 1 then
				coLogMilestone("📦 Processing started - first " & CHUNK_SIZE & " contacts loaded")
			end if
			
		on error chunkLoadErr
			coLogError(handlerName & "(): Failed to load chunk: " & chunkLoadErr)
			set errorCount to errorCount + 1
			-- Continue with next chunk
		end try
		
		-- ENHANCED: Process loaded data with Performance Tracking integration
		repeat with contactData in contactDataList
			set contactsProcessed to contactsProcessed + 1
			try
				set origNote to contactData's contactNote
				if origNote is missing value then set origNote to ""
				
				-- ✅ SINGLE-SOURCE CHARACTER COUNTING: Always count in main loop
				set totalOriginalLength to totalOriginalLength + (length of origNote)
				
				-- COMPATIBILITY: Derive tracking values from simplified logic
				if (length of origNote) = 0 then
					set contactsSkippedEmpty to contactsSkippedEmpty + 1
				else
					set contactsWithContent to contactsWithContent + 1
				end if
				
				-- ✅ UNIFIED PROCESSING: Always process all contacts (handles empty notes efficiently)
				set noteInfo to my processContactDataOptimized(contactData, testMode)
				
				-- Tally modifications (preserved from original)
				if noteInfo's modified then
					set contactsModified to contactsModified + 1
					set totalCharsRemoved to totalCharsRemoved + (noteInfo's charsRemoved)
				end if
				
			on error procErr
				-- COMPATIBILITY: Track errors with both simplified and legacy counters (PRESERVED)
				set errorCount to errorCount + 1
				set contactsWithErrors to contactsWithErrors + 1
				set end of errorContactsList to (contactData's contactName)
				coLogError(handlerName & "(): Error processing " & quote & (contactData's contactName) & quote & ": " & procErr)
			end try
			
			-- ✅ ADAPTIVE PROGRESS REPORTING (delegated to dedicated handler)
			try
				set elapsedTime to (current date) - startTime
				my checkAndReportProgress(contactsProcessed, totalContacts, elapsedTime, processingMode)
			on error progressErr
				-- Silent fallback - don't let progress reporting break processing
				coLogDebug(handlerName & "(): Progress reporting error (continuing): " & progressErr)
			end try
			
		end repeat
		
		-- Clear chunk from memory
		set contactDataList to {}
		
		delay 0.1 -- Brief pause between chunks for Contacts app stability (PRESERVED)
	end repeat
	
	----------------------------------------------------------------
	-- 4 ▸ ENHANCED: Final report & cleanup with Performance Tracking
	----------------------------------------------------------------
	-- 3.1 ▸ Restore forceCleanup default for next run (PRESERVED)
	set forceCleanup to defaultForceCleanupMode
	
	-- ✅ ENHANCED: Final progress report and performance recording
	set finalElapsedTime to (current date) - startTime
	try
		if utilitiesScript is not missing value then
			-- ✅ FIXED: Correct parameter format for recordSessionPerformance
			-- ENHANCED: Record performance with baseline threshold control
			try
				-- Determine if this session should update baseline (5+ contacts)
				set updateBaselineFlag to (contactsProcessed ≥ 5)
				
				if updateBaselineFlag then
					coLogDebug(handlerName & "(): Recording session with baseline update (" & contactsProcessed & " contacts)")
				else
					coLogDebug(handlerName & "(): Recording session WITHOUT baseline update (" & contactsProcessed & " contacts < 5 threshold)")
				end if
				
				-- Pass the updateBaseline flag to control baseline updates
				utilitiesScript's ¬
					¬
						recordSessionPerformance({mode:processingMode, contacts:contactsProcessed, elapsedSec:finalElapsedTime, updateBaseline:updateBaselineFlag} ¬
							)
				
			on error perfErr
				coLogWarning(handlerName & "(): Could not record session performance: " & perfErr)
			end try
		end if
		
		-- Format final completion message with proper time formatting
		if finalElapsedTime > 0 and contactsProcessed > 0 then
			set finalRate to contactsProcessed / finalElapsedTime
			set rateDisplay to (round (finalRate * 10)) / 10
			
			set timeDisplay to ""
			if utilitiesScript is not missing value then
				set timeDisplay to utilitiesScript's formatTimeEstimate(finalElapsedTime)
			else
				-- Fallback time formatting
				if finalElapsedTime < 60 then
					set timeDisplay to (round finalElapsedTime) & "s"
				else
					set timeDisplay to (finalElapsedTime div 60) & "m" & (round (finalElapsedTime mod 60)) & "s"
				end if
			end if
			
			set completeMsg to "✅ Completed " & contactsProcessed & " contacts in " & timeDisplay & " • " & rateDisplay & " contacts/sec"
		else
			set completeMsg to "✅ Completed " & contactsProcessed & " contacts"
		end if
		
		if utilitiesScript is not missing value then
			coLogMilestone(completeMsg)
		else
			coLogWarning(completeMsg)
		end if
		
		-- ✅ ENHANCED: Learning milestone (after completion, after recordSessionPerformance)
		try
			if utilitiesScript is not missing value then
				set baseline to utilitiesScript's getPerformanceBaseline(processingMode)
				if baseline's hasHistory then
					set sessionCount to baseline's sessionCount -- ✅ FIXED: No +1 since already updated
					if sessionCount = 1 then
						coLogMilestone("🧠 Performance learning: First " & processingMode & " session completed, baseline established")
					else
						coLogMilestone("🧠 Performance tracking: " & processingMode & " session " & sessionCount & " completed, baseline updated")
					end if
				else
					coLogMilestone("🧠 Performance learning: First " & processingMode & " session establishing baseline")
				end if
			end if
		on error learningErr
			coLogWarning("Performance Tracking System reporting milestone error: " & learningErr)
		end try
		
	on error recordErr
		coLogWarning(handlerName & "(): Could not record session performance: " & recordErr)
		try
			if utilitiesScript is not missing value then
				coLogMilestone("✅ Completed " & contactsProcessed & " contacts")
			else
				coLogInfo("✅ Completed " & contactsProcessed & " contacts")
			end if
		end try
	end try
	
	-- 4 ▸ Build and return the enhanced final report + stats (PRESERVED)
	set fullReport to generateStatsReport()
	try
		if (not testMode) then
			my updateCumulativeStats({processed:contactsProcessed, charsRemoved:totalCharsRemoved})
		end if
	on error statsErr
		coLogWarning("updateCumulativeStats call failed: " & statsErr)
	end try
	
	coLogInfo(handlerName & "(): ✔ Enhanced batch complete • processed=" & contactsProcessed & " • modified=" & contactsModified & " • skipped(footer)=" & contactsSkippedFooter & " • errors=" & errorCount)
	
	-- ✅ PRESERVED RETURN: Essential metrics only (BACKWARD COMPATIBLE)
	return {success:true, cancelled:false, report:fullReport, stats:{processed:contactsProcessed, modified:contactsModified, skippedFooter:contactsSkippedFooter, errors:errorCount, charsRemoved:totalCharsRemoved, errorContactsList:errorContactsList}}
end processContactsWithScopeOptimized

-- =============================================================================
-- Handler: checkAndReportProgress (FIXED GLOBAL VARIABLE HANDLING)
-- VERSION: 3.0.1 (2025-07-08)
-- PURPOSE: Adaptive progress reporting with proper variable initialization
-- FIX: Proper global variable initialization to prevent "variable not defined" errors
-- =============================================================================
on checkAndReportProgress(contactsProcessed, totalContacts, elapsedTime, processingMode)
	-- Early exit for start/end conditions
	if contactsProcessed ≤ 1 or contactsProcessed ≥ totalContacts then return false
	
	try
		-- ✅ FIXED: Proper global variable initialization with error handling
		global reportingStrategy, reportingInterval, lastTimeReport
		global milestone25Reported, milestone50Reported, milestone75Reported
		
		-- ✅ SAFE INITIALIZATION CHECK using error handling
		set needsInitialization to false
		try
			-- Try to access the variable
			set testValue to reportingStrategy
			if testValue is missing value then set needsInitialization to true
		on error
			-- Variable not defined yet - needs initialization
			set needsInitialization to true
		end try
		
		-- ✅ INITIALIZE ON FIRST CALL
		if needsInitialization then
			set reportingStrategy to my determineReportingStrategy(totalContacts, processingMode)
			set lastTimeReport to 0
			set milestone25Reported to false
			set milestone50Reported to false
			set milestone75Reported to false
			
			coLogDebug("Adaptive reporting initialized: " & reportingStrategy's strategy & " (" & reportingStrategy's interval & "s intervals)")
		end if
		
		-- ✅ EXECUTE CHOSEN STRATEGY
		set shouldReport to false
		set reportReason to ""
		
		if reportingStrategy's strategy is "discovery" then
			-- Discovery phase: frequent reports for UX learning
			if elapsedTime - lastTimeReport ≥ reportingStrategy's interval then
				set shouldReport to true
				set lastTimeReport to elapsedTime
				set reportReason to "discovery-" & reportingStrategy's interval & "s"
			end if
			
		else if reportingStrategy's strategy is "percentage" then
			-- Small jobs: clean percentage milestones
			set progressPercent to (contactsProcessed * 100) div totalContacts
			if progressPercent ≥ 75 and not milestone75Reported then
				set shouldReport to true
				set milestone75Reported to true
				set reportReason to "75%-milestone"
			else if progressPercent ≥ 50 and not milestone50Reported then
				set shouldReport to true
				set milestone50Reported to true
				set reportReason to "50%-milestone"
			else if progressPercent ≥ 25 and not milestone25Reported then
				set shouldReport to true
				set milestone25Reported to true
				set reportReason to "25%-milestone"
			end if
			
		else if reportingStrategy's strategy is "time-based" then
			-- Medium/large jobs: time-based intervals
			if elapsedTime - lastTimeReport ≥ reportingStrategy's interval then
				set shouldReport to true
				set lastTimeReport to elapsedTime
				set reportReason to "time-" & reportingStrategy's interval & "s"
			end if
		end if
		
		-- ✅ GENERATE PROGRESS REPORT
		if shouldReport then
			return my generateProgressReport(contactsProcessed, totalContacts, elapsedTime, reportReason)
		end if
		
		return false
		
	on error reportErr
		coLogWarning("Adaptive progress reporting error: " & reportErr)
		return false
	end try
end checkAndReportProgress
-- =============================================================================
-- Handler: generateProgressReport
-- VERSION: 1.0.0 (2025-07-08)
-- PURPOSE: Generate consistent progress reports with strategy context
-- =============================================================================
on generateProgressReport(contactsProcessed, totalContacts, elapsedTime, reportReason)
	try
		set progressPercent to (contactsProcessed * 100) div totalContacts
		
		if elapsedTime > 0 then
			set currentRate to contactsProcessed / elapsedTime
			set rateDisplay to (round (currentRate * 10)) / 10
			
			set remainingContacts to totalContacts - contactsProcessed
			set remainingTime to remainingContacts / currentRate
			
			set elapsedDisplay to utilitiesScript's formatTimeEstimate(elapsedTime)
			set remainingDisplay to utilitiesScript's formatTimeEstimate(remainingTime)
			
			set progressMsg to "📊 Progress: " & contactsProcessed & "/" & totalContacts & " (" & progressPercent & "%) • " & elapsedDisplay & " elapsed • " & remainingDisplay & " remaining • " & rateDisplay & " contacts/sec"
			
			-- Optional: Add strategy context in debug mode
			global debugMode
			if debugMode then set progressMsg to progressMsg & " [" & reportReason & "]"
		else
			set progressMsg to "📊 Progress: " & contactsProcessed & "/" & totalContacts & " (" & progressPercent & "%)"
		end if
		
		coLogMilestone(progressMsg)
		return true
		
	on error reportErr
		coLogWarning("Error generating progress report: " & reportErr)
		return false
	end try
end generateProgressReport

-- =============================================================================
-- Handler: determineReportingStrategy (FIXED PERFORMANCE DATA ACCESS)
-- VERSION: 1.2.0 (2025-07-08)
-- PURPOSE: Dynamic calibration with proper performance history access
-- FIX: Access full performance history instead of simplified baseline record
-- =============================================================================
on determineReportingStrategy(totalContacts, processingMode)
	try
		-- ✅ GET FULL PERFORMANCE HISTORY (not just baseline)
		set perfHistory to utilitiesScript's loadPerformanceHistory()
		
		-- ✅ ACCESS MODE-SPECIFIC DATA from full history
		if processingMode is "simulation" then
			set modeData to perfHistory's simulationMode
		else
			set modeData to perfHistory's updateMode
		end if
		
		set sessionCount to modeData's sessionCount
		set totalProcessedContacts to modeData's totalContacts
		set hasCalibration to (sessionCount > 0)
		
		-- ✅ DYNAMIC CALIBRATION THRESHOLDS (percentage-based)
		set calibrationPercentage to 2.5 -- 2.5% of total contact base
		set minSessionsForCalibration to 3
		
		-- Calculate required contacts for calibration
		set requiredCalibrationContacts to (totalContacts * calibrationPercentage) div 100
		if requiredCalibrationContacts < 15 then set requiredCalibrationContacts to 15 -- Minimum 15 contacts
		if requiredCalibrationContacts > 300 then set requiredCalibrationContacts to 300 -- Maximum 300 contacts
		
		-- ✅ CALIBRATION STATUS CHECK
		set isCalibrated to false
		if hasCalibration and sessionCount ≥ minSessionsForCalibration then
			if totalProcessedContacts ≥ requiredCalibrationContacts then
				set isCalibrated to true
				coLogDebug("Performance calibrated: " & totalProcessedContacts & "/" & requiredCalibrationContacts & " contacts (" & calibrationPercentage & "% of " & totalContacts & ")")
			else
				coLogDebug("Need more contacts: " & totalProcessedContacts & "/" & requiredCalibrationContacts & " (" & (requiredCalibrationContacts - totalProcessedContacts) & " more needed)")
			end if
		else
			coLogDebug("Need more sessions: " & sessionCount & "/" & minSessionsForCalibration & " sessions")
		end if
		
		-- ✅ DISCOVERY PHASE: Frequent reporting until calibrated
		if not isCalibrated then
			-- Adaptive discovery intervals based on total database size
			if totalContacts ≤ 100 then
				set discoveryInterval to 8 -- Small database: 8s intervals
			else if totalContacts ≤ 1000 then
				set discoveryInterval to 12 -- Medium database: 12s intervals
			else
				set discoveryInterval to 15 -- Large database: 15s intervals
			end if
			
			return {strategy:"discovery", interval:discoveryInterval, reason:"Calibrating (" & totalProcessedContacts & "/" & requiredCalibrationContacts & " contacts processed)"}
		end if
		
		-- ✅ CALIBRATED PHASE: Use prediction for optimal strategy
		set estimates to utilitiesScript's estimateProcessingTime(totalContacts, 0, 0, processingMode)
		set estimatedDuration to estimates's estimatedTotalTime
		
		coLogDebug("Estimated job duration: " & (round estimatedDuration) & "s for " & totalContacts & " contacts (calibrated baseline)")
		
		-- ✅ INTELLIGENT STRATEGY SELECTION
		if estimatedDuration ≤ 90 then
			-- Very short jobs (≤1.5min): Clean percentage milestones
			return {strategy:"percentage", interval:0, reason:"Short job (" & (round estimatedDuration) & "s) - clean milestones"}
			
		else if estimatedDuration ≤ 300 then
			-- Medium jobs (1.5-5min): 20-second intervals
			return {strategy:"time-based", interval:20, reason:"Medium job (" & (round estimatedDuration) & "s) - 20s reports"}
			
		else if estimatedDuration ≤ 900 then
			-- Long jobs (5-15min): 30-second intervals
			return {strategy:"time-based", interval:30, reason:"Long job (" & (round estimatedDuration) & "s) - 30s reports"}
			
		else
			-- Very long jobs (>15min): 60-second intervals
			return {strategy:"time-based", interval:60, reason:"Very long job (" & (round estimatedDuration) & "s) - 60s reports"}
		end if
		
	on error strategyErr
		coLogWarning("Error in strategy determination: " & strategyErr)
		-- ✅ SAFE FALLBACK with discovery mode for unknown conditions
		return {strategy:"discovery", interval:15, reason:"Fallback to discovery mode due to error: " & strategyErr}
	end try
end determineReportingStrategy

-------------------------------------------------------------------------------
-- Handler: initializeProgressReporting
-- VERSION: 1.0.0 (2025-07-07)
-- PURPOSE: Reset progress reporting state for new processing session
-- CALLED: At the start of each batch processing session
-------------------------------------------------------------------------------
on initializeProgressReporting()
	global lastTimeReport, reportingInterval, adaptiveReportingInitialized
	global milestone25Reported, milestone50Reported, milestone75Reported
	
	set lastTimeReport to 0
	set reportingInterval to missing value
	set adaptiveReportingInitialized to false
	set milestone25Reported to false
	set milestone50Reported to false
	set milestone75Reported to false
end initializeProgressReporting

-- ============================================
-- Handler: processContactDataOptimized
-- PURPOSE: Process contact using pre-loaded data while preserving ALL original functionality
-- PRESERVES: Backups, footer handling, date capture, error handling, statistics
-- OPTIMIZES: Uses pre-loaded data instead of additional I/O calls
-- ============================================
on processContactDataOptimized(contactData, testMode)
	set handlerName to "Processing "
	
	-- Access global counters for comprehensive session statistics (PRESERVED)
	global debugMode, inlineDuplicatesCount, blockDuplicatesCount, lineDuplicatesCount
	global inlineCharsRemoved, lineCharsRemoved, blockCharsRemoved, totalOriginalLength
	
	-- 0. PRE-FLIGHT CHECKS (PRESERVED) - but using pre-loaded data
	set contactRef to contactData's contactRef
	if contactRef is missing value then
		coLogError(handlerName & "(): Contact reference is missing value")
		return {success:false, modified:false, reason:"Missing contact reference", charsRemoved:0}
	end if
	set contactName to contactData's contactName
	
	-- Handle missing value BEFORE any length operations
	if contactData's contactNote is missing value then
		set originalNote to ""
		-- coLogDebug(handlerName & "(): Contact has missing value note: " & contactName)
	end if
	
	set originalNote to contactData's contactNote as text
	
	-- Initialize any missing global counters for session statistics safety (PRESERVED)
	if inlineDuplicatesCount is missing value then set inlineDuplicatesCount to 0
	if lineDuplicatesCount is missing value then set lineDuplicatesCount to 0
	if blockDuplicatesCount is missing value then set blockDuplicatesCount to 0
	if inlineCharsRemoved is missing value then set inlineCharsRemoved to 0
	if lineCharsRemoved is missing value then set lineCharsRemoved to 0
	if blockCharsRemoved is missing value then set blockCharsRemoved to 0
	if totalOriginalLength is missing value then set totalOriginalLength to 0
	
	-- coLogDebug(handlerName & "(): Starting processing for: " & contactName)
	
	-- 1. CONTACT DATE CAPTURE (PRESERVED) - using pre-loaded data
	set contactDates to {modDate:(contactData's contactModified as text), creationDate:(contactData's contactCreated as text), source:"pre-loaded"}
	
	-- coLogDebug(handlerName & "(): Contact dates for " & contactName & " - Mod: " & contactDates's modDate & ", Created: " & contactDates's creationDate)
	
	-- 2. NOTE HANDLING (OPTIMIZED) - skip three-strategy retrieval, use pre-loaded
	if originalNote is missing value then set originalNote to ""
	set originalNote to originalNote as text
	
	-- Check if this note already has a footer (PRESERVED)
	set hasFooter to my hasCCCFooter(originalNote)
	
	-- coLogDebug(handlerName & "(): Using pre-loaded note of length: " & (length of originalNote))
	
	-- 3. ORIGINAL NOTE BACKUP (PRESERVED)
	if (not testMode or debugMode) then
		try
			my backupContactNoteWithType(contactRef, contactName, originalNote, "original")
			-- coLogDebug(handlerName & "(): Backed-up original note of length: " & (length of originalNote))
		on error backupErr
			coLogWarning(handlerName & "(): Original backup error for " & contactName & ": " & backupErr)
			-- Continue processing despite backup failure
		end try
	else
		-- coLogDebug(handlerName & "(): Skipping note backup in test mode for: " & contactName)
	end if
	
	-- 4. FOOTER EXTRACTION AND CONTENT ISOLATION (PRESERVED)
	set footerBlock to my extractExistingFooter(originalNote)
	if footerBlock ≠ "" then
		set cleanedText to text 1 thru ((offset of footerBlock in originalNote) - 1) of originalNote
		coLogDebug(handlerName & "(): Extracted existing footer from note")
	else
		set cleanedText to originalNote
		-- coLogDebug(handlerName & "(): No existing footer found")
	end if
	
	-- 5. CONTENT PROCESSING PIPELINE (PRESERVED)
	set originalLength to length of cleanedText
	set finalText to my processNoteContentOptimized(cleanedText)
	-- coLogDebug(handlerName & "(): Processing completed, result length: " & (length of finalText) & " characters")
	
	-- 6. MODIFICATION ANALYSIS AND METRICS CALCULATION (PRESERVED)
	set charsRemoved to originalLength - (length of finalText)
	if charsRemoved < 0 then set charsRemoved to 0
	set contentModified to (charsRemoved > 0)
	set modificationReason to "Content simplified and optimized: " & charsRemoved & " characters removed"
	
	-- 7. ENHANCED FOOTER BUILDING WITH DATE FORMATTING (PRESERVED)
	-- coLogDebug(handlerName & "(): Building CCC footer for " & contactName & " (" & charsRemoved & " chars removed)")
	
	set finalNoteWithFooter to my updateCCCFooter(finalText, charsRemoved, originalLength, contentModified, contactDates)
	
	-- 8. PROCESSED NOTE BACKUP WITH COMPLETE FOOTER (PRESERVED)
	if (not testMode or debugMode) then
		try
			-- Ensure processed note includes complete final result with footer
			set safeProcessedNote to finalNoteWithFooter
			if (class of safeProcessedNote) is list then
				set safeProcessedNote to utilitiesScript's joinText(safeProcessedNote, return & return)
			end if
			
			my backupContactNoteWithType(contactRef, contactName, safeProcessedNote, "processed")
			-- coLogDebug(handlerName & "(): Backed up complete processed note with footer (length: " & (length of safeProcessedNote) & ")")
			
		on error processedBackupErr
			coLogWarning(handlerName & "(): Processed backup error for " & contactName & ": " & processedBackupErr)
			-- Continue with contact update despite backup failure
		end try
	end if
	
	-- 9. CONTACT UPDATE OR SIMULATION REPORTING (PRESERVED) - SINGLE I/O CALL
	if contentModified and not testMode then
		try
			tell application "Contacts"
				set note of contactRef to finalNoteWithFooter
				delay 0.1 -- Brief pause for Contacts app stability
				save
			end tell
			coLogDebug(handlerName & "(): Note updated for " & contactName)
			
		on error updateErr
			coLogError(handlerName & "(): Failed to update contact " & contactName & ": " & updateErr)
			return {success:false, modified:false, reason:"Contact update failed: " & updateErr, charsRemoved:0}
		end try
		
	else if testMode then
		coLogDebug(handlerName & contactName & " [SIMULATION] (" & charsRemoved & " chars removed)")
	else
		coLogDebug(handlerName & "(): No changes needed for " & contactName)
	end if
	
	-- 10. COMPREHENSIVE RETURN WITH PROCESSING METRICS (PRESERVED)
	return {success:true, modified:contentModified, reason:modificationReason, charsRemoved:charsRemoved}
end processContactDataOptimized


-------------------------------------------------------------------------------
-- GENERATE CLEANUP SUMMARY REPORT
-- on generateStatsReport(statsRecord, scriptVersion)
--   Builds the final cleanup summary text, using the unified counters.
-------------------------------------------------------------------------------
-- ✅ SIMPLE FIX: Add legacy-compatible reporting function
on generateStatsReportLegacy()
	set handlerName to "generateStatsReportLegacy"
	coLogInfo(handlerName & "(): Generating legacy-compatible cleanup summary report")
	
	-- Access only basic counters (guaranteed to exist in legacy)
	global contactsProcessed, contactsModified, totalOriginalLength, totalCharsRemoved
	global startTime, testMode, scriptVersion, skippedContacts, errorCount
	
	-- Timing calculations
	set endTime to current date
	set elapsedSeconds to endTime - startTime
	set avgTimePerContact to 0
	if contactsProcessed > 0 then set avgTimePerContact to elapsedSeconds / contactsProcessed
	
	-- Build legacy-compatible report
	set reportText to "✅ Process Results (" & scriptVersion & ")" & return & return
	-- set reportText to reportText & "Pipeline: Legacy (Original)" & return & return
	
	-- 📊 Basic Process Stats
	set reportText to reportText & "📊 Process Stats:" & return
	set reportText to reportText & "• Contacts processed: " & contactsProcessed & return
	set reportText to reportText & "• Contacts with content cleaned: " & contactsModified & return
	
	-- Handle skipped contacts if variable exists
	try
		global skippedContacts
		set reportText to reportText & "• Contacts skipped: " & skippedContacts & return
	on error
		set reportText to reportText & "• Contacts skipped: 0" & return
	end try
	
	set reportText to reportText & return
	
	-- 💾 Data Cleanup
	set reportText to reportText & "💾 Data Cleanup:" & return
	set reportText to reportText & "• Total characters processed: " & totalOriginalLength & return
	set reportText to reportText & "• Total characters removed: " & totalCharsRemoved & return
	
	if totalOriginalLength > 0 then
		set cleanupMetrics to utilitiesScript's computeReductionMetrics(totalCharsRemoved, totalOriginalLength)
		set reportText to reportText & "• Percentage reduction: " & ((round ((cleanupMetrics's pct) * 100)) / 100) & "%" & return
	end if
	set reportText to reportText & return
	
	-- ⏱ Performance
	set reportText to reportText & "⏱ Performance:" & return
	set reportText to reportText & "• Total processing time: " & ((round (elapsedSeconds * 10)) / 10) & " seconds" & return
	set reportText to reportText & "• Average per contact: " & ((round (avgTimePerContact * 100)) / 100) & " seconds" & return
	
	-- Handle errors if variable exists
	try
		global errorCount
		if errorCount > 0 then
			set reportText to reportText & "• Processing errors: " & errorCount & return
		end if
	end try
	
	set reportText to reportText & return
	
	-- Simulation notice
	if testMode then
		set reportText to reportText & "⚠️ SIMULATION NOTICE:" & return
		set reportText to reportText & "• No actual changes were made to your contacts" & return
		set reportText to reportText & "• This report shows what would happen in normal mode" & return
	end if
	
	return reportText
end generateStatsReportLegacy


-- ============================================
-- Handler: getProcessingStatsRecord (ENHANCED with Session Info)
-- PURPOSE: Single source of truth for stats including session information
-- RETURNS: Complete stats record with all computed values + session data
-- ============================================
on getProcessingStatsRecord()
	-- Access all counters with safe fallbacks
	global contactsProcessed, contactsModified, totalOriginalLength, totalCharsRemoved
	global startTime, testMode, scriptVersion, reportsFolder
	global contactsSkippedFooter, contactsSkippedEmpty, contactsWithContent, contactsWithErrors, errorContactsList
	
	-- ENHANCED: Session information extraction
	set sessionStartFormatted to ""
	set reportFolderPath to ""
	
	set sessionStartFormatted to (startTime as text)
	
	try
		global reportsFolder
		set reportFolderPath to reportsFolder
	on error
		set reportFolderPath to "Session folder"
	end try
	
	-- Safe extraction with fallbacks
	set stats to ¬
		{totalExamined:contactsProcessed, withContent:(my getGlobalValueSafe(contactsWithContent, contactsProcessed)), modified:contactsModified, skippedFooter:(my getGlobalValueSafe(contactsSkippedFooter, 0)), skippedEmpty:(my getGlobalValueSafe(contactsSkippedEmpty, 0)), errors:(my getGlobalValueSafe(contactsWithErrors, 0)), errorNames:(my getGlobalValueSafe(errorContactsList, {})), charsProcessed:totalOriginalLength, charsRemoved:totalCharsRemoved, testMode:testMode, sessionStart:sessionStartFormatted, reportFolder:reportFolderPath}
	
	-- Timing calculations
	-- ✅ ENHANCED: High-precision timing calculations
	set endTime to current date
	set elapsedSeconds to endTime - startTime
	
	-- ✅ FIX: Minimum realistic time for very fast operations
	if elapsedSeconds ≤ 0 then
		set elapsedSeconds to 0.1 -- Minimum 100ms for any processing
		my coLogDebug("getProcessingStatsRecord(): Adjusted zero elapsed time to 0.1s minimum")
	else if elapsedSeconds < 0.05 then
		set elapsedSeconds to 0.1 -- Round up very small times to realistic minimum
		my coLogDebug("getProcessingStatsRecord(): Adjusted very fast time to 0.1s minimum")
	end if
	
	-- Calculate avgTimeContent with proper AppleScript syntax
	if stats's withContent > 0 then
		set avgTimeContentValue to elapsedSeconds / (stats's withContent)
	else
		set avgTimeContentValue to 0
	end if
	
	set stats to stats & {elapsedSeconds:elapsedSeconds, avgTimeAll:(elapsedSeconds / contactsProcessed), avgTimeContent:avgTimeContentValue}
	
	-- Percentage calculation
	if totalOriginalLength > 0 then
		set cleanupMetrics to utilitiesScript's computeReductionMetrics(totalCharsRemoved, totalOriginalLength)
		set stats to stats & {percentReduction:cleanupMetrics's pct}
	else
		set stats to stats & {percentReduction:0}
	end if
	
	return stats
end getProcessingStatsRecord

-- Helper for safe global variable access
on getGlobalValueSafe(globalVar, defaultValue)
	try
		return globalVar
	on error
		return defaultValue
	end try
end getGlobalValueSafe


-- ============================================
-- Handler: getSessionPerformanceData
-- VERSION: 1.0.0-sync (2025-07-01)
-- PURPOSE: Provide consistent performance data for both dialog and console reports
-- RETURNS: Record with timing, rate, and baseline comparison data
-- ============================================
on getSessionPerformanceData()
	global contactsProcessed, startTime
	
	-- Get precise elapsed time
	set endTime to current date
	set elapsedSeconds to endTime - startTime
	
	-- Apply minimum time fix
	if elapsedSeconds ≤ 0 then
		set elapsedSeconds to 0.1
	else if elapsedSeconds < 0.05 then
		set elapsedSeconds to 0.1
	end if
	
	-- Calculate rate
	set processingRate to 0
	if contactsProcessed > 0 then
		set processingRate to contactsProcessed / elapsedSeconds
	end if
	
	return {contactsProcessed:contactsProcessed, elapsedSeconds:elapsedSeconds, processingRate:processingRate, rateDisplay:my formatProcessingRate(contactsProcessed, elapsedSeconds)}
end getSessionPerformanceData

-- ============================================
-- Handler: generateStatsReport (ENHANCED with Session Info)
-- PURPOSE: Generate enhanced report with detailed tracking + session information
-- ============================================
on generateStatsReport()
	set handlerName to "generateStatsReport"
	coLogInfo(handlerName & "(): Generating enhanced cleanup summary report with session info")
	
	-- Get all stats in one call (includes timing and enhanced tracking)
	set stats to getProcessingStatsRecord()
	
	-- ENHANCED: Get session information
	global startTime, reportsFolder, scriptVersion
	
	-- Get session start time in human-readable format
	set sessionStartFormatted to (startTime as text)
	
	-- Get current report folder path
	set reportFolderPath to ""
	try
		global reportsFolder
		set reportFolderPath to reportsFolder
	on error
		set reportFolderPath to "Session folder"
	end try
	
	-- ENHANCED: Build report with session information header
	set reportText to "✅ Cleanup Summary (" & scriptVersion & ")" & return
	set reportText to reportText & "Session started: " & sessionStartFormatted & return
	-- set reportText to reportText & "Report location: " & reportFolderPath & return
	-- set reportText to reportText & "Pipeline: Enhanced I/O Optimized with Detailed Tracking" & return & return
	
	-- 📊 Enhanced Process Stats
	set reportText to reportText & return & "📊 Process Statistics:" & return
	set reportText to reportText & "• Total contacts examined: " & (stats's totalExamined) & return
	set reportText to reportText & "• Contacts with content processed: " & (stats's withContent) & return
	set reportText to reportText & "• Contacts modified: " & (stats's modified) & return
	set reportText to reportText & "• Contacts skipped (already processed): " & (stats's skippedFooter) & return
	set reportText to reportText & "• Contacts skipped (empty notes): " & (stats's skippedEmpty) & return & return
	
	-- 💾 Data Cleanup
	set reportText to reportText & "💾 Data Cleanup:" & return
	set reportText to reportText & "• Total characters processed: " & (stats's charsProcessed) & return
	set reportText to reportText & "• Total characters removed: " & (stats's charsRemoved) & return
	set reportText to reportText & "• Percentage reduction: " & ((round ((stats's percentReduction) * 100)) / 100) & "%" & return & return
	
	-- ⏱ Enhanced Performance with Smart Time Formatting
	set reportText to reportText & "⏱ Performance:" & return
	
	-- ENHANCED: Smart time formatting for total processing time
	set elapsedSeconds to stats's elapsedSeconds
	if elapsedSeconds < 60 then
		set reportText to reportText & "• Total processing time: " & ((round (elapsedSeconds * 10)) / 10) & " seconds" & return
	else
		set minutesPart to elapsedSeconds div 60
		set secondsPart to elapsedSeconds mod 60
		set reportText to reportText & "• Total processing time: " & minutesPart & "min " & (secondsPart as integer) & "sec (" & ((round (elapsedSeconds * 10)) / 10) & " seconds)" & return
	end if
	
	-- ✅ ENHANCED: Smart rate display with minimum time handling
	if stats's elapsedSeconds > 0 and stats's totalExamined > 0 then
		set smartRate to my formatProcessingRate(stats's totalExamined, stats's elapsedSeconds)
	else
		-- Fallback calculation with minimum time
		set minTime to 0.1
		if stats's totalExamined > 0 then
			set smartRate to my formatProcessingRate(stats's totalExamined, minTime)
			set smartRate to smartRate & " (estimated)"
		else
			set smartRate to "calculating..."
		end if
	end if
	set reportText to reportText & "• Processing rate: " & smartRate & return & return
	
	-- 🚨 Enhanced Error Reporting
	if (stats's errors) > 0 then
		set reportText to reportText & "🚨 Processing Errors:" & return
		set reportText to reportText & "• Contacts with errors: " & (stats's errors) & return
		if (count of (stats's errorNames)) > 0 then
			set reportText to reportText & "• Error contact names: " & utilitiesScript's joinText((stats's errorNames), ", ") & return
		end if
		set reportText to reportText & return
	end if
	
	-- Simulation notice
	if stats's testMode then
		set reportText to reportText & "⚠️ SIMULATION NOTICE:" & return
		set reportText to reportText & "• No actual changes were made to your contacts" & return
		set reportText to reportText & "• This report shows what would happen in normal mode" & return
	end if
	
	return reportText
end generateStatsReport

-- 🏷 Issue Summary (for next iteration)
(*
	if tagLinkedIn > 0 or tagDupLinkedIn > 0 or tagDupURL > 0 or tagMultiProfile > 0 then
		coLogDebug("Adding tag summary section to report")
		set reportText to reportText & return & "🏷 Issue Summary:" & return
		if tagLinkedIn > 0 then set reportText to reportText & "• 🔗 LinkedIn tracking parameters: " & tagLinkedIn & " contact(s)" & return
		if tagDupLinkedIn > 0 then set reportText to reportText & "• 👤 Duplicate LinkedIn profiles: " & tagDupLinkedIn & " contact(s)" & return
		if tagDupURL > 0 then set reportText to reportText & "• 🔄 Duplicate URLs detected: " & tagDupURL & " contact(s)" & return
		if tagMultiProfile > 0 then set reportText to reportText & "• 👥 Multiple profiles found: " & tagMultiProfile & " contact(s)" & return
	end if
	*)


-------------------------------------------------------------------------------
-- Handler: saveReportToFile
-- VERSION: 1.0.0-unified (2025-05-21)
-- PURPOSE: Unified file save for ContactOperations reports using Utilities.
--          Ensures folder exists, file is touched, logs via Utilities.
--          Returns true on success, false on failure.
-------------------------------------------------------------------------------
on saveReportToFile(reportText, reportPath)
	global utilitiesScript
	set handlerName to "saveReportToFile"
	
	try
		-- Ensure parent folder exists
		set AppleScript's text item delimiters to ":"
		set pathItems to text items of reportPath
		if (count of pathItems) > 1 then
			set parentFolder to (items 1 thru -2 of pathItems as string) & ":"
			utilitiesScript's createFolderPath(parentFolder)
		end if
		set AppleScript's text item delimiters to ""
		
		-- Touch file to guarantee alias coercion works
		try
			do shell script "touch " & quoted form of (POSIX path of reportPath)
		end try
		
		-- Save the file using unified Utilities handler
		set saveResult to utilitiesScript's saveTextToFile(reportText, reportPath)
		
		-- Logging through Utilities
		if saveResult is true then
			-- coLogDebug(handlerName & "(): ContactOperations report saved to: " & reportPath)
			
			return true
		else
			coLogError(handlerName & "(): saveReportToFile failed for: " & reportPath)
			return false
		end if
		
	on error errMsg
		coLogError(handlerName & "(): ContactOperations", "saveReportToFile exception: " & errMsg & " (" & reportPath & ")")
		return false
	end try
end saveReportToFile

-- ==========================================================
-- CONTACT PROCESSING
-- ==========================================================

-- ==========================================================
-- Handler: captureContactDates
-- VERSION: 6.0.0-alpha27+ (2025-01-09)
-- PURPOSE: Capture both modification and creation dates of a contact before CCC 
--          processing, to preserve complete temporal history in footer
-- INPUTS:  aPerson (Contacts record) - the contact to query
--          contactName (text) - contact name for logging (optional, for performance)
-- RETURNS: record - {modDate:text, creationDate:text, source:text}
--          - modDate: formatted modification date or ""
--          - creationDate: formatted creation date or ""  
--          - source: which strategy succeeded ("direct", "vcard", "system", "none")
-- NOTES:   Uses multiple fallback strategies to capture both timestamps
--          Creation date capture is attempted but may not be available in all cases
-- ==========================================================
on captureContactDates(aPerson, contactName)
	set handlerName to "captureContactDates"
	-- Input validation with defensive defaults
	if aPerson is missing value then
		coLogWarning(handlerName & "(): Invalid contact (missing value)")
		return {modDate:"", creationDate:"", source:"none"}
	end if
	
	if contactName is missing value or contactName is "" then
		set contactName to "<Unknown Contact>"
	end if
	
	-- coLogDebug(handlerName & "(): Capturing modification and creation dates for: " & contactName)
	
	-- Initialize result record
	set dateResult to {modDate:"", creationDate:"", source:"none"}
	
	-- Strategy 1: Direct contact date properties (most reliable)
	try
		tell application "Contacts"
			set contactModDate to missing value
			set contactCreationDate to missing value
			
			-- Try modification date
			try
				set contactModDate to modification date of aPerson
				if contactModDate is not missing value then
					set dateResult's modDate to my formatDateCompact(contactModDate)
					-- coLogDebug(handlerName & "(): Direct mod date for " & contactName & ": " & dateResult's modDate)
				end if
			on error modErr
				coLogWarning(handlerName & "(): Modification date property unavailable for " & contactName & ": " & modErr)
			end try
			
			-- Try creation date  
			try
				set contactCreationDate to creation date of aPerson
				if contactCreationDate is not missing value then
					set dateResult's creationDate to my formatDateCompact(contactCreationDate)
					-- coLogDebug(handlerName & "(): Direct creation date for " & contactName & ": " & dateResult's creationDate)
				else
					coLogWarning(handlerName & "(): Creation date property returned missing value for " & contactName)
				end if
			on error createErr
				coLogWarning(handlerName & "(): Creation date property unavailable for " & contactName & ": " & createErr)
			end try
			
			-- If we got at least one date via direct access, mark as successful
			if dateResult's modDate is not "" or dateResult's creationDate is not "" then
				set dateResult's source to "direct"
				return dateResult
			end if
		end tell
	on error directErr
		coLogWarning(handlerName & "(): Direct date access failed for " & contactName & ": " & directErr)
	end try
	
	-- Strategy 2: vCard metadata parsing (advanced fallback)
	try
		tell application "Contacts"
			set vcardData to vcard of aPerson as text
			
			-- Parse vCard for REV (revision/modification) field
			if vcardData contains "REV:" and dateResult's modDate is "" then
				set revStart to offset of "REV:" in vcardData
				set revLine to paragraph 1 of (text revStart thru -1 of vcardData)
				set revValue to utilitiesScript's trimWhitespace(text 5 thru -1 of revLine) -- Skip "REV:"
				
				set parsedModDate to my parseVCardTimestamp(revValue)
				if parsedModDate is not "" then
					set dateResult's modDate to parsedModDate
					coLogDebug(handlerName & "(): vCard REV date for " & contactName & ": " & parsedModDate)
				end if
			end if
			
			-- Parse vCard for custom creation date fields (if they exist)
			-- Some vCard implementations use X-CREATION-DATE or similar
			set creationPatterns to {"X-CREATION-DATE:", "X-CREATED:", "X-CREATE-DATE:"}
			repeat with pattern in creationPatterns
				if vcardData contains pattern and dateResult's creationDate is "" then
					set createStart to offset of pattern in vcardData
					set createLine to paragraph 1 of (text createStart thru -1 of vcardData)
					set createValue to utilitiesScript's trimWhitespace(text ((length of pattern) + 1) thru -1 of createLine)
					
					set parsedCreateDate to my parseVCardTimestamp(createValue)
					if parsedCreateDate is not "" then
						set dateResult's creationDate to parsedCreateDate
						coLogDebug(handlerName & "(): vCard creation date for " & contactName & ": " & parsedCreateDate)
						exit repeat
					end if
				end if
			end repeat
			
			-- If we got dates from vCard, mark as successful
			if dateResult's modDate is not "" or dateResult's creationDate is not "" then
				set dateResult's source to "vcard"
				return dateResult
			end if
		end tell
	on error vCardErr
		coLogWarning(handlerName & "(): vCard parsing failed for " & contactName & ": " & vCardErr)
	end try
	
	-- Strategy 3: System timestamp as last resort (for modification date only)
	try
		if dateResult's modDate is "" then
			set currentTimestamp to my formatDateCompact(current date)
			set dateResult's modDate to currentTimestamp
			set dateResult's source to "system"
			coLogDebug(handlerName & "(): No dates found for " & contactName & ", using current timestamp: " & currentTimestamp)
		end if
	on error systemErr
		coLogError(handlerName & "(): System timestamp failed for " & contactName & ": " & systemErr)
	end try
	
	-- Log final result
	if dateResult's modDate is not "" or dateResult's creationDate is not "" then
		coLogDebug(handlerName & "(): Final dates for " & contactName & " - Mod: " & dateResult's modDate & ", Created: " & dateResult's creationDate & " (source: " & dateResult's source & ")")
	else
		coLogWarning(handlerName & "(): Could not capture any dates for " & contactName)
	end if
	
	return dateResult
end captureContactDates

-- ==========================================================
-- Handler: parseVCardTimestamp  
-- VERSION: 6.0.0-alpha27+ (2025-01-09)
-- PURPOSE: Convert vCard timestamp format to human-readable date
-- INPUTS:  vcardTimestamp (text) - Raw vCard timestamp (e.g., "20240315T143022Z")
-- RETURNS: text - Formatted date string, or empty string if parsing fails
-- NOTES:   Enhanced to handle multiple vCard timestamp formats
-- ==========================================================
on parseVCardTimestamp(vcardTimestamp)
	try
		-- Remove any whitespace and non-alphanumeric chars except T and Z
		set cleanTimestamp to utilitiesScript's replaceText(vcardTimestamp, " ", "")
		set cleanTimestamp to utilitiesScript's replaceText(cleanTimestamp, tab, "")
		set cleanTimestamp to utilitiesScript's replaceText(cleanTimestamp, return, "")
		set cleanTimestamp to utilitiesScript's replaceText(cleanTimestamp, linefeed, "")
		
		-- Handle different timestamp formats
		-- Format 1: YYYYMMDDTHHMMSSZ (ISO 8601)
		-- Format 2: YYYY-MM-DD HH:MM:SS (already formatted)
		-- Format 3: YYYYMMDD (date only)
		
		-- If already formatted, return as-is
		if cleanTimestamp contains "-" and cleanTimestamp contains ":" then
			return cleanTimestamp
		end if
		
		-- Parse ISO 8601 format: YYYYMMDDTHHMMSSZ
		if (length of cleanTimestamp) ≥ 8 then
			set yearStr to text 1 thru 4 of cleanTimestamp
			set monthStr to text 5 thru 6 of cleanTimestamp
			set dayStr to text 7 thru 8 of cleanTimestamp
			
			-- Check if we have time component
			if cleanTimestamp contains "T" and (length of cleanTimestamp) ≥ 15 then
				set timeStart to (offset of "T" in cleanTimestamp) + 1
				if (timeStart + 5) ≤ (length of cleanTimestamp) then
					set hourStr to text timeStart thru (timeStart + 1) of cleanTimestamp
					set minStr to text (timeStart + 2) thru (timeStart + 3) of cleanTimestamp
					set secStr to text (timeStart + 4) thru (timeStart + 5) of cleanTimestamp
					
					-- Format as readable timestamp
					return yearStr & "-" & monthStr & "-" & dayStr & " " & hourStr & ":" & minStr & ":" & secStr
				end if
			end if
			
			-- Date only format
			return yearStr & "-" & monthStr & "-" & dayStr
		end if
		
		return ""
		
	on error parseErr
		coLogDebug("vCard timestamp parsing error: " & parseErr & " for input: " & vcardTimestamp)
		return ""
	end try
end parseVCardTimestamp

-------------------------------------------------------------------------------
-- Handler: trimLeadingTrailingBlankLines
-- VERSION: 0.9.0-alpha (2025-05-23)
-- PURPOSE:
--   Removes blank lines at the very beginning or end of a note.
--   Ensures output always starts and ends with real content (not blank).
-- INPUT: inputText (text)
-- OUTPUT: outText (text)
-- CHANGELOG:
--   0.9.0-alpha (2025-05-23): Minimal, robust, bulletproof.
-------------------------------------------------------------------------------
on trimLeadingTrailingBlankLines(inputText)
	global utilitiesScript
	set linesList to paragraphs of utilitiesScript's forceText(inputText)
	-- Remove leading blanks
	repeat while ((count of linesList) > 0) and (item 1 of linesList = "")
		set linesList to items 2 thru -1 of linesList
	end repeat
	-- Remove trailing blanks
	repeat while ((count of linesList) > 0) and (item -1 of linesList = "")
		set linesList to items 1 thru -2 of linesList
	end repeat
	set outText to utilitiesScript's joinText(linesList, return)
	return outText
end trimLeadingTrailingBlankLines

-- ===================================================
-- Handler: backupContactNoteWithType
-- VERSION: 0.9.0-alpha2 (2025-05-21)
-- PURPOSE: Save a versioned backup of contact note with pipeline version indicator
-- INPUTS:  aPerson - contact record
--          contactName - name of contact
--          noteText - note content to backup
--          backupType - type of backup (e.g. "note", "processed")
-- RETURNS: path to backup file or empty string if failed
-- ===================================================
on backupContactNoteWithType(aPerson, contactName, noteText, backupType)
	global utilitiesScript
	set safeText to noteText
	
	-- coLogDebug("Backing up note for " & contactName)
	
	try
		set resultRec to utilitiesScript's createVersionedBackup(contactName, safeText, backupType)
	on error errMsg
		coLogWarning("Backup helper error for " & contactName & " (" & "): " & errMsg)
		return ""
	end try
	
	if resultRec's success as boolean then
		-- coLogDebug("Backup (" & ") created at: " & (resultRec's path as text))
		return resultRec's path as string
	else
		coLogWarning("Backup (" & ") failed for " & contactName & ": " & (resultRec's errorMessage as text))
		return ""
	end if
end backupContactNoteWithType

-- ==========================================================
-- TEXT PROCESSING
-- ==========================================================

-- VERSION: 6.0.0-alpha26
-- PURPOSE: Explicitly set forceCleanup mode for next batch run
on setForceCleanupMode(newMode)
	global forceCleanup
	if newMode is missing value or newMode is "" then
		set forceCleanup to defaultForceCleanupMode
	else
		set forceCleanup to newMode
	end if
	coLogDebug("forceCleanup mode set to: " & forceCleanup)
	return true
end setForceCleanupMode


-- ==========================================================
-- CONTACT NOTE FOOTER FUNCTIONS
-- ==========================================================

-- ===================================================
--  extractExistingFooter(noteText) → text
--  VERSION: 6.0.0-alpha25+footerDetect (2025-05-16)
--  PURPOSE: If noteText contains the footer marker, return the footer block
--           (from the marker to the end), else return "".
-- ===================================================
on extractExistingFooter(noteText as text)
	if noteText contains "==== CCC Summary ====" then
		set idx to offset of "==== CCC Summary ====" in noteText
		return text idx thru -1 of noteText
	else
		return ""
	end if
end extractExistingFooter


-- ===================================================
--  parseFooterLine(footerText, label) → text
--
--  Finds the first line in footerText that begins with `label`
--  (including the trailing colon) and returns the remainder of that line.
--  If not found, returns empty string.
-- ===================================================
on parseFooterLine(footerText as text, label as text)
	repeat with l in paragraphs of footerText
		if l starts with label then
			-- skip the label + following space
			return text ((length of label) + 2) thru -1 of l
		end if
	end repeat
	return ""
end parseFooterLine

-- ===================================================
--  hasCCCFooter(noteText) → boolean
--  VERSION: 6.0.0-alpha25+footerDetect (2025-05-16)
--  PURPOSE: Return true if the note already ends with a CCC Footer—
--           i.e. contains the exact marker "==== CCC Summary ====".
-- ===================================================
on hasCCCFooter(noteText as text)
	return noteText contains "==== CCC Summary ===="
end hasCCCFooter

-- ===================================================
-- Handler: updateCCCFooter
-- VERSION: 6.0.0-alpha5 (2025-06-10)
-- PURPOSE: Builds a fresh CCC Summary footer with enhanced date formatting that:
--          • Preserves historical "CCC cleaned on:" entries for tracking
--          • Shows contact dates only on first processing (when no prevMod exists)
--          • Records new "CCC cleaned on:" date if content was modified
--          • Always updates "Last checked:" with current timestamp
--          • Uses human-readable date format throughout
--          • Uses shared utilities for consistent percentage calculations
-- INPUTS:  noteContent (text) - The note content with potential existing footer
--          charsRemoved (integer) - Number of characters removed in this pass
--          originalLength (integer) - Original content length before processing
--          wasModified (boolean) - Whether content was actually changed
--          contactDates (record) - {modDate:text, creationDate:text, source:text}
-- RETURNS: text - Complete note content with updated CCC footer
-- NOTES:   Uses utilities shared handlers for consistent formatting and calculations
--          Preserves all historical tracking and conditional logic
-- DEPENDENCIES: parseFooterLine(), extractExistingFooter() (local)
--               utilitiesScript's joinText(), formatDateHumanReadable(), 
--               convertSystemDateToHuman(), computeReductionMetrics() (utilities module)
-- ===================================================

on updateCCCFooter(noteContent as text, charsRemoved as integer, originalLength as integer, wasModified as boolean, contactDates)
	-- Extract and analyze existing footer for historical data
	set oldFooter to my extractExistingFooter(noteContent)
	
	-- Determine prior modification date and removals (PRESERVE HISTORY)
	set prevMod to my parseFooterLine(oldFooter, "CCC cleaned on:")
	if prevMod is "" then set prevMod to my parseFooterLine(oldFooter, "Modified by CCC:")
	set prevRemovals to my parseFooterLine(oldFooter, "Characters removed:")
	
	-- **FIXED: Parse and preserve contact dates from existing footer**
	set existingContactCreated to my parseFooterLine(oldFooter, "Contact created:")
	set existingContactMod to my parseFooterLine(oldFooter, "Last modification before CCC:")
	
	-- Strip existing footer from the body content
	if oldFooter ≠ "" then
		set bodyText to text 1 thru ((offset of oldFooter in noteContent) - 1) of noteContent
	else
		set bodyText to noteContent
	end if
	
	-- Clean up trailing blank lines from body content
	repeat while bodyText ends with return or bodyText ends with linefeed
		if length of bodyText > 1 then
			set bodyText to text 1 thru -2 of bodyText
		else
			exit repeat
		end if
	end repeat
	
	-- Build new footer lines, always start with standard header
	set newFooterLines to {"==== CCC Summary ===="}
	
	-- Always show contact dates (from existing footer OR contact record)
	-- Priority: existing footer first, then contact record, then nothing
	if existingContactCreated ≠ "" then
		-- Use date from existing footer (already formatted)
		copy ("Contact created: " & existingContactCreated) to end of newFooterLines
	else if contactDates's creationDate is not "" then
		-- Use date from contact record (format it)
		set humanCreationDate to (contactDates's creationDate as text)
		copy ("Contact created: " & humanCreationDate) to end of newFooterLines
	end if
	
	if existingContactMod ≠ "" then
		-- Use date from existing footer (already formatted)
		copy ("Last modification before CCC: " & existingContactMod) to end of newFooterLines
	else if contactDates's modDate is not "" then
		-- Use date from contact record (format it)
		set humanModDate to (contactDates's modDate as text)
		copy ("Last modification before CCC: " & humanModDate) to end of newFooterLines
	end if
	
	-- Record this processing run if content was actually modified
	if wasModified then
		set nowStamp to ((current date) as text)
		copy ("CCC cleaned on: " & nowStamp) to end of newFooterLines
		
		-- Use shared utilities function for consistent percentage calculation
		if originalLength > 0 then
			set reductionMetrics to utilitiesScript's computeReductionMetrics(charsRemoved, originalLength)
			set formattedPct to (round ((reductionMetrics's pct) * 10)) / 10
			copy ("Characters removed: " & charsRemoved & " (" & formattedPct & "% reduction)") to end of newFooterLines
		else
			copy ("Characters removed: " & charsRemoved) to end of newFooterLines
		end if
	else
		-- Only add "Last checked" if not cleaned today
		set todayDateString to (date string of (current date))
		set shouldAddLastChecked to true
		
		if prevMod ≠ "" then
			-- Check if already cleaned today
			if prevMod contains todayDateString then
				set shouldAddLastChecked to false
			end if
		end if
		
		if shouldAddLastChecked then
			set nowStamp to ((current date) as text)
			copy ("Last checked: " & nowStamp) to end of newFooterLines
		end if
	end if
	
	-- Assemble footer block using utilities shared handler
	set footerBody to utilitiesScript's joinText(newFooterLines, return)
	
	-- Ensure exactly one blank line before footer and trailing linefeed
	set footerBlock to return & return & footerBody & return
	
	return bodyText & footerBlock
end updateCCCFooter

-- ==========================================================
-- GROUP TAG MANAGEMENT (Under development. Plan a session for this)
-- ==========================================================

on processGroupTags(theContact)
	-- Validate input
	if theContact is missing value then
		coLogWarning("Invalid contact (missing value) passed to processGroupTags")
		return {success:false, modified:false, reason:"Invalid contact object"}
	end if
	
	coLogInfo("Group tag processing requested for contact")
	
	-- Get contact name for better logging
	try
		tell application "Contacts"
			set contactName to name of theContact
			coLogDebug("Processing group tags for: " & contactName)
		end tell
	on error nameErr
		set contactName to "Unknown"
		coLogWarning("Could not get contact name: " & nameErr)
	end try
	
	-- This will be implemented in Session 3
	coLogInfo("Group tag processing feature will be implemented in the next version")
	
	-- For now, return success but no modification
	return {success:true, modified:false, reason:"Group tag processing not yet implemented"}
end processGroupTags

-- =============================================================================
-- Handler: extractGroupsAsTagLine
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Build sentinel line from the list of groups the person belongs to
-- INPUTS:  aPerson - contact reference
-- RETURNS: text - formatted group tag line or empty string
-- NOTES:   Groups are sorted alphabetically for consistency
-- =============================================================================
on extractGroupsAsTagLine(aPerson)
	global utilitiesScript
	set handlerName to "extractGroupsAsTagLine"
	
	try
		set groupNames to {}
		
		tell application "Contacts"
			-- Get all groups this person belongs to
			set allGroups to every group
			
			repeat with aGroup in allGroups
				try
					-- Check if person is in this group
					if aPerson is in people of aGroup then
						set groupName to name of aGroup
						-- Escape pipe characters in group names
						set escapedName to my escapeGroupName(groupName)
						set end of groupNames to escapedName
					end if
				on error groupErr
					-- Skip this group if we can't check membership
					utilitiesScript's moduleLogDebug("ContactOps", handlerName & " - Error checking group: " & groupErr)
				end try
			end repeat
		end tell
		
		-- Build the tag line if groups exist
		if (count of groupNames) > 0 then
			-- Sort groups alphabetically for consistency
			set sortedGroups to utilitiesScript's sortList(groupNames)
			set groupsText to utilitiesScript's joinText(sortedGroups, GROUP_SEPARATOR)
			set tagLine to GROUP_TAG_PREFIX & groupsText & GROUP_TAG_SUFFIX
			
			utilitiesScript's moduleLogDebug("ContactOps", handlerName & " - Created tag line with " & (count of groupNames) & " groups")
			return tagLine
		else
			return ""
		end if
		
	on error errMsg
		utilitiesScript's moduleLogError("ContactOps", handlerName & " error: " & errMsg)
		return ""
	end try
end extractGroupsAsTagLine

-- =============================================================================
-- Unit Test: testExtractGroupsAsTagLine
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Test extraction of groups to tag line format
-- =============================================================================
on testExtractGroupsAsTagLine()
	set testResults to {}
	
	-- Test 1: Contact with no groups
	try
		tell application "Contacts"
			-- Create test contact
			set testPerson to make new person with properties {first name:"Test", last name:"NoGroups"}
			
			-- Test extraction
			set result to my extractGroupsAsTagLine(testPerson)
			
			if result = "" then
				set end of testResults to {test:"No groups", passed:true}
			else
				set end of testResults to {test:"No groups", passed:false, got:result}
			end if
			
			-- Cleanup
			delete testPerson
		end tell
	on error errMsg
		set end of testResults to {test:"No groups", passed:false, theError:errMsg}
	end try
	
	-- Test 2: Contact with multiple groups
	try
		tell application "Contacts"
			-- Create test groups
			set group1 to make new group with properties {name:"Test Group A"}
			set group2 to make new group with properties {name:"Test Group B"}
			
			-- Create test contact and add to groups
			set testPerson to make new person with properties {first name:"Test", last name:"MultiGroups"}
			add testPerson to group1
			add testPerson to group2
			
			-- Test extraction
			set result to my extractGroupsAsTagLine(testPerson)
			set expectedResult to ":::groups: Test Group A | Test Group B :::"
			
			if result = expectedResult then
				set end of testResults to {test:"Multiple groups", passed:true}
			else
				set end of testResults to {test:"Multiple groups", passed:false, expected:expectedResult, got:result}
			end if
			
			-- Cleanup
			delete testPerson
			delete group1
			delete group2
		end tell
	on error errMsg
		set end of testResults to {test:"Multiple groups", passed:false, theError:errMsg}
	end try
	
	-- Test 3: Group with pipe character
	try
		tell application "Contacts"
			-- Create group with pipe
			set groupWithPipe to make new group with properties {name:"Test | Pipe"}
			
			-- Create test contact
			set testPerson to make new person with properties {first name:"Test", last name:"PipeGroup"}
			add testPerson to groupWithPipe
			
			-- Test extraction
			set result to my extractGroupsAsTagLine(testPerson)
			set expectedResult to ":::groups: Test \\| Pipe :::"
			
			if result = expectedResult then
				set end of testResults to {test:"Group with pipe", passed:true}
			else
				set end of testResults to {test:"Group with pipe", passed:false, expected:expectedResult, got:result}
			end if
			
			-- Cleanup
			delete testPerson
			delete groupWithPipe
		end tell
	on error errMsg
		set end of testResults to {test:"Group with pipe", passed:false, theError:errMsg}
	end try
	
	return testResults
end testExtractGroupsAsTagLine

-- =============================================================================
-- Handler: parseGroupsFromTagLine
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Extract group names from a tag line
-- INPUTS:  tagLine - the formatted group tag line
-- RETURNS: list - unescaped group names
-- =============================================================================
on parseGroupsFromTagLine(tagLine)
	global utilitiesScript
	set handlerName to "parseGroupsFromTagLine"
	
	try
		-- Validate input
		if tagLine is "" or not (tagLine starts with GROUP_TAG_PREFIX and tagLine ends with GROUP_TAG_SUFFIX) then
			return {}
		end if
		
		-- Remove prefix and suffix
		set startIdx to (length of GROUP_TAG_PREFIX) + 1
		set endIdx to (length of tagLine) - (length of GROUP_TAG_SUFFIX)
		set groupsText to text startIdx thru endIdx of tagLine
		
		-- Split by separator and unescape names
		set groupNames to utilitiesScript's splitText(groupsText, GROUP_SEPARATOR)
		set unescapedNames to {}
		
		repeat with groupName in groupNames
			set trimmedName to utilitiesScript's trimWhitespace(groupName)
			if trimmedName ≠ "" then
				set unescapedName to my unescapeGroupName(trimmedName)
				set end of unescapedNames to unescapedName
			end if
		end repeat
		
		return unescapedNames
		
	on error errMsg
		my coLogError(handlerName & " error: " & errMsg)
		return {}
	end try
end parseGroupsFromTagLine

-- =============================================================================
-- Unit Test: testParseGroupsFromTagLine
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Test parsing of tag lines to group names
-- =============================================================================
on testParseGroupsFromTagLine()
	set testResults to {}
	
	-- Test 1: Empty tag line
	set parsed to my parseGroupsFromTagLine("")
	if (count of parsed) = 0 then
		set end of testResults to {test:"Empty tag line", passed:true}
	else
		set end of testResults to {test:"Empty tag line", passed:false, got:parsed}
	end if
	
	-- Test 2: Single group
	set parsed to my parseGroupsFromTagLine(":::groups: Friends :::")
	if (count of parsed) = 1 and item 1 of parsed = "Friends" then
		set end of testResults to {test:"Single group", passed:true}
	else
		set end of testResults to {test:"Single group", passed:false, got:parsed}
	end if
	
	-- Test 3: Multiple groups
	set parsed to my parseGroupsFromTagLine(":::groups: Friends | Family | Work :::")
	if (count of parsed) = 3 and item 1 of parsed = "Friends" and item 2 of parsed = "Family" and item 3 of parsed = "Work" then
		set end of testResults to {test:"Multiple groups", passed:true}
	else
		set end of testResults to {test:"Multiple groups", passed:false, got:parsed}
	end if
	
	-- Test 4: Group with escaped pipe
	set parsed to my parseGroupsFromTagLine(":::groups: Test \\| Pipe | Normal :::")
	if (count of parsed) = 2 and item 1 of parsed = "Test | Pipe" and item 2 of parsed = "Normal" then
		set end of testResults to {test:"Escaped pipe", passed:true}
	else
		set end of testResults to {test:"Escaped pipe", passed:false, got:parsed}
	end if
	
	-- Test 5: Invalid format
	set parsed to my parseGroupsFromTagLine("Not a tag line")
	if (count of parsed) = 0 then
		set end of testResults to {test:"Invalid format", passed:true}
	else
		set end of testResults to {test:"Invalid format", passed:false, got:parsed}
	end if
	
	return testResults
end testParseGroupsFromTagLine

-- =============================================================================
-- Handler: escapeGroupName
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Escape pipe characters in group names
-- INPUTS:  groupName - the group name to escape
-- RETURNS: text - escaped group name
-- =============================================================================
on escapeGroupName(groupName)
	-- First escape any existing backslashes
	set ASTID to AppleScript's text item delimiters
	set AppleScript's text item delimiters to "\\"
	set nameParts to text items of groupName
	set AppleScript's text item delimiters to "\\\\"
	set escapedName to nameParts as text
	
	-- Then escape pipes
	set AppleScript's text item delimiters to "|"
	set nameParts to text items of escapedName
	set AppleScript's text item delimiters to "\\|"
	set escapedName to nameParts as text
	
	set AppleScript's text item delimiters to ASTID
	return escapedName
end escapeGroupName

-- =============================================================================
-- Handler: unescapeGroupName
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Unescape pipe characters in group names
-- INPUTS:  groupName - the escaped group name
-- RETURNS: text - unescaped group name
-- =============================================================================
on unescapeGroupName(groupName)
	-- First unescape pipes
	set ASTID to AppleScript's text item delimiters
	set AppleScript's text item delimiters to "\\|"
	set nameParts to text items of groupName
	set AppleScript's text item delimiters to "|"
	set unescapedName to nameParts as text
	
	-- Then unescape backslashes
	set AppleScript's text item delimiters to "\\\\"
	set nameParts to text items of unescapedName
	set AppleScript's text item delimiters to "\\"
	set unescapedName to nameParts as text
	
	set AppleScript's text item delimiters to ASTID
	return unescapedName
end unescapeGroupName

-- =============================================================================
-- Handler: extractGroupTagLineFromNote
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Find existing tag line in note
-- INPUTS:  noteText - the contact note text
-- RETURNS: text - the tag line if found, empty string otherwise
-- =============================================================================
on extractGroupTagLineFromNote(noteText)
	global utilitiesScript
	set handlerName to "extractGroupTagLineFromNote"
	
	try
		if noteText is "" then return ""
		
		-- Split into lines
		set ASTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to linefeed
		set noteLines to text items of noteText
		set AppleScript's text item delimiters to ASTID
		
		-- Search for tag line
		repeat with aLine in noteLines
			set trimmedLine to utilitiesScript's trimWhitespace(aLine)
			if trimmedLine starts with GROUP_TAG_PREFIX and trimmedLine ends with GROUP_TAG_SUFFIX then
				utilitiesScript's moduleLogDebug("ContactOps", handlerName & " - Found existing tag line")
				return trimmedLine
			end if
		end repeat
		
		return ""
		
	on error errMsg
		utilitiesScript's moduleLogError("ContactOps", handlerName & " error: " & errMsg)
		return ""
	end try
end extractGroupTagLineFromNote

--===
-- STATISTICS
--===

-- ============================================
-- Handler: loadCumulativeStats  ❬PATCHED 2025‑07‑07❭
-- VERSION: 2.5.0 – single‑path reader (base CCC folder)
-- PURPOSE: Load cumulative statistics text from the persistent CCC Script
--          folder, strip comment/header lines, and return the cleaned result
--          for display. No session‑path fallback; statistics are now stored
--          and read exclusively from the base folder.
-- DEPENDS: utilitiesScript's getBaseCCCFolder, readTextFile,
--          splitText, filterLinesStartingWith, joinText
--          Contact‑Operations logging wrappers: coLogInfo, coLogWarning
-- RETURNS: text – cleaned statistics, or explanatory string if none found.
-- ============================================

on loadCumulativeStats()
	global utilitiesScript
	set handlerName to "loadCumulativeStats"
	coLogInfo(handlerName & " – loading cumulative‑stats text…")
	
	-- Build canonical path: <Documents>/CCC Script/ccc_stats.txt
	set statsPath to (utilitiesScript's getBaseCCCFolder()) & "ccc_stats.txt"
	
	-- Attempt to read file via Utilities wrapper
	set res to utilitiesScript's readTextFile(statsPath)
	if (class of res is not record) or (res's success is false) then
		set msg to "No cumulative statistics found yet."
		coLogWarning(handlerName & " – " & msg)
		return msg
	end if
	
	set rawText to res's text
	
	-- Strip header / comment / blank lines using Utilities helpers
	set linesList to utilitiesScript's splitText(rawText, return)
	set dataLines to utilitiesScript's filterLinesStartingWith(linesList, {"--", "#", ""})
	set cleanedText to utilitiesScript's joinText(dataLines, return)
	
	coLogInfo(handlerName & " – cleaned statistics ready (" & (count dataLines) & " lines)")
	return cleanedText
end loadCumulativeStats

-- ============================================
-- Handler: saveCumulativeStats  (ROBUST I/O + RICH HEADER) – PATCH 1.2.1
-- MODULE : ContactOperations
-- AUTHOR : Claude – AppleScript Project
-- PURPOSE: Persist cumulative optimisation statistics **reliably**.
--          ✱ PATCH 1.2.1: replaced stale variable `stats` with correct
--          parameter `statsRec`; no other logic changes.
-- RETURNS: Boolean – true if at least one target file is written.
-- ============================================
on saveCumulativeStats(statsRec, includeSessionCopy)
	if includeSessionCopy is missing value then set includeSessionCopy to true
	
	coLogInfo("Saving cumulative statistics to file(s)")
	if statsRec is missing value then
		coLogError("Cannot save statistics: stats record is missing value")
		return false
	end if
	
	----------------------------------------------------------------------
	-- 1 · Build header + key : value block
	----------------------------------------------------------------------
	try
		set currentTimestamp to utilitiesScript's getISOTimestamp(current date)
		set statsContent to "# Contact Management System – Cumulative Statistics" & return & ¬
			"# Auto-generated – do not edit" & return & ¬
			"# =============================================" & return & return & ¬
			"Contacts optimised: " & (statsRec's totalContacts) & return & ¬
			"Characters removed (total): " & (statsRec's totalChars) & return & ¬
			"Data saved: " & ((round ((statsRec's totalKB) * 100)) / 100) & " KB" & return & ¬
			"Average / contact: " & (round ((statsRec's avgCharsPerContact) * 10) / 10) & return & ¬
			"Average % saved: " & (round ((statsRec's percentSaved) * 10) / 10) & " %" & return & return & ¬
			"# Last rebuild: " & currentTimestamp & return & ¬
			"systemVersion:" & scriptVersion & return
	on error fmtErr
		coLogError("Error building stats text: " & fmtErr)
		return false
	end try
	
	----------------------------------------------------------------------
	-- 2 · Resolve target paths
	----------------------------------------------------------------------
	set baseFolder to (path to documents folder as string) & "CCC Script:"
	set targetPaths to {baseFolder & "ccc_stats.txt"}
	global sessionFolder
	if includeSessionCopy and sessionFolder is not missing value and sessionFolder ≠ "" then ¬
		set end of targetPaths to sessionFolder & "ccc_stats.txt"
	
	----------------------------------------------------------------------
	-- 3 · Ensure folders exist
	----------------------------------------------------------------------
	if (utilitiesScript's createFolderPath(baseFolder)) is false then
		coLogError("❌ Cannot create stats folder: " & baseFolder)
		return false
	end if
	if includeSessionCopy and sessionFolder ≠ "" then ¬
		utilitiesScript's createFolderPath(sessionFolder)
	
	----------------------------------------------------------------------
	-- 4 · Write files via Utilities.saveTextToFile
	----------------------------------------------------------------------
	set saveSuccessful to false
	repeat with p in targetPaths
		set rec to utilitiesScript's saveTextToFile(statsContent, p)
		if (class of rec is record) then
			if rec's success then
				coLogInfo("✅ Statistics saved to: " & (rec's path))
				set saveSuccessful to true
			else
				coLogWarning("saveTextToFile failed for: " & (rec's path))
			end if
		else if rec then
			coLogInfo("✅ Statistics saved to: " & p)
			set saveSuccessful to true
		else
			coLogWarning("saveTextToFile returned false for: " & p)
		end if
	end repeat
	
	if saveSuccessful then
		coLogInfo("Statistics save operation completed successfully")
		return true
	else
		coLogError("❌ All statistics save attempts failed")
		return false
	end if
end saveCumulativeStats

-- ============================================
-- Handler: updateCumulativeStats – FIXED VERSION
-- VERSION: 2.0.1 – removed call to splitText; uses existing splitText
-- PURPOSE: Merge session statistics gathered during the current cleanup session
--          into the persistent cumulative counters stored in «ccc_stats.txt».
-- LOCATION: ContactOperations module
-- DEPENDS:  utilitiesScript → readTextFile(), saveTextToFile(),
--           statsTextToRecord(), statsRecordToText()
-- RETURNS:  boolean – true   ⇢ merge & save OK
--                     false  ⇢ nothing written (error already logged)
-- ============================================

on updateCumulativeStats(sessionStats)
	global utilitiesScript
	set handlerName to "updateCumulativeStats"
	
	-- ▸ 0  Sanity check ------------------------------------------------------
	if sessionStats is missing value then
		coLogWarning(handlerName & " – sessionStats record missing; aborting update")
		return false
	end if
	
	-- ▸ 1  Locate cumulative‑stats file -------------------------------------
	set baseFolder to (path to documents folder as string) & "CCC Script:"
	set statsPath to baseFolder & "ccc_stats.txt"
	
	-- ▸ 2  Load existing counters  ------------------------------------------
	set currentText to ""
	try
		set currentText to (utilitiesScript's readTextFile(statsPath))'s text
	end try
	
	set cumulativeRec to utilitiesScript's statsTextToRecord(currentText)
	if cumulativeRec is missing value or cumulativeRec = {} then
		set cumulativeRec to {totalContacts:0, totalChars:0, totalKB:0, avgCharsPerContact:0, percentSaved:0}
	end if
	
	-- ▸ 3  Extract deltas from sessionStats – keys are «processed» & «charsRemoved»
	set sessContacts to 0
	set sessChars to 0
	try
		set sessContacts to sessionStats's processed
	end try
	try
		set sessChars to sessionStats's charsRemoved
	end try
	
	-- Guard: nothing to merge
	if sessContacts = 0 and sessChars = 0 then
		coLogDebug(handlerName & " – no deltas in sessionStats; nothing to merge")
		return true
	end if
	
	-- ▸ 4  Merge ------------------------------------------------------------
	set cumulativeRec's totalContacts to (cumulativeRec's totalContacts) + sessContacts
	set cumulativeRec's totalChars to (cumulativeRec's totalChars) + sessChars
	set cumulativeRec's totalKB to (cumulativeRec's totalChars) / 1024.0
	if cumulativeRec's totalContacts > 0 then
		set cumulativeRec's avgCharsPerContact to (cumulativeRec's totalChars) / (cumulativeRec's totalContacts)
	end if
	
	coLogDebug(handlerName & " – merged +" & sessContacts & " contacts, +" & sessChars & " chars")
	
	-- ▸ 5  Serialise & persist ---------------------------------------------
	set newText to utilitiesScript's statsRecordToText(cumulativeRec, missing value)
	try
		if utilitiesScript's saveTextToFile(newText, statsPath) then
			coLogInfo(handlerName & " – cumulative stats written to " & statsPath)
			return true
		else
			coLogError(handlerName & " – saveTextToFile returned false for " & statsPath)
			return false
		end if
	on error saveErr
		coLogError(handlerName & " – error saving stats: " & saveErr)
		return false
	end try
end updateCumulativeStats

-- ============================================
-- Handler: rebuildCumulativeStats  (v0.9.19‑rich‑progress) – 2025‑07‑07
-- MODULE : ContactOperations
-- AUTHOR : Philippe Dewost ✚ Claude / AppleScript Project
-- PURPOSE: Full statistics rebuild with milestone UI, CNPredicate fast fetch,
--          percent‑saving accumulation, real session performance, and robust
--          error handling.  This file **no longer contains saveCumulativeStats**;
--          that handler lives in its own textdoc (Save Cumulative Stats Fix).
-- ============================================

use framework "Contacts"
property CNContactStore : class "CNContactStore"

on rebuildCumulativeStats()
	set handlerName to "Statistics Rebuild"
	with timeout of 900 seconds -- 15 min safeguard
		------------------------------------------------------------------
		-- 1 ▸ Fetch only contacts that contain a CCC footer (fast path)
		------------------------------------------------------------------
		try
			set store to (current application's CNContactStore's alloc()'s init())
			set keysToFetch to {current application's CNContactNoteKey}
			set pred to current application's NSPredicate's predicateWithFormat_("note CONTAINS %@", "==== CCC Summary ====")
			set allContacts to (store's unifiedContactsMatchingPredicate:pred keysToFetch:keysToFetch |error|:(missing value)) as list
			coLogDebug(handlerName & ": predicate fetched " & (count allContacts) & " candidate contacts")
		on error
			-- Fallback: full enumeration via Contacts.app
			tell application "Contacts" to set allContacts to every person
			coLogDebug(handlerName & ": fallback enumeration – " & (count allContacts) & " contacts")
		end try
		set totalContactCount to count allContacts
		if totalContactCount = 0 then
			coLogWarning(handlerName & ": No contacts found – aborting")
			return {success:false, reason:"No contacts"}
		end if
		
		------------------------------------------------------------------
		-- 2 ▸ Init accumulators & timers
		------------------------------------------------------------------
		set {cccContactsFound, totalCharsSaved, totalPctSaved} to {0, 0, 0}
		set startTime to current date
		
		------------------------------------------------------------------
		-- 3 ▸ Main loop
		------------------------------------------------------------------
		repeat with c in allContacts
			set contactNote to ""
			try
				set contactNote to (c's |note|()) as text
			on error
				-- legacy person object fallback
				try
					tell application "Contacts" to set contactNote to note of c
				end try
			end try
			if contactNote is missing value then set contactNote to ""
			
			if contactNote contains "==== CCC Summary ====" then
				set cccContactsFound to cccContactsFound + 1
				set summaryParsed to false
				
				-- 3·a ▸ Friendly contact name ----------------------------------
				set contactName to ""
				try
					-- CNContact path
					set contactName to ((c's |givenName|()) & " " & (c's |familyName|())) as text
				on error
					-- legacy person object path
					try
						tell application "Contacts" to set contactName to name of c
					end try
				end try
				if contactName is "" then set contactName to "<unknown>"
				
				-- 3·b ▸ Parse footer and accumulate ---------------------------
				set footerStart to (offset of "==== CCC Summary ====" in contactNote)
				set footerText to text footerStart thru -1 of contactNote
				if footerText contains "Characters removed:" then
					repeat with ln in paragraphs of footerText
						set lineText to ln as text
						if lineText starts with "Characters removed:" then
							set parseRec to parseCCCCharactersSummaryLine(text 20 thru -1 of lineText, utilitiesScript)
							set removedChars to parseRec's removedChars
							set pctVal to parseRec's percentVal
							set totalCharsSaved to totalCharsSaved + removedChars
							set totalPctSaved to totalPctSaved + pctVal
							set summaryParsed to true
							exit repeat
						end if
					end repeat
				end if
				
				-- 3·c ▸ Debug log ---------------------------------------------
				if summaryParsed then
					coLogDebug(handlerName & ": " & contactName & "  chars=" & removedChars & "  pct=" & pctVal)
				else
					coLogDebug(handlerName & ": " & contactName & "  – no char data")
				end if
			end if
		end repeat
		
		------------------------------------------------------------------
		-- 4 ▸ Finalise stats record
		------------------------------------------------------------------
		set elapsedSeconds to (current date) - startTime
		if elapsedSeconds < 1 then set elapsedSeconds to 1 -- avoid divide‑by‑zero
		set statsRec to {totalContacts:cccContactsFound, totalChars:totalCharsSaved, totalKB:(totalCharsSaved / 1024), avgCharsPerContact:(totalCharsSaved / cccContactsFound), percentSaved:(totalPctSaved / cccContactsFound), sessionPerformance:(totalContactCount / elapsedSeconds)}
		
		------------------------------------------------------------------
		-- 5 ▸ Persist stats
		------------------------------------------------------------------
		set saveOK to my saveCumulativeStats(statsRec, true)
		if saveOK then
			coLogInfo(handlerName & ": ✅ Statistics rebuild completed: " & cccContactsFound & " CCC contacts, " & totalCharsSaved & " chars saved in " & (round elapsedSeconds) & "s")
			return {success:true, scannedContacts:totalContactCount, cccContacts:cccContactsFound, errors:0, errorContacts:{}, processingTime:elapsedSeconds, stats:statsRec}
		else
			coLogError(handlerName & ": Failed to save statistics")
			return {success:false, reason:"Failed to save", scannedContacts:totalContactCount, cccContacts:cccContactsFound, errors:0, errorContacts:{}, processingTime:elapsedSeconds}
		end if
	end timeout
end rebuildCumulativeStats

-- ============================================
-- Helper ▸ fetchCCCContactsPredicate – Contacts.framework predicate with fallback
-- ============================================
on fetchCCCContactsPredicate()
	try
		set store to (current application's CNContactStore's alloc()'s init())
		set keysToFetch to {current application's CNContactNoteKey}
		set predicate to current application's NSPredicate's predicateWithFormat_("note CONTAINS %@", "==== CCC Summary ====")
		set cocoalist to store's unifiedContactsMatchingPredicate:predicate keysToFetch:keysToFetch |error|:(missing value)
		return cocoalist as list
	on error errMsg
		error errMsg
	end try
end fetchCCCContactsPredicate

-- ============================================
-- Handler: parseCCCCharactersSummaryLine
-- VERSION: 1.0.0 (2025‑07‑05)
-- AUTHOR: Claude / AppleScript Expert
-- PURPOSE:  Robustly extract the characters‑removed **and** percent‑saving values
--           from a CCC footer summary line such as:
--              "167 (0,16 KB, 2,41% reduction)"
--           The original implementation fed the whole parenthesis content
--           (including the size fragment “0,16 KB,”) to parseLocaleNumber, which
--           caused repeated parse failures.  This handler cleans the string
--           before numeric coercion, so **parseLocaleNumber stays untouched**.
-- INPUTS:   ▸ summaryLine (text) – the part after “Characters removed: ”
--           ▸ utilitiesScript – reference to the Utilities script (for helpers)
-- RETURNS:  record {removedChars:integer, percentVal:real}
-- DEPENDENCIES: utilitiesScript's trimWhitespace(), parseLocaleNumber()
-- SIDE‑EFFECTS: none
-- CHANGELOG:
--   • 1.0.0 – first extraction as standalone helper (was inline in Statistics
--             Rebuild loop). Implements comma‑aware splitting to ignore the
--             “KB” token.
-- ============================================
on parseCCCCharactersSummaryLine(summaryLine as text, utilitiesScript)
	-- Default results
	set removedChars to 0
	set percentVal to 0
	
	---------------------------------------------------------------------------
	-- 1 ▸ Characters removed  (text *before* the opening parenthesis)
	---------------------------------------------------------------------------
	try
		if summaryLine contains "(" then
			set parenPos to offset of "(" in summaryLine
			set numberPart to text 1 thru (parenPos - 1) of summaryLine
		else
			set numberPart to summaryLine -- fallback, should not happen
		end if
		set numberPart to utilitiesScript's trimWhitespace(numberPart)
		set removedChars to utilitiesScript's parseLocaleNumber(numberPart)
	on error
		-- soft‑fail: keep 0
	end try
	
	---------------------------------------------------------------------------
	-- 2 ▸ Percent saving  (last numeric token *inside* the parenthesis)
	---------------------------------------------------------------------------
	try
		if summaryLine contains "%" then
			-- Grab the inside of the first pair of parentheses
			set pStart to (offset of "(" in summaryLine) + 1
			set pEnd to (offset of "%" in summaryLine) - 1
			if pEnd > pStart then
				set innerText to text pStart thru pEnd of summaryLine -- "0,16 KB, 2,41"
				
				-- Keep only the bit **after** the last comma (locale‑safe)
				set ASTID to AppleScript's text item delimiters
				set AppleScript's text item delimiters to ","
				set tokens to text items of innerText
				set AppleScript's text item delimiters to ASTID
				set rawPercent to item -1 of tokens -- e.g. " 2,41"
				set rawPercent to utilitiesScript's trimWhitespace(rawPercent)
				set percentVal to utilitiesScript's parseLocaleNumber(rawPercent)
			end if
		end if
	end try
	
	return {removedChars:removedChars, percentVal:percentVal}
end parseCCCCharactersSummaryLine

-- Generate formatted statistics report with error handling
on getCumulativeStatsReport()
	coLogInfo("Generating cumulative statistics report")
	
	-- Load current stats with error handling
	try
		coLogDebug("Loading current statistics")
		set stats to my loadCumulativeStats()
		
		-- Format KB and average for display
		set kbFormatted to (round ((stats's totalChars) / 1024 * 100)) / 100
		set avgFormatted to (round ((stats's avgCharsPerContact) * 10)) / 10
		
		coLogDebug("Formatted values: " & kbFormatted & " KB, " & avgFormatted & " avg chars")
		
		-- Create the report
		set reportText to "📊 Cumulative Statistics:" & return & return
		set reportText to reportText & "• Total contacts optimized: " & stats's totalContacts & return
		set reportText to reportText & "• Total characters saved: " & stats's totalChars & " (" & kbFormatted & " KB)" & return
		set reportText to reportText & "• Average savings: " & avgFormatted & " characters per contact"
		
		-- Add percentage saved information if available
		if stats contains "percentSaved" and stats's percentSaved > 0 then
			set percentFormatted to (round ((stats's percentSaved) * 10)) / 10
			set reportText to reportText & return & "• Percentage of text saved: " & percentFormatted & "%"
			coLogDebug("Added percentage saved: " & percentFormatted & "%")
		else
			coLogDebug("No percentage saved data available")
		end if
		
		coLogDebug("Statistics report generated successfully")
		return reportText
	on error errMsg
		coLogError("Error generating statistics report: " & errMsg)
		
		-- Create a fallback report indicating the error
		set fallbackReport to "📊 Cumulative Statistics:" & return & return
		set fallbackReport to fallbackReport & "• Error loading statistics: " & errMsg & return
		set fallbackReport to fallbackReport & "• Try rebuilding statistics from the Statistics Management menu"
		
		return fallbackReport
	end try
end getCumulativeStatsReport

-- Track processed contacts to prevent double-counting in statistics
on hasBeenProcessedInSession(contactName)
	-- Access the global list with error protection
	try
		global processedContactsList
		
		-- Validate input
		if contactName is "" or contactName is missing value then
			coLogWarning("Invalid contact name passed to hasBeenProcessedInSession")
			return false
		end if
		
		coLogDebug("Checking if contact has been processed: " & contactName)
		
		-- Defensive initialization if somehow still undefined
		if processedContactsList is missing value then
			set processedContactsList to {}
			coLogWarning("processedContactsList was undefined - re-initialized")
		end if
		
		-- Check if contact is in the list
		set contactFound to false
		repeat with processedContact in processedContactsList
			if processedContact is contactName then
				coLogDebug("Contact already processed in this session: " & contactName)
				set contactFound to true
				exit repeat
			end if
		end repeat
		
		-- If not found, add to the list
		if not contactFound then
			try
				set end of processedContactsList to contactName
				coLogDebug("Added " & contactName & " to processedContactsList")
			on error addErr
				coLogError("Error adding contact to processedContactsList: " & addErr)
			end try
			return false
		end if
		
		-- If found, return true
		return true
		
	on error processErr
		-- Failsafe: if anything goes wrong, assume contact wasn't processed
		coLogError("Error in hasBeenProcessedInSession: " & processErr)
		return false
	end try
end hasBeenProcessedInSession

-- ======
-- PERFORMANCE TRACKING SYSTEM (June 25th 2025)
-- Utilities' PTS learns from CCC sessions to establish and update user system's performance profile
-- Estimates average processing time for both simulation and real mode
-- Establishes a history of all contacts processed over time and the performance evolution and averages
-- Uses these estimations for large batches processing
-- ======


-- ====
-- GENERIC HELPERS
-- ====

-- ============================================
-- Handler: formatProcessingRate
-- VERSION: 1.0.0 (2025-06-25)
-- PURPOSE: Smart rate display - contacts/s for fast, s/contact for slow processing
-- INPUTS:  contactsProcessed (integer), elapsedTime (real)
-- RETURNS: text - formatted rate string
-- RULE:    If rate >= 1.0 show "contacts/s", else show "s/contact"
-- ============================================
on formatProcessingRate(contactsProcessed, elapsedTime)
	try
		if elapsedTime ≤ 0 or contactsProcessed ≤ 0 then
			return "calculating..."
		end if
		
		set rate to contactsProcessed / elapsedTime
		
		if rate ≥ 1.0 then
			-- Fast processing: show contacts/second
			set rateDisplay to (round (rate * 10)) / 10
			if rateDisplay = (rateDisplay as integer) then
				return (rateDisplay as integer) & " contacts/s"
			else
				return rateDisplay & " contacts/s"
			end if
		else
			-- Slow processing: show seconds/contact
			set timePerContact to elapsedTime / contactsProcessed
			set timeDisplay to (round (timePerContact * 100)) / 100
			if timeDisplay = (timeDisplay as integer) then
				return (timeDisplay as integer) & " s/contact"
			else
				return timeDisplay & " s/contact"
			end if
		end if
		
	on error rateErr
		return "rate unknown"
	end try
end formatProcessingRate

-------------------------------------------------------------------------------
--  formatDateCompact(theDate)                    ▸  PRIVATE
--  Returns "YYYY‑MM‑DD HH:MM:SS" (zero‑padded).
--  AppleScript 2.4‑compatible and side‑effect‑free.
-------------------------------------------------------------------------------
on formatDateCompact(theDate)
	if theDate is missing value then set theDate to (current date)
	
	set y to year of theDate as integer
	set m to (month of theDate as integer)
	set d to day of theDate
	set hh to hours of theDate
	set mm to minutes of theDate -- ✅ fixed: minutes, not “min”
	set ss to seconds of theDate
	
	repeat with n in {m, d, hh, mm, ss}
		if (n as integer) < 10 then set contents of n to "0" & n
	end repeat
	
	return (y & "-" & m & "-" & d & " " & hh & ":" & mm & ":" & ss) as text
end formatDateCompact

-- ===================================================
--  generateSkipReport(skippedContacts) → text
--
--  When no contacts needed cleaning, builds a short report listing each
--  skipped contact and the date they were last checked (from their CCC footer).
-- ===================================================
on generateSkipReport(skippedContacts)
	set reportLines to {"No contacts needed cleaning."}
	repeat with c in skippedContacts
		-- safely get note text
		tell application "Contacts"
			try
				set noteText to note of c
			on error
				set noteText to ""
			end try
			set contactName to name of c
		end tell
		
		-- extract and parse last-checked date
		set footer to extractExistingFooter(noteText)
		set lastChecked to parseFooterLine(footer, "Last checked:")
		if lastChecked is "" then set lastChecked to "(no check date found)"
		
		copy ("• " & contactName & " was last checked on " & lastChecked) to end of reportLines
	end repeat
	
	return reportLines as text
end generateSkipReport

-- ==========================================================
-- MODULE INFORMATION
-- Provide diagnostic information about the module
on getModuleInfo()
	coLogDebug("Retrieving module information")
	
	-- Access needed global variables
	global MODULE_NAME, scriptVersion
	
	-- Make sure MODULE_NAME is defined
	if MODULE_NAME is missing value then
		set MODULE_NAME to "ContactOperations"
		coLogWarning("MODULE_NAME was missing value, using default")
	end if
	
	set functionCount to 26 -- Updated after removing deprecated functions
	
	-- Create and return module info record
	set moduleInfo to {name:MODULE_NAME, version:scriptVersion, functions:functionCount}
	
	coLogInfo("Module information: " & MODULE_NAME & " v" & scriptVersion & " (" & functionCount & " functions)")
	return moduleInfo
end getModuleInfo

-- ==============================================================
-- ENTRY POINT for standalone testing
-- VERSION: 1.0.1 (2025-07-15) – protects init & loads Utilities
-- ==============================================================

on run
	-- 0 ▸ Minimal logging
	log "🟦 ContactOperations.run() – standalone test at " & (current date)
	
	-- 1 ▸ Ensure critical globals exist **before** init
	global debugMode, testMode, utilitiesScript
	set debugMode to true -- verbose console during tests
	set testMode to true -- never touch real contacts
	
	-- 2 ▸ Resolve Utilities module if missing
	if utilitiesScript is missing value then
		try
			-- Assume Utilities.scpt sits next to this script
			set mePath to (path to me as string)
			set ASTID to AppleScript's text item delimiters
			set AppleScript's text item delimiters to ":"
			set pathParts to text items of mePath
			set AppleScript's text item delimiters to ASTID
			set parentPath to (items 1 thru -2 of pathParts) as string
			set utilPath to parentPath & ":utilities.scpt"
			
			set utilitiesScript to load script alias utilPath
			log "🟩 Utilities module loaded from: " & utilPath
		on error loadErr
			
			-- ▸ ultra-light fallback Utilities stub (enough for group-tests)
			script utilitiesStub
				-- --- simple text helpers ----------------------------------
				on splitText(src, d)
					set TIDs to AppleScript's text item delimiters
					set AppleScript's text item delimiters to d
					set out to text items of src
					set AppleScript's text item delimiters to TIDs
					return out
				end splitText
				
				on joinText(lst, d)
					set TIDs to AppleScript's text item delimiters
					set AppleScript's text item delimiters to d
					set out to lst as text
					set AppleScript's text item delimiters to TIDs
					return out
				end joinText
				
				on trimWhitespace(t)
					-- crude trim: collapse leading / trailing spaces & tabs
					set txt to t as text
					repeat while txt begins with space or txt begins with tab
						set txt to text 2 thru -1 of txt
					end repeat
					repeat while txt ends with space or txt ends with tab
						set txt to text 1 thru -2 of txt
					end repeat
					return txt
				end trimWhitespace
				
				on sortList(theList)
					-- quick shell sort (case-insensitive, A→Z)
					return paragraphs of (do shell script "printf '%s\\n' " & quoted form of ((theList as text)) & " | sort -f")
				end sortList
				
				-- --- no-op log shims --------------------------------------
				on moduleLogDebug(m, msg)
					(* silent in stub – add “log msg” if you want console noise *)
				end moduleLogDebug
				
				on moduleLogError(m, msg)
					log msg
				end moduleLogError
				
				on moduleLogInfo(m, msg)
					log "ℹ️ [" & m & "] " & msg
				end moduleLogInfo
				
				on moduleLogWarning(m, msg)
					log "⚠️ [" & m & "] " & msg
				end moduleLogWarning
				
				on milestoneLog(m, msg)
					log "📍 [" & m & "] " & msg
				end milestoneLog
				
				on |missing value|(verboseMessage)
					-- ignore any unknown selector from ContactOperations
				end |missing value|
				
			end script
			
			set utilitiesScript to utilitiesStub
			log "🟨 Utilities stub injected (" & loadErr & ")"
		end try
	end if
	
	-- 3 ▸ Normal module initialisation
	initializeModule()
	coLogInfo("ContactOperations module (v" & scriptVersion & ") initialised for tests")
	
	-- 4 ▸ Execute unit-tests
	log my testExtractGroupsAsTagLine()
	log my testParseGroupsFromTagLine()
end run


