-- ==============================================
-- MODULE: Utilities
--  VERSION: 0.9.8 (2025-06-13)
-- ==============================================
-- Copyright: ¬©Philippe Dewost 2025
-- Universal utility module for CCC Contact Cleaner
--
-- ==============================================
-- CHANGELOG
-- ==============================================
-- 0.9.9 (2025-06-25) Added Performance Tracking System
--
-- ==============================================
--  FEATURE REQUESTS / NEXT STEPS
-- ==============================================
--     * Add fallback error handling for huge file/backup operations
--     * Enhance file path validation/normalization
--     * QA for all cross-module functions (called from Manager and Operations)
--     * Tune file I/O for performance
--     * Optimize join/split/replacement for >5000-line notes
--
-- ==============================================
-- KNOWN ISSUES
-- ==============================================
--    * None critical; all legacy bugs now isolated to caller modules.
--
-- ==============================================
-- CORE HANDLERS & STATUS
-- ==============================================
--   forceText (robust)
--   joinText (robust)
--   splitText (robust)
--   minOfList (robust)
--   trimWhitespace (robust)
--   replaceText (robust)
--   deduplicateFirstHalfRepeat (robust)
--   processCrossParagraphDedupe (robust)
--   saveTextToFile, createFolderPath (robust)
--   All logging wrappers: moduleLogDebug, safeLog, etc. (robust)

(*
Proposed Functional Regrouping for Utilities.txt:
Based on modular design best practices and actual usage patterns, here's the recommended reorganization:

Block 1: Module Core & Initialization
applescript-- Essential module setup and configuration

Block 2: Public Text Processing Engine
applescript-- Core text manipulation utilities (heavily used by other modules)

Block 3: Public File & Path Operations
applescript-- File system operations exposed to other modules

Block 4: Public Logging Interface
applescript-- Main logging system for other modules

Block 5: Backup System Engine (Internal)
applescript-- Comprehensive backup system (mostly internal)

Block 6: Logging System Implementation (Internal)
applescript-- Advanced logging implementation details

Block 7: Internal Utilities & Helpers
applescript-- Internal supporting functions

Block 8: Unused/Alternative Utilities
applescript-- Currently unused but potentially useful utilities

Block 9: Deprecated & Testing
applescript-- Deprecated APIs and testing functions

Consolidate Public API: Move the most-used handlers (Blocks 2-4) to the top for better discoverability
Hide Implementation Details: Keep internal backup and logging implementation in separate blocks
Mark Deprecated Code: Clearly separate deprecated handlers that should be removed
Document Block Dependencies: Each block should document its dependencies on other blocks
Consider Breaking Up: The backup system (Block 5) could potentially be its own module given its size and complexity
*)

use AppleScript version "2.4"
use framework "Foundation"
use scripting additions

-- No log statements, no prints, nothing that runs during module load

-- Define basic properties
property MODULE_NAME : "Utilities"
property scriptVersion : "0.9.0-alpha4"

-- ==============================================
-- LOGGING CONSTANTS (Properties - Compile Time)
-- VERSION: 0.9.8-fix1 (2025-06-13)
-- ==============================================
property kLogLevelError : 0
property kLogLevelInfo : 1
property kLogLevelDebug : 2
property kLogLevelWarning : 3
property kLogLevelMilestone : 9
property emojiMilestone : "üìç"
property emojiError : "üî¥"
property emojiWarning : "‚ö†Ô∏è"
property emojiInfo : "‚ÑπÔ∏è"
property emojiDebug : "üîç"
property logInitialized : false
property primaryLogFile : ""
property sessionLogFile : ""
property logLevel : 1
property scriptFolder : ""
property backupFolder : ""
property logsFolder : ""
property reportsFolder : ""
property logFilePath : "" -- will be filled by initializeLogs, but never undefined
property inLoggingFunction : false -- Flag to prevent recursion in logging
property initialLogQueue : {}
property autoEscalated : false
property consecutiveErrorCount : 0 -- for log level escalation
property LOG_ESCALATE_AFTER_ERRORS : 1 -- flip to DEBUG after 3 consecutive ERRORs
property gLogLevel : 1 -- shadow of logLevel for legacy helpers
property gLoggingActive : false -- becomes true once initialiseLogging() ends
property gLogFileAlias : missing value -- alias to the open session log file
property sessionPathsInitialized : false
property sessionLogPath : ""
property cachedPerformanceHistory : missing value
property performanceHistoryLoaded : false

-------------------------------------------------------------------------------
-- Handler: initializeModule
-- VERSION: 0.9.9 (2025-06-22)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Module initialization without independent startup logging
-- CHANGE: Removes independent logging during startup phase
-- WHY:    Single-buffer approach eliminates need for Utilities startup buffer
-- WHEN:   Called during loadModules() phase of system initialization
-- HOW:    Returns success/failure without logging, parent handles logging
-- BREAKS:  Nothing - same interface, eliminates buffer merge complexity
-------------------------------------------------------------------------------
on initializeModule()
	global MODULE_NAME
	-- Set module identifier
	set MODULE_NAME to "Utilities"
	
	-- Initialize module state
	try
		resetLoggingState()
		setupFolders()
	on error initErr
		-- Return error to parent instead of logging directly
		error "Utilities initialization failed: " & initErr
	end try
	-- NO LOGGING during startup - ContactManager handles all startup logging
	-- Parent (loadModules) will log success/failure appropriately	
	return true
end initializeModule

--  Wipe every transient logging property that persists between runs (properties survive AppleScript compiles).   
------------------------------------------------------------
on resetLoggingState()
	-- Clear the stored path and mark logging as not initialised
	set my logFilePath to ""
	set my logInitialized to false
	
	set my initialLogQueue to {}
	
	-- Reset error-escalation flag so we can auto-escalate again
	set my autoEscalated to false
	
	-- Reset the re-entrancy guard used inside _appendToLog
	set my inLoggingFunction to false
	
	-- Reset Performance History Cache
	set cachedPerformanceHistory to missing value
	set performanceHistoryLoaded to false
	
end resetLoggingState

-- PURPOSE: Create basic folder structure with simple error handling
on setupFolders()
	-- Get base folders
	set docsPath to path to documents folder as string
	set cccFolder to docsPath & "CCC Script:"
	
	-- Initialize folder paths to empty strings
	set scriptFolder to "" -- Will be set to session folder later
	set backupFolder to "" -- Will be set to session's backup folder later
	set logsFolder to "" -- Will be set to session's logs folder later
	set reportsFolder to "" -- Will be set to session's reports folder later
	
	-- Only create the base CCC folder if needed
	try
		tell application "Finder"
			if not (exists folder cccFolder) then
				make new folder at docsPath with properties {name:"CCC Script"}
			end if
		end tell
		return true
	on error errMsg
		try
			my moduleLogError("Utilities", "setupFolders() failed to create CCC Script folder: " & errMsg)
		on error
			log "‚ùå Failed to create CCC Script folder: " & errMsg
		end try
		return false
	end try
end setupFolders

-------------------------------------------------------------------------------
-- Handler: setSessionPaths
-- VERSION: 0.9.10 (2025-06-24)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Store session folder paths with single responsibility principle
-- CHANGE: Removed redundant initializeLogging() calls that caused duplicate debug messages
-- WHY:    setSessionPaths() should only set paths - logging initialization is caller's responsibility
-- WHEN:   Called during initializeSystem() and by other modules  
-- HOW:    Eliminated initializeLogging() calls, maintains only path setting functionality
-- BREAKS:  Nothing - caller (initializeSystem) already handles initializeLogging() properly
-- DEPENDENCIES: Requires sessionPathsInitialized property, global path variables
-- RESPONSIBILITY: Path setting ONLY - no logging initialization
-------------------------------------------------------------------------------
on setSessionPaths(newSessionFolder, newBackupFolder, newLogsFolder, newReportsFolder)
	global logFilePath, logsFolder, scriptFolder, backupFolder, reportsFolder
	global loggingActive -- Phase detection for single-buffer approach
	
	-- SINGLE RESPONSIBILITY: Only set paths, don't initialize logging
	-- The caller (initializeSystem) is responsible for logging initialization
	if sessionPathsInitialized is false then
		-- PHASE-AWARE LOGGING: Only log during runtime phase
		try
			if loggingActive is true then
				-- RUNTIME PHASE: Safe to log path updates
				my moduleLogDebug("Utilities", "Session paths updated: " & newSessionFolder)
				my safeLog("Utilities", "Session paths: " & newSessionFolder & ", " & newBackupFolder & ", " & newLogsFolder & ", " & newReportsFolder, kLogLevelDebug, missing value)
			else
				-- STARTUP PHASE: Silent operation - ContactManager logs success/failure
				-- NO LOGGING INITIALIZATION - caller handles this
			end if
		on error phaseErr
			-- Fallback: if loggingActive undefined, assume startup phase and stay silent
		end try
		
		set sessionPathsInitialized to true
	end if
	
	-- CORE FUNCTIONALITY: Update all path globals (unchanged)
	set scriptFolder to newSessionFolder
	set backupFolder to newBackupFolder
	set logsFolder to newLogsFolder
	set reportsFolder to newReportsFolder
	
	-- DIRECTORY SAFETY: Ensure logs folder exists for future operations (silent)
	try
		do shell script "mkdir -p " & quoted form of (POSIX path of newLogsFolder)
	on error mkdirErr
		-- Only log mkdir errors during runtime phase
		try
			if loggingActive is true then
				my safeLog("Utilities", "‚ö†Ô∏è Error creating logs folder: " & mkdirErr, kLogLevelWarning, missing value)
			end if
		on error
			-- Ignore logging errors during startup phase
		end try
	end try
	
	return true
end setSessionPaths

-------------------------------------------------------------------------------
-- Handler: initializeTrackingFiles
-- VERSION: 1.0.0  (2025-07-07)
-- PURPOSE: Ensure performance_history.txt and ccc_stats.txt both exist;
--          create templates if missing and log.
-------------------------------------------------------------------------------
on initializeTrackingFiles()
	set basePath to my getBaseCCCFolder()
	-- Performance History
	set phPath to basePath & "performance_history.txt"
	if my fileExists(phPath) is false then
		my saveTextToFile(my buildPerformanceHistoryTemplate(), phPath)
		my moduleLogInfo("Utilities", "Performance Tracking System initialised (" & phPath & ")")
	else
		-- DON‚ÄôT rewrite template; just ensure mandatory keys exist
		-- my ensurePerformanceKeys(phPath)
	end if
	-- Cumulative Stats
	set csPath to basePath & "ccc_stats.txt"
	if my fileExists(csPath) is false then
		my saveTextToFile(my buildCumulativeStatsTemplate(), csPath)
		my moduleLogInfo("Utilities", "Cumulative Statistics initialised (" & csPath & ")")
	end if
end initializeTrackingFiles

-- ==============================================
-- BACKUP MANAGER SYSTEM
-- ==============================================
-- VERSION: 6.0.0-alpha13 (2025-04-28)
-- STATUS: STABLE - DO NOT MODIFY
-- PURPOSE: Comprehensive script backup system that tracks scripts for backup
--          based on version changes, file modifications, and time intervals.

-- ================ CONFIGURATION ================
-- Backup system configuration properties - FINALIZED
property BACKUP_TIME_INTERVAL : 6 -- Hours between time-based backups in development mode
property BACKUP_RETENTION_COUNT : 10 -- Number of backup versions to keep
property BACKUP_ALWAYS_INCLUDE_TEXT : true -- Always include text exports of scripts
property BACKUP_ROOT_FOLDER : "" -- Will be auto-detected
property BACKUP_DEV_MODE : true -- Enable more frequent backups for development

-------------------------------------------------------------------------------
-- Facade: backupDebugLog
-- VERSION: 1.0.0 (2025-06-17)
-- PURPOSE: Conditionally log BackupManager DEBUG entries
--          Only emits if BACKUP_DEBUG_VERBOSE is true
-------------------------------------------------------------------------------
property BACKUP_DEBUG_VERBOSE : false -- Set to true to enable verbose backup debug logging

on backupDebugLog(msg)
	if BACKUP_DEBUG_VERBOSE then
		my moduleLogDebug("BackupManager", msg)
	end if
end backupDebugLog

-- ================ CRITICAL PATHS ================
-- These paths will be initialized at runtime - DO NOT MODIFY
property BACKUP_HISTORY_PATH : "" -- Path to backup history file 
property BACKUP_VERSION_PATH : "" -- Path to last backup version file
property BACKUP_BASE_FOLDER : "" -- Base folder for all backups

-- ================ PUBLIC INTERFACES ================
-------------------------------------------------------------------------------
-- Handler: runBackupSystem
-- VERSION: 0.9.9 (2025-06-23)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Main backup system entry point with phase-aware logging
-- CHANGE: Added startup phase detection to prevent single-buffer violations
-- WHY:    runBackupSystem() called during startup was logging independently
-- WHEN:   Called during initializeSystem() and by user actions
-- HOW:    Checks loggingActive flag to stay silent during startup
-- BREAKS:  Nothing - maintains same functionality, eliminates startup logging
-------------------------------------------------------------------------------
on runBackupSystem(mainVersion)
	global loggingActive -- Phase detection for single-buffer approach
	
	-- PHASE-AWARE LOGGING: Only log during runtime phase
	try
		if loggingActive is true then
			-- RUNTIME PHASE: Normal logging allowed
			my moduleLogDebug("BackupManager", "Starting backup system check")
		else
			-- STARTUP PHASE: Silent operation - ContactManager will log success/failure
		end if
	on error phaseErr
		-- Fallback: if loggingActive undefined, assume startup phase and stay silent
	end try
	
	-- Initialize backup system (will also be made phase-aware)
	initializeBackupSystem()
	
	-- Check for session marker first to avoid redundant backups
	if hasSessionBackupMarker() then
		-- Only log during runtime phase
		try
			if loggingActive is true then
				my backupDebugLog("Session already has backup marker - skipping backup")
			end if
		on error
			-- Ignore logging errors
		end try
		return {success:true, reason:"Session backup already performed", path:""}
	end if
	
	-- Check if backup should be performed
	set backupDecision to shouldPerformBackup(mainVersion)
	if backupDecision's needed then
		-- Perform backup and record result
		set backupResult to createBackup(mainVersion, "Automatic backup")
		
		if backupResult's success then
			recordSuccessfulBackup(mainVersion, "Automatic backup")
			createSessionBackupMarker("Backup completed: " & backupDecision's reason)
			
			-- Only log success during runtime phase
			try
				if loggingActive is true then
					my moduleLogInfo("BackupManager", "‚úÖ Backup completed successfully")
				end if
			on error
				-- Ignore logging errors during startup
			end try
		else
			-- Only log failure during runtime phase
			try
				if loggingActive is true then
					my moduleLogError("BackupManager", "‚ùå Backup failed: " & backupResult's reason)
				end if
			on error
				-- Ignore logging errors during startup
			end try
		end if
		
		return backupResult
	else
		-- Only log skip reason during runtime phase
		try
			if loggingActive is true then
				my backupDebugLog("No backup needed - all triggers check passed")
			end if
		on error
			-- Ignore logging errors during startup
		end try
		return {success:true, reason:"No backup needed", path:""}
	end if
end runBackupSystem

-- Force an immediate backup regardless of conditions
on forceBackup(mainVersion)
	my backupDebugLog("User requested forced backup of version: " & mainVersion)
	
	-- Initialize backup system if needed
	my backupDebugLog("Ensuring backup system is initialized")
	initializeBackupSystem()
	
	-- Log that we're bypassing normal triggers
	my backupDebugLog("Bypassing normal backup triggers for forced backup")
	
	-- Perform backup with user-triggered reason
	my backupDebugLog("Creating forced backup with version: " & mainVersion)
	set backupResult to createBackup(mainVersion, "User-requested backup")
	
	-- Record successful backup with proper logging
	if backupResult's success then
		my backupDebugLog("Forced backup created successfully, recording in history")
		recordSuccessfulBackup(mainVersion, "User-requested backup")
		my backupDebugLog("Backup history updated with forced backup: " & mainVersion)
		
		-- Log details about the backup location
		if backupResult contains "path" then
			my backupDebugLog("Backup saved to: " & backupResult's path)
		end if
	else
		-- Log details about the failure
		my moduleLogError("BackupManager", "Forced backup creation failed: " & backupResult's reason)
	end if
	
	return backupResult
end forceBackup

-- Get backup statistics for UX display
on getBackupStats()
	-- Initialize backup system
	initializeBackupSystem()
	
	-- Count total backups
	set backupCount to countExistingBackups()
	
	-- Get date of last backup
	set lastBackupDate to getLastBackupDate()
	
	-- Get disk space used by backups (in MB)
	set spaceUsed to getBackupSpaceUsed()
	
	-- Return stats bundle
	return {backupCount:backupCount, lastBackupDate:lastBackupDate, spaceUsed:spaceUsed}
end getBackupStats

-------------------------------------------------------------------------------
-- Handler: initializeBackupSystem
-- VERSION: 0.9.9 (2025-06-23)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Initialize backup system with phase-aware logging
-- CHANGE: Added startup phase detection to prevent logging during initialization
-- WHY:    initializeBackupSystem() was logging during startup, violating single-buffer
-- WHEN:   Called by runBackupSystem() during startup and runtime
-- HOW:    Checks loggingActive flag to determine when logging is appropriate
-- BREAKS:  Nothing - maintains same initialization logic, eliminates startup logging
-------------------------------------------------------------------------------
on initializeBackupSystem()
	global loggingActive -- Phase detection for single-buffer approach
	
	-- Skip if already initialized to avoid redundant operations
	if BACKUP_ROOT_FOLDER is not "" then
		-- Only log during runtime phase
		try
			if loggingActive is true then
				my backupDebugLog("Backup system already initialized - using existing configuration")
			end if
		on error
			-- Ignore logging errors
		end try
		return true
	end if
	
	-- PHASE-AWARE LOGGING: Only log during runtime phase
	try
		if loggingActive is true then
			-- RUNTIME PHASE: Normal logging allowed
			my backupDebugLog("BackupManager", "Initializing backup system")
		else
			-- STARTUP PHASE: Silent operation
		end if
	on error phaseErr
		-- Fallback: if loggingActive undefined, assume startup phase and stay silent
	end try
	
	-- 1. Global tracking folder (persists across sessions)
	set GLOBAL_TRACKING_FOLDER to (path to documents folder as string) & "CCC Script:"
	
	-- Only log path during runtime phase
	try
		if loggingActive is true then
			my backupDebugLog("Global tracking folder path: " & GLOBAL_TRACKING_FOLDER)
		end if
	on error
		-- Ignore logging errors during startup
	end try
	
	-- 2. Session-specific backup folder with backup path validation
	global backupFolder
	if backupFolder is not "" and backupFolder is not missing value then
		set BACKUP_ROOT_FOLDER to backupFolder
		-- Only log during runtime phase
		try
			if loggingActive is true then
				my backupDebugLog("Using session backup folder: " & BACKUP_ROOT_FOLDER)
			end if
		on error
			-- Ignore logging errors during startup
		end try
	else
		-- Fallback to default location
		set BACKUP_ROOT_FOLDER to (path to documents folder as string) & "CCC Script:Backups:"
		-- Only log during runtime phase
		try
			if loggingActive is true then
				my backupDebugLog("Session backup folder not available - using default backup folder: " & BACKUP_ROOT_FOLDER)
			end if
		on error
			-- Ignore logging errors during startup
		end try
	end if
	
	-- 3. Set up paths (unchanged core logic)
	set BACKUP_BASE_FOLDER to BACKUP_ROOT_FOLDER & "Scripts:"
	set BACKUP_HISTORY_PATH to GLOBAL_TRACKING_FOLDER & "script_backup_history.txt"
	set BACKUP_VERSION_PATH to GLOBAL_TRACKING_FOLDER & "last_backup_version.txt"
	
	-- Only log paths during runtime phase
	try
		if loggingActive is true then
			my backupDebugLog("Defined backup paths: BASE=" & BACKUP_BASE_FOLDER & ", HISTORY=" & BACKUP_HISTORY_PATH)
		end if
	on error
		-- Ignore logging errors during startup
	end try
	
	-- 4. Create folders (unchanged core logic with phase-aware logging)
	try
		-- Create global tracking folder if needed
		tell application "Finder"
			if not (exists folder GLOBAL_TRACKING_FOLDER) then
				make new folder at (path to documents folder) with properties {name:"CCC Script"}
				-- Only log creation during runtime phase
				try
					if loggingActive is true then
						my moduleLogInfo("BackupManager", "Created global tracking folder: " & GLOBAL_TRACKING_FOLDER)
					end if
				on error
					-- Ignore logging errors during startup
				end try
			else
				-- Only log existing folder during runtime phase
				try
					if loggingActive is true then
						my backupDebugLog("Global tracking folder already exists")
					end if
				on error
					-- Ignore logging errors during startup
				end try
			end if
		end tell
		
		-- Create backup scripts folder
		tell application "Finder"
			if not (exists folder BACKUP_BASE_FOLDER) then
				make new folder at BACKUP_ROOT_FOLDER with properties {name:"Scripts"}
				-- Only log creation during runtime phase
				try
					if loggingActive is true then
						my backupDebugLog("BackupManager", "Created Scripts subfolder: " & BACKUP_BASE_FOLDER)
					end if
				on error
					-- Ignore logging errors during startup
				end try
			else
				-- Only log existing folder during runtime phase
				try
					if loggingActive is true then
						my backupDebugLog("Scripts subfolder already exists")
					end if
				on error
					-- Ignore logging errors during startup
				end try
			end if
		end tell
	on error createErr
		-- Only log errors during runtime phase
		try
			if loggingActive is true then
				my moduleLogError("BackupManager", "Error creating folders: " & createErr)
			end if
		on error
			-- Ignore logging errors during startup
		end try
		
		-- Try shell command as fallback (silent during startup)
		try
			do shell script "mkdir -p " & quoted form of (POSIX path of BACKUP_BASE_FOLDER)
			-- Only log shell success during runtime phase
			try
				if loggingActive is true then
					my moduleLogInfo("BackupManager", "Created folder using shell command for: " & BACKUP_BASE_FOLDER)
				end if
			on error
				-- Ignore logging errors during startup
			end try
		on error shellErr
			-- Only log shell failure during runtime phase
			try
				if loggingActive is true then
					my moduleLogError("BackupManager", "Shell folder creation also failed: " & shellErr & " - backup operations may fail")
				end if
			on error
				-- Ignore logging errors during startup
			end try
		end try
	end try
	
	-- Final success message - only during runtime phase
	try
		if loggingActive is true then
			my moduleLogDebug("BackupManager", "Backup system initialized successfully")
			my backupDebugLog("Base folder: " & BACKUP_BASE_FOLDER)
			my backupDebugLog("Version tracking files stored in: " & GLOBAL_TRACKING_FOLDER)
		end if
	on error
		-- Ignore logging errors during startup
	end try
	
	return true
end initializeBackupSystem

-- ================ BACKUP DECISION LOGIC ================
-- Check if backup should be performed based on multiple triggers
-- PURPOSE: Combined decision logic for all backup triggers with enhanced logging
on shouldPerformBackup(mainVersion)
	-- Use standardized logging with module name for all log messages
	my backupDebugLog("Checking if backup is needed")
	
	-- 1. Check for version change (highest priority)
	my backupDebugLog("Checking for version changes")
	set versionResult to checkVersionChange(mainVersion)
	if versionResult's changed then
		my moduleLogInfo("BackupManager", "Version change detected: " & versionResult's oldVersion & " ‚Üí " & mainVersion)
		return {needed:true, reason:"Version changed from " & versionResult's oldVersion & " to " & mainVersion}
	end if
	
	-- 2. Check for script file modifications
	my backupDebugLog("Checking for script file modifications")
	set fileResult to checkScriptFileChanges()
	if fileResult's changed then
		my backupDebugLog("Modified script file detected: " & fileResult's filename)
		return {needed:true, reason:"Script file modified: " & fileResult's filename}
	end if
	
	-- 3. Check for time-based backup (development mode only)
	if BACKUP_DEV_MODE then
		my backupDebugLog("Development mode active - checking time-based backup triggers")
		set timeResult to checkTimeBasedBackup()
		if timeResult's needed then
			my backupDebugLog("Time-based backup needed: " & timeResult's reason)
			return {needed:true, reason:"Time-based backup (dev mode): " & timeResult's reason}
		end if
	end if
	
	-- No backup needed
	my backupDebugLog("No backup triggers detected")
	return {needed:false, reason:"No backup triggers detected"}
end shouldPerformBackup

-- Check if version has changed from last backup
on checkVersionChange(currentVersion)
	try
		-- Get last backed up version with detailed logging
		my backupDebugLog("Retrieving last backed up version for comparison")
		set lastVersion to readLastBackupVersion()
		
		my backupDebugLog("BackupManager", "Checking version change: Current=" & currentVersion & ", Last=" & lastVersion)
		
		-- Perform detailed comparison with explicit logging
		if lastVersion is "" then
			my backupDebugLog("No previous version found - first backup needed")
			return {changed:true, oldVersion:"(none)", newVersion:currentVersion}
		else if lastVersion is not equal to currentVersion then
			my moduleLogInfo("BackupManager", "Version change detected: " & lastVersion & " ‚Üí " & currentVersion)
			return {changed:true, oldVersion:lastVersion, newVersion:currentVersion}
		else
			my backupDebugLog("Version unchanged: still at " & currentVersion)
			return {changed:false, oldVersion:lastVersion, newVersion:currentVersion}
		end if
	on error errMsg
		my moduleLogError("BackupManager", "Error in version check: " & errMsg)
		
		-- Safety first - return true if we can't determine version (to ensure backup happens)
		my moduleLogError("BackupManager", "Triggering backup due to version check error")
		return {changed:true, oldVersion:"(error)", newVersion:currentVersion}
	end try
end checkVersionChange

-- Check for script file modifications since last backup
on checkScriptFileChanges()
	my backupDebugLog("Checking for script file modifications since last backup")
	
	try
		-- Get the last backup timestamp with proper logging
		my backupDebugLog("Retrieving last backup date for comparison")
		set lastBackupDate to getLastBackupDate()
		my backupDebugLog("Last backup date: " & lastBackupDate)
		
		-- Get the module folder with proper error handling
		my backupDebugLog("Getting script module folder path")
		set moduleFolder to getScriptFolder()
		
		-- List all script files in the folder
		my backupDebugLog("Scanning for script files in: " & moduleFolder)
		set scriptFiles to listScriptFiles(moduleFolder)
		my backupDebugLog("Found " & (count of scriptFiles) & " script files to check")
		
		-- Check each script file's modification date
		repeat with scriptFile in scriptFiles
			set filePath to scriptFile's path
			set filename to scriptFile's name
			
			my backupDebugLog("Checking modification date for: " & filename)
			
			tell application "System Events"
				set fileModDate to modification date of file filePath
				
				-- Compare with last backup date
				if fileModDate > lastBackupDate then
					my backupDebugLog("Script modified since last backup: " & filename)
					my backupDebugLog("Last backup: " & lastBackupDate & ", File mod: " & fileModDate)
					return {changed:true, filename:filename, path:filePath, modDate:fileModDate}
				else
					my backupDebugLog("Script " & filename & " unchanged since last backup")
				end if
			end tell
		end repeat
		
		-- No modifications found
		my backupDebugLog("No script file modifications found since last backup")
		return {changed:false, filename:"", path:"", modDate:missing value}
	on error errMsg
		my moduleLogError("BackupManager", "Error checking script file changes: " & errMsg)
		
		-- If error occurs, assume no changes for safety
		my moduleLogError("BackupManager", "Assuming no changes due to error checking files")
		return {changed:false, filename:"", path:"", modDate:missing value}
	end try
end checkScriptFileChanges

-- Check if time-based backup is needed (only in dev mode)
on checkTimeBasedBackup()
	my backupDebugLog("Checking if time-based backup is needed")
	
	try
		-- Get the last backup timestamp with logging
		my backupDebugLog("Retrieving last backup date")
		set lastBackupDate to getLastBackupDate()
		set currentDate to (current date)
		
		-- Calculate hours since last backup with detailed logging
		set secondsSinceBackup to currentDate - lastBackupDate
		set hoursSinceBackup to secondsSinceBackup / 3600
		
		my backupDebugLog("Hours since last backup: " & hoursSinceBackup)
		
		-- Check if we've exceeded the interval with clear decision logging
		if hoursSinceBackup > BACKUP_TIME_INTERVAL then
			my backupDebugLog("Time-based backup needed: " & (round hoursSinceBackup) & " hours exceeds " & BACKUP_TIME_INTERVAL & " hour threshold")
			return {needed:true, reason:"Last backup was " & (round hoursSinceBackup) & " hours ago"}
		else
			-- Log the decision clearly for debugging
			set hoursRemaining to BACKUP_TIME_INTERVAL - hoursSinceBackup
			my backupDebugLog("Time-based backup not needed: " & (round hoursSinceBackup) & " hours since backup, " & (round hoursRemaining) & " hours remaining until next automatic backup")
			return {needed:false, reason:"Last backup was only " & (round hoursSinceBackup) & " hours ago"}
		end if
	on error errMsg
		my moduleLogError("BackupManager", "Error in time-based backup check: " & errMsg)
		
		-- If error occurs, trigger backup to be safe, with clear reasoning
		my moduleLogError("BackupManager", "Triggering backup due to error in time-based check")
		return {needed:true, reason:"Error determining last backup time"}
	end try
end checkTimeBasedBackup

-- ================ BACKUP CREATION ================
-- Create a complete backup of all script files in .scpt and .txt format
on createBackup(mainVersion, backupReason)
	my backupDebugLog("Creating backup for version: " & mainVersion)
	
	-- Generate timestamp for this backup
	set timestamp to formatTimestamp(current date)
	set versionTimestamp to mainVersion & "_" & timestamp
	my backupDebugLog("Generated timestamp for backup: " & versionTimestamp)
	
	-- Create version folder
	set versionFolderName to "v" & versionTimestamp
	set versionFolder to BACKUP_BASE_FOLDER & versionFolderName & ":"
	
	my backupDebugLog("Creating version folder: " & versionFolderName)
	
	-- Create the folder with error handling
	try
		tell application "Finder"
			-- Create version folder
			if not (exists folder versionFolder) then
				make new folder at BACKUP_BASE_FOLDER with properties {name:versionFolderName}
				my backupDebugLog("Created version folder at: " & versionFolder)
			else
				my backupDebugLog("Version folder already exists: " & versionFolder)
			end if
		end tell
	on error folderErr
		my moduleLogError("BackupManager", "Error creating version folder: " & folderErr)
		return {success:false, reason:"Failed to create backup folder: " & folderErr, version:versionTimestamp}
	end try
	
	-- Get list of all script files
	my backupDebugLog("Getting list of script files to backup")
	set moduleFolder to getScriptFolder()
	set scriptFiles to listScriptFiles(moduleFolder)
	
	-- Log the number of files to be backed up
	my backupDebugLog("Found " & (count of scriptFiles) & " scripts to backup")
	
	-- Backup results
	set backupResults to {}
	set scriptsCopied to 0
	set scriptsExported to 0
	set failedScripts to {}
	
	-- Copy each script
	repeat with scriptFile in scriptFiles
		set srcPath to scriptFile's path
		set scriptName to scriptFile's name
		set destPath to versionFolder & scriptName
		
		my backupDebugLog("Backing up script: " & scriptName)
		set scriptResult to {name:scriptName, copied:false, exported:false}
		
		try
			-- 1. Copy script binary
			tell application "Finder"
				duplicate file srcPath to folder versionFolder
			end tell
			
			set scriptResult's copied to true
			set scriptsCopied to scriptsCopied + 1
			my backupDebugLog("Successfully copied script: " & scriptName)
			
			-- 2. Export as text using osadecompile
			if BACKUP_ALWAYS_INCLUDE_TEXT then
				try
					-- Create text filename (remove .scpt extension)
					set textFilename to text 1 thru ((offset of ".scpt" in scriptName) - 1) of scriptName & ".txt"
					set textPath to versionFolder & textFilename
					
					my backupDebugLog("Exporting script as text: " & textFilename)
					
					-- Use osadecompile to export text
					set posixSrcPath to POSIX path of srcPath
					set posixTextPath to POSIX path of textPath
					do shell script "osadecompile " & quoted form of posixSrcPath & " > " & quoted form of posixTextPath
					
					set scriptResult's exported to true
					set scriptsExported to scriptsExported + 1
					my backupDebugLog("Successfully exported script as text: " & textFilename)
				on error exportErr
					my moduleLogError("BackupManager", "Failed to export " & scriptName & " as text: " & exportErr)
				end try
			end if
		on error copyErr
			my moduleLogError("BackupManager", "Error copying " & scriptName & ": " & copyErr)
			set end of failedScripts to scriptName
		end try
		
		set end of backupResults to scriptResult
	end repeat
	
	-- Create detailed manifest
	my backupDebugLog("Creating backup manifest with details")
	createBackupManifest(versionFolder, mainVersion, backupReason, backupResults)
	
	-- Clean up old backups
	my backupDebugLog("Checking for old backups to clean up")
	cleanupOldBackups()
	
	-- Return success if at least one script was copied
	if scriptsCopied > 0 then
		my backupDebugLog("BackupManager", "Backup completed successfully: " & scriptsCopied & " scripts copied, " & scriptsExported & " exported as text")
		
		-- Log any failures if they occurred
		if (count of failedScripts) > 0 then
			my moduleLogError("BackupManager", "Warning: " & (count of failedScripts) & " scripts failed to copy")
		end if
		
		return {success:true, version:versionTimestamp, path:versionFolder, reason:backupReason, scriptsCopied:scriptsCopied, scriptsExported:scriptsExported, failedScripts:failedScripts}
	else
		my moduleLogError("BackupManager", "Backup failed: No scripts were copied")
		return {success:false, reason:"Failed to copy any scripts", version:versionTimestamp}
	end if
end createBackup

-- Create a manifest file with backup details
-- PURPOSE: Document the backup contents and metadata with improved logging
on createBackupManifest(versionFolder, mainVersion, backupReason, backupResults)
	my backupDebugLog("Creating backup manifest for version: " & mainVersion)
	
	-- Create detailed manifest content
	my backupDebugLog("Building manifest content with backup details")
	
	set manifestContent to "# Script Backup Manifest" & return
	set manifestContent to manifestContent & "Version: " & mainVersion & return
	set manifestContent to manifestContent & "Backup Date: " & ((current date) as string) & return
	set manifestContent to manifestContent & "Trigger: " & backupReason & return & return
	
	-- Add backup results to manifest
	set manifestContent to manifestContent & "## Backup Results" & return
	
	-- Log statistics for debugging
	set scriptsTotal to count of backupResults
	set scriptsCopied to 0
	set scriptsExported to 0
	
	my backupDebugLog("Processing results for " & scriptsTotal & " scripts")
	
	repeat with result in backupResults
		set scriptName to result's name
		set scriptStatus to ""
		
		if result's copied then
			set scriptsTotal to scriptsTotal + 1
			set scriptStatus to "Copied"
			if result's exported then
				set scriptsExported to scriptsExported + 1
				set scriptStatus to scriptStatus & ", Exported as text"
			end if
		else
			set scriptStatus to "FAILED"
		end if
		
		set manifestContent to manifestContent & "- " & scriptName & ": " & scriptStatus & return
	end repeat
	
	-- Log manifest statistics
	my backupDebugLog("Manifest includes " & scriptsTotal & " scripts, " & scriptsExported & " with text exports")
	
	-- Save manifest file using shell command with proper error handling
	set manifestPath to versionFolder & "manifest.txt"
	my backupDebugLog("Saving manifest to: " & manifestPath)
	
	try
		set posixPath to POSIX path of manifestPath
		do shell script "echo " & quoted form of manifestContent & " > " & quoted form of posixPath
		
		my backupDebugLog("Created manifest at: " & manifestPath)
		return true
	on error errMsg
		my moduleLogError("BackupManager", "Error creating manifest: " & errMsg)
		
		-- Try alternate approach if shell command fails
		try
			set manifestFile to open for access file manifestPath with write permission
			set eof of manifestFile to 0
			write manifestContent to manifestFile
			close access manifestFile
			
			my backupDebugLog("Created manifest using direct file access")
			return true
		on error altErr
			my moduleLogError("BackupManager", "All manifest creation methods failed: " & altErr)
			
			-- Make sure file is closed if it was opened
			try
				close access manifestFile
			end try
			
			return false
		end try
	end try
end createBackupManifest

-- Record successful backup in history file
-- PURPOSE: Track backup history and save version information with improved logging
on recordSuccessfulBackup(mainVersion, backupReason)
	my backupDebugLog("Recording successful backup of version: " & mainVersion)
	
	-- Save current version using shell command
	my backupDebugLog("Saving current version to version tracking file")
	try
		set posixPath to POSIX path of BACKUP_VERSION_PATH
		do shell script "echo " & quoted form of mainVersion & " > " & quoted form of posixPath
		my backupDebugLog("BackupManager", "Saved version to: " & BACKUP_VERSION_PATH)
	on error errMsg
		my moduleLogError("BackupManager", "Error saving version: " & errMsg)
		
		-- Try alternate method if shell command fails
		try
			set versionFile to open for access file BACKUP_VERSION_PATH with write permission
			set eof of versionFile to 0
			write mainVersion to versionFile
			close access versionFile
			my moduleLogInfo("BackupManager", "Saved version using direct file access")
		on error altErr
			my moduleLogError("BackupManager", "All version saving methods failed: " & altErr)
			
			-- Make sure file is closed if it was opened
			try
				close access versionFile
			end try
		end try
	end try
	
	-- Add to history file using shell command
	my backupDebugLog("Updating backup history file")
	try
		set timestamp to formatTimestamp(current date)
		set historyEntry to mainVersion & "_" & timestamp & " | " & ((current date) as string) & " | " & backupReason
		my backupDebugLog("Created history entry: " & historyEntry)
		
		set posixPath to POSIX path of BACKUP_HISTORY_PATH
		
		-- Check if file exists with detailed logging
		my backupDebugLog("Checking if history file exists at: " & BACKUP_HISTORY_PATH)
		set fileCheckCmd to "test -f " & quoted form of posixPath & " && echo 'exists' || echo 'missing'"
		set fileStatus to do shell script fileCheckCmd
		
		if fileStatus is "exists" then
			-- Append to existing file
			my backupDebugLog("History file exists - appending new entry")
			do shell script "echo " & quoted form of historyEntry & " >> " & quoted form of posixPath
			my backupDebugLog("BackupManager", "Updated history file")
		else
			-- Create new file with header
			my backupDebugLog("History file doesn't exist - creating new file with header")
			set headerText to "# Script Version History" & return
			set headerText to headerText & "# Format: versionTimestamp | creation date | backup reason" & return & return
			
			do shell script "echo " & quoted form of (headerText & historyEntry) & " > " & quoted form of posixPath
			my backupDebugLog("BackupManager", "Created new history file")
		end if
		
		return true
	on error errMsg
		my moduleLogError("BackupManager", "Error updating history: " & errMsg)
		
		-- Try alternate method if shell command fails
		try
			set historyFile to open for access file BACKUP_HISTORY_PATH with write permission
			set eof of historyFile to (get eof of historyFile)
			write historyEntry & return to historyFile
			close access historyFile
			my backupDebugLog("BackupManager", "Updated history using direct file access")
			return true
		on error altErr
			my moduleLogError("BackupManager", "All history update methods failed: " & altErr)
			
			-- Make sure file is closed if it was opened
			try
				close access historyFile
			end try
			
			return false
		end try
	end try
end recordSuccessfulBackup

-- Clean up old backups beyond retention count
-- PURPOSE: Maintain backup folder size by removing old backups
on cleanupOldBackups()
	try
		-- List all backup folders sorted by date (oldest first)
		set posixBackupFolder to POSIX path of BACKUP_BASE_FOLDER
		set listCmd to "find " & quoted form of posixBackupFolder & " -mindepth 1 -maxdepth 1 -type d | sort | head -n -" & BACKUP_RETENTION_COUNT
		
		set oldDirsOutput to do shell script listCmd & " 2>/dev/null || echo ''"
		
		-- Skip if no output or not enough backups to clean
		if oldDirsOutput is "" then
			return
		end if
		
		-- Split into lines
		set oldTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to return
		set oldDirs to text items of oldDirsOutput
		set AppleScript's text item delimiters to oldTID
		
		-- Remove each old directory
		repeat with oldDir in oldDirs
			if oldDir is not "" then
				my moduleLogInfo("BackupManager", "Removing old backup: " & oldDir)
				do shell script "rm -rf " & quoted form of oldDir
			end if
		end repeat
	on error errMsg
		my moduleLogError("BackupManager", "Error cleaning up old backups: " & errMsg)
	end try
end cleanupOldBackups

-- ================ SESSION MARKER MANAGEMENT ================
-- Detect if backup has already been checked in this session
on hasSessionBackupMarker()
	-- Get current session folder
	set sessionFolder to getCurrentSessionFolder()
	if sessionFolder is "" then
		my moduleLogError("BackupManager", "No valid session folder found, assuming no marker exists", 1)
		return false
	end if
	
	-- Check for marker file DIRECTLY without calling fileExists
	set markerPath to sessionFolder & "backup_complete.marker"
	my backupDebugLog("Checking for backup marker at: " & markerPath)
	
	-- Use System Events directly rather than calling another function
	try
		tell application "System Events"
			if exists file markerPath then
				my moduleLogInfo("BackupManager", "Backup marker found - backup already performed in this session")
				return true
			else
				my backupDebugLog("Backup marker not found - no backup has been performed in this session")
				return false
			end if
		end tell
	on error errMsg
		-- On any error, assume marker doesn't exist
		my moduleLogError("BackupManager", "Error checking session marker: " & errMsg)
		return false
	end try
end hasSessionBackupMarker

-- Read the last backup version from storage file with direct file check
on readLastBackupVersion()
	try
		-- Check if version file exists DIRECTLY
		tell application "System Events"
			if not (exists file BACKUP_VERSION_PATH) then
				my backupDebugLog("Version file does not exist at: " & BACKUP_VERSION_PATH)
				return ""
			end if
		end tell
		
		my backupDebugLog("Reading version from: " & BACKUP_VERSION_PATH)
		
		-- Use shell commands for more reliable file access
		try
			set posixPath to POSIX path of BACKUP_VERSION_PATH
			set lastVersion to do shell script "cat " & quoted form of posixPath & " 2>/dev/null || echo ''"
			
			if lastVersion is not "" then
				my backupDebugLog("Successfully read version: " & lastVersion)
				return lastVersion
			end if
		on error shellErr
			my moduleLogError("BackupManager", "Shell command error: " & shellErr)
			
			-- Fall back to direct file access as backup method
			try
				set versionFile to open for access file BACKUP_VERSION_PATH
				set lastVersion to read versionFile
				close access versionFile
				
				if lastVersion is not "" then
					my backupDebugLog("Successfully read version using direct access: " & lastVersion)
					return lastVersion
				end if
			on error directErr
				my moduleLogError("BackupManager", "Direct file access error: " & directErr)
				try
					close access versionFile
				end try
			end try
		end try
	on error errMsg
		my moduleLogError("BackupManager", "Error reading last backup version: " & errMsg)
	end try
	
	my backupDebugLog("No version found, returning empty string")
	return ""
end readLastBackupVersion

-- Create a session marker to prevent redundant backups in the same session
on createSessionBackupMarker(backupStatus)
	try
		-- Get current session folder
		my backupDebugLog("Getting current session folder for marker creation")
		set sessionFolder to getCurrentSessionFolder()
		if sessionFolder is "" then
			my moduleLogError("BackupManager", "Failed to get a valid session folder")
			return false
		end if
		
		-- Create marker file with status information
		set markerPath to sessionFolder & "backup_complete.marker"
		set markerContent to "Backup status: " & backupStatus & " at " & ((current date) as string)
		
		-- my backupDebugLog("Creating marker at: " & markerPath)
		
		-- Use shell command instead of direct file access
		set posixPath to POSIX path of markerPath
		do shell script "echo " & quoted form of markerContent & " > " & quoted form of posixPath
		
		my backupDebugLog("BackupManager", "Created session marker at: " & markerPath)
		return true
	on error errMsg
		my moduleLogError("BackupManager", "Error creating session marker: " & errMsg)
		return false
	end try
end createSessionBackupMarker

-- ================ BACKUP SYSTEM UTILITY FUNCTIONS ================
-- Get the folder containing the script
on getScriptFolder()
	try
		-- Try to get folder containing current script
		set scriptPath to path to me as string
		
		-- Extract path using basic string operations
		set ASTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to ":"
		set pathParts to text items of scriptPath
		
		-- Remove last item (script name)
		set lastItemIndex to count of pathParts
		set pathParts to items 1 thru (lastItemIndex - 1) of pathParts
		
		-- Rebuild path
		set AppleScript's text item delimiters to ":"
		set scriptFolder to pathParts as string
		if scriptFolder does not end with ":" then
			set scriptFolder to scriptFolder & ":"
		end if
		set AppleScript's text item delimiters to ASTID
		
		return scriptFolder
	on error getPathErr
		my moduleLogError("BackupManager", "Error determining script folder: " & getPathErr)
		
		-- Fallback to session folder or documents folder
		try
			global scriptFolder
			if scriptFolder is not "" and scriptFolder is not missing value then
				return scriptFolder
			end if
		end try
		
		-- Last resort - return documents folder
		return (path to documents folder as string)
	end try
end getScriptFolder

-- List all AppleScript files in a folder
on listScriptFiles(folderPath)
	set scriptFiles to {}
	
	try
		tell application "Finder"
			set fileList to every file of folder folderPath whose name extension is "scpt"
			
			repeat with aFile in fileList
				set filePath to (folderPath & name of aFile) as string
				set filename to name of aFile as string
				
				set end of scriptFiles to {name:filename, path:filePath}
			end repeat
		end tell
	on error errMsg
		my moduleLogError("BackupManager", "Error listing script files: " & errMsg)
	end try
	
	return scriptFiles
end listScriptFiles

-- Format timestamp for consistent file naming
on formatTimestamp(dateObj)
	set y to year of dateObj as string
	set m to text -2 thru -1 of ("0" & (month of dateObj as integer as string))
	set d to text -2 thru -1 of ("0" & (day of dateObj as string))
	set h to text -2 thru -1 of ("0" & (hours of dateObj as string))
	set min to text -2 thru -1 of ("0" & (minutes of dateObj as string))
	return y & "-" & m & "-" & d & "_" & h & "-" & min
	-- in case you need seconds, uncomment below and comment line above
	-- set s to text -2 thru -1 of ("0" & (seconds of dateObj as string))
	-- return y & "-" & m & "-" & d & "_" & h & "-" & min & "-" & s
end formatTimestamp

-- Get current session folder with multiple fallbacks
on getCurrentSessionFolder()
	-- Try to get from global variable first
	global scriptFolder
	
	-- Check if it looks like a session folder
	if scriptFolder is not "" and scriptFolder is not missing value and scriptFolder contains "Session_" then
		my backupDebugLog("Using current scriptFolder as session folder: " & scriptFolder)
		return scriptFolder
	end if
	
	-- If that fails, try to detect from the current log file path
	global logFilePath
	if logFilePath is not "" and logFilePath is not missing value then
		my backupDebugLog("Attempting to derive session folder from log file path: " & logFilePath)
		
		-- Extract the session path from the log path
		set logPathParts to my splitText(logFilePath, ":")
		set sessionPath to ""
		set foundSession to false
		
		-- Reconstruct the path up to the Session_ folder
		repeat with i from 1 to (count of logPathParts) - 2
			set part to item i of logPathParts
			if part contains "Session_" then
				set foundSession to true
			end if
			
			if sessionPath is "" then
				set sessionPath to part
			else
				set sessionPath to sessionPath & ":" & part
			end if
			
			-- Stop when we've included the session folder
			if foundSession and part contains "Session_" then
				set sessionPath to sessionPath & ":"
				exit repeat
			end if
		end repeat
		
		if foundSession then
			my backupDebugLog("Successfully derived session folder: " & sessionPath)
			return sessionPath
		end if
	end if
	
	-- Last resort: use the CCC Script folder
	my moduleLogInfo("BackupManager", "Falling back to default CCC Script folder")
	return (path to documents folder as string) & "CCC Script:"
end getCurrentSessionFolder

-- Get the date of the last backup
on getLastBackupDate()
	-- Default to a date in the past in case we can't determine the actual date
	set defaultDate to (current date) - (7 * days)
	
	-- Check if history file exists
	tell application "System Events"
		if not (exists file BACKUP_HISTORY_PATH) then
			return defaultDate
		end if
	end tell
	
	-- Read history file to get last backup date
	try
		-- Use shell command to get last line
		set posixPath to POSIX path of BACKUP_HISTORY_PATH
		set lastLineCmd to "tail -n 1 " & quoted form of posixPath
		set lastLine to do shell script lastLineCmd
		
		-- Extract date (format: "6.0.0-alpha3_2025-04-25_12-10-15 | date | reason")
		if lastLine contains " | " then
			set dateStart to offset of " | " in lastLine
			set afterDate to text (dateStart + 3) thru -1 of lastLine
			
			-- Extract until next pipe
			set nextPipePos to offset of " | " in afterDate
			if nextPipePos > 0 then
				set dateStr to text 1 thru (nextPipePos - 1) of afterDate
			else
				set dateStr to afterDate
			end if
			
			-- Try to parse date
			try
				set backupDate to date dateStr
				return backupDate
				
			on error dateErr
				my moduleLogError("BackupManager", "Error parsing date: " & dateErr)
				return defaultDate
			end try
		end if
	on error readErr
		my moduleLogError("BackupManager", "Error reading history file: " & readErr)
	end try
	
	-- If we get here, we couldn't get the date
	return defaultDate
end getLastBackupDate

-- Count existing backups in the backup folder
on countExistingBackups()
	try
		my backupDebugLog("Counting existing backup versions")
		
		-- Use shell command for reliability
		set posixPath to POSIX path of BACKUP_BASE_FOLDER
		set countCmd to "find " & quoted form of posixPath & " -mindepth 1 -maxdepth 1 -type d | wc -l"
		set countOutput to do shell script countCmd
		
		-- Parse result
		set backupCount to countOutput as number
		my moduleLogInfo("BackupManager", "Found " & backupCount & " existing backups")
		return backupCount
	on error errMsg
		my moduleLogError("BackupManager", "Error counting backups: " & errMsg)
		return 0
	end try
end countExistingBackups

-- Calculate disk space used by backups (in MB)
on getBackupSpaceUsed()
	try
		my backupDebugLog("Calculating disk space used by backups")
		
		-- Use shell command
		set posixPath to POSIX path of BACKUP_BASE_FOLDER
		set duCmd to "du -sm " & quoted form of posixPath & " | cut -f1"
		set duOutput to do shell script duCmd
		
		-- Parse result
		set spaceUsed to duOutput as number
		my moduleLogInfo("BackupManager", "Backup space used: " & spaceUsed & " MB")
		return spaceUsed
	on error errMsg
		my moduleLogError("BackupManager", "Error calculating backup space: " & errMsg)
		return 0
	end try
end getBackupSpaceUsed

-------------------------------------------------------------------------------
-- Handler: createVersionedBackup [CORE HANDLER - STABLE]
-- VERSION: 6.0.0-alpha40 (2025-05-21)
-- PURPOSE: Save a versioned backup (original/processed/vcard) for a contact,
--          in Contact Notes subfolder, using the proven (path as alias) fix.
--          Now uses Utilities' formatTimestamp for all date handling.
--          Shell script fallback for ultimate reliability.
-- RETURNS: {success:true/false, path:string, errorMessage:string}
-------------------------------------------------------------------------------
on createVersionedBackup(contactName, noteContent, noteType)
	global backupFolder, utilitiesScript
	set logPrefix to "createVersionedBackup(): "
	
	if noteContent is missing value then set noteContent to ""
	if noteType is missing value then set noteType to "original"
	
	-- 1. Ensure Contact Notes subfolder exists (shell, POSIX path, robust)
	set notesBackupFolder to backupFolder & "Contact Notes:"
	set notesBackupFolderPOSIX to POSIX path of notesBackupFolder
	try
		do shell script "mkdir -p " & quoted form of notesBackupFolderPOSIX
	on error mkErr
		my safeLog("Utilities", logPrefix & "Failed to create Contact Notes folder: " & mkErr, 0, missing value)
		return {success:false, errorMessage:"Failed to create Contact Notes backup folder: " & mkErr}
	end try
	
	-- 2. Prepare sanitized file name, using robust timestamp from Utilities
	set cleanName to my sanitizeFileName(contactName)
	set timestamp to ""
	try
		if utilitiesScript is not missing value then
			set timestamp to utilitiesScript's formatTimestamp(current date)
		else
			-- Fallback, always zero-padded
			set currentDate to current date
			set theYear to year of currentDate as string
			set theMonth to text -2 thru -1 of ("0" & (month of currentDate as integer))
			set theDay to text -2 thru -1 of ("0" & (day of currentDate as string))
			set theHour to text -2 thru -1 of ("0" & (hours of currentDate as string))
			set theMinute to text -2 thru -1 of ("0" & (minutes of currentDate as string))
			set theSecond to text -2 thru -1 of ("0" & (seconds of currentDate as string))
			set timestamp to theYear & "-" & theMonth & "-" & theDay & "_" & theHour & "-" & theMinute & "-" & theSecond
		end if
	end try
	set filename to cleanName & "_" & noteType & "_" & timestamp & ".txt"
	set backupPath to notesBackupFolder & filename
	
	-- my safeLog("Utilities", logPrefix & "Backup file path: " & backupPath, 2, missing value)
	
	-- 3. Attempt AppleScript file write using (path as alias)
	try
		do shell script "touch " & quoted form of (POSIX path of backupPath) -- Ensure file exists for alias coercion
		set fileAlias to backupPath as alias
		set fileRef to open for access fileAlias with write permission
		set eof of fileRef to 0
		write noteContent to fileRef as ¬´class utf8¬ª
		close access fileRef
		-- my safeLog("Utilities", logPrefix & "Backup created: " & backupPath, 1, missing value)
		return {success:true, path:backupPath, errorMessage:""}
	on error errMsg
		try
			close access fileAlias
		end try
		my safeLog("Utilities", logPrefix & "AppleScript write error, falling back to shell: " & errMsg, 0, missing value)
		
		-- 4. Fallback: Write with shell (as ultimate reliability net)
		try
			set posixBackupPath to POSIX path of backupPath
			do shell script "printf %s " & quoted form of noteContent & " > " & quoted form of posixBackupPath
			my safeLog("Utilities", logPrefix & "Shell backup created: " & posixBackupPath, 1, missing value)
			return {success:true, path:backupPath, errorMessage:""}
		on error shellErr
			my safeLog("Utilities", logPrefix & "Shell write error: " & shellErr, 0, missing value)
			return {success:false, errorMessage:"AppleScript and shell write failed: " & errMsg & " | " & shellErr}
		end try
	end try
end createVersionedBackup


-- ====
-- GENERIC TEXT / STRING / DATES PROCESSING HANDLERS
-- ====

-------------------------------------------------------------------------------
-- Handler: forceText
-- VERSION: 0.9.4-alpha (2025-05-23)
-- PURPOSE: Coerces input to text, never logs except on error.
-------------------------------------------------------------------------------
on forceText(val)
	try
		if (class of val is record) then
			try
				if val's text is not missing value then set val to val's text
			end try
		end if
		if (class of val is list) then
			set val to joinText(val, return) of utilitiesScript
		end if
		if (class of val is integer) or (class of val is real) or (class of val is boolean) then
			set val to val as text
		end if
		set val to val as text
		
		-- Check for empty string before text range operation
		if (length of val) > 0 then
			set val to text 1 thru (length of val) of val
		end if
		
		return val
	on error errMsg number errNum
		try
			moduleLogError("Utilities", "forceText ERROR: " & errMsg & " (num: " & (errNum as text) & ")")
		end try
		return ""
	end try
end forceText

on splitText(sourceText, delimiter)
	if (delimiter is missing value) then set delimiter to linefeed
	
	--  Preserve caller‚Äôs text‚Äëitem‚Äëdelimiter state
	set oldTIDs to AppleScript's text item delimiters
	try
		set AppleScript's text item delimiters to delimiter
		set segments to sourceText's text items
		if (segments is {}) then set segments to {sourceText} -- no split
	on error
		set segments to {sourceText} -- fall‚Äëback on any coercion error
	end try
	set AppleScript's text item delimiters to oldTIDs
	
	return segments
end splitText

-- =============================================================================
-- Handler: filterLinesStartingWith
-- VERSION: 1.0.0 (2025-07-08)
-- PURPOSE: Filter out lines that start with any of the specified prefixes
-- INPUTS:  linesList (list) - list of text lines
--          prefixList (list) - list of prefixes to filter out (e.g., {"--", "#", ""})
-- RETURNS: list - filtered list with lines starting with prefixes removed
-- NOTES:   Empty lines are filtered out when "" is in prefixList
--          Comparison is case-sensitive and checks exact prefix match
-- =============================================================================
on filterLinesStartingWith(lineList, prefixList)
	set outLines to {}
	repeat with aLine in lineList
		set keepIt to true
		repeat with p in prefixList
			if (aLine as text) starts with (p as text) then
				set keepIt to false
				exit repeat
			end if
		end repeat
		if keepIt then set end of outLines to aLine
	end repeat
	return outLines
end filterLinesStartingWith

-------------------------------------------------------------------------------
-- Handler: deduplicateFirstHalfRepeat
-- VERSION: 1.0.0-alpha (2025-05-24)
-- PURPOSE: If input is exactly X+X (no whitespace, even length), returns X.
--          Otherwise, returns original string.
-- INPUT: textLine (text)
-- OUTPUT: dedupedLine (text)
-------------------------------------------------------------------------------
on deduplicateFirstHalfRepeat(textLine)
	set t to textLine as text
	set txtLen to length of t
	if txtLen ‚â• 2 and (txtLen mod 2 = 0) then
		set halfLen to txtLen div 2
		set firstHalf to text 1 thru halfLen of t
		set secondHalf to text (halfLen + 1) thru -1 of t
		if firstHalf = secondHalf then
			return firstHalf
		end if
	end if
	return t
end deduplicateFirstHalfRepeat


-------------------------------------------------------------------------------
-- Handler: splitByMultipleDelimiters
-- VERSION: 0.9.2-alpha (2025-05-23)
-- PURPOSE: 
--   Splits inputText at each occurrence of any marker in markerList.
--   Only logs on error/abort, never per split.
-- INPUT: inputText (text), markerList (list of text)
-- OUTPUT: resultBlocks (list of text)
-- CHANGELOG:
--   0.9.2-alpha (2025-05-23): Infinite loop protection, minimal logging, robust output.
-------------------------------------------------------------------------------
on splitByMultipleDelimiters(inputText, markerList)
	set resultBlocks to {}
	set scanText to inputText
	set loopCounter to 0
	repeat
		set loopCounter to loopCounter + 1
		if (loopCounter > 10000) then
			log "ABORTING: splitByMultipleDelimiters exceeded 10,000 iterations!"
			exit repeat
		end if
		set earliestOffset to 0
		set foundMarker to ""
		repeat with m in markerList
			set mText to m as text
			set mOffset to offset of mText in scanText
			if (mOffset > 0) and ((earliestOffset = 0) or (mOffset < earliestOffset)) then
				set earliestOffset to mOffset
				set foundMarker to mText
			end if
		end repeat
		if (earliestOffset = 0) then
			exit repeat
		else
			set blockEnd to earliestOffset + (length of foundMarker) - 1
			set block to text 1 thru blockEnd of scanText
			set end of resultBlocks to block
			if blockEnd < (length of scanText) then
				set scanText to text (blockEnd + 1) thru -1 of scanText
			else
				set scanText to ""
				exit repeat
			end if
		end if
	end repeat
	if (scanText ‚â† "") then set end of resultBlocks to scanText
	return resultBlocks
end splitByMultipleDelimiters

-- Strips leading/trailing spaces, tabs, and line breaks from input string.
-------------------------------------------------------------------------------
on trimText(theText)
	set theText to theText as text
	repeat while theText begins with " " or theText begins with tab or theText begins with linefeed or theText begins with return
		set theText to text 2 thru -1 of theText
		if theText = "" then exit repeat
	end repeat
	repeat while theText ends with " " or theText ends with tab or theText ends with linefeed or theText ends with return
		set theText to text 1 thru -2 of theText
		if theText = "" then exit repeat
	end repeat
	return theText
end trimText

-- Split text into a list of words, handling space, tab, CR, LF
on getWordList(someText)
	set tempText to someText
	set tempText to my replaceText(tempText, return, " ")
	set tempText to my replaceText(tempText, linefeed, " ")
	set tempText to my replaceText(tempText, tab, " ")
	set oldDelims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to " "
	set wordList to text items of tempText
	set AppleScript's text item delimiters to oldDelims
	set cleanedList to {}
	repeat with w in wordList
		if (w as string) is not "" then set end of cleanedList to w
	end repeat
	return cleanedList
end getWordList

-- Join list of words into a single string, space-separated
on joinWordList(wordList)
	set oldDelims to AppleScript's text item delimiters
	set AppleScript's text item delimiters to " "
	set result to wordList as text
	set AppleScript's text item delimiters to oldDelims
	return result
end joinWordList

(*
    replaceText ¬∑ Utilities ‚Äî canonical helper (3‚Äëparam, case‚Äësensitive)
*)
on replaceText(sourceText, searchToken, replacement)
	if sourceText is missing value then return ""
	if searchToken is missing value or searchToken = "" then return sourceText
	if replacement is missing value then set replacement to ""
	
	-- preserve caller‚Äôs TIDs
	set oldTIDs to AppleScript's text item delimiters
	try
		set AppleScript's text item delimiters to searchToken
		set segments to text items of (sourceText as string)
		set AppleScript's text item delimiters to replacement
		set outText to segments as text
	on error errMsg
		try
			directFileLog("Utilities", "replaceText error: " & errMsg, 1)
		end try
		set outText to sourceText
	end try
	set AppleScript's text item delimiters to oldTIDs
	return outText
end replaceText

-------------------------------------------------------------------------------
-- Handler: stripAllWhitespace
-- VERSION: 1.0.0 (2025-06-06)
-- PURPOSE: Remove all CR, LF, tab, space, non-breaking space from a text,
--          for robust glue-point/duplication detection. Keeps case and punctuation.
-- INPUT: theText (text)
-- OUTPUT: text with all whitespace removed
-------------------------------------------------------------------------------
on stripAllWhitespace(theText)
	set t to theText
	set t to my replaceText(t, return, "")
	set t to my replaceText(t, linefeed, "")
	set t to my replaceText(t, tab, "")
	set t to my replaceText(t, " ", "")
	set t to my replaceText(t, (character id 160), "")
	return t
end stripAllWhitespace

-------------------------------------------------------------------------------
-- Handler: findNthNonWhitespaceIdx
-- VERSION: 1.0.0 (2025-06-06)
-- PURPOSE: Return character position of the Nth non-whitespace char in t.
-- INPUTS: t (text), n (integer)
-- OUTPUT: integer index
-------------------------------------------------------------------------------
on findNthNonWhitespaceIdx(t, n)
	set count to 0
	repeat with i from 1 to length of t
		set c to character i of t
		if c is not in {" ", return, linefeed, tab, (character id 160)} then
			set count to count 1
		end if
		if (count) = n then return i
	end repeat
	return length of t -- fallback: end
end findNthNonWhitespaceIdx


-------------------------------------------------------------------------------
-- Handler: collapseMultipleBlankLines
-- VERSION: 0.9.0 alpha2 (2025-05-19)
-- PURPOSE: Collapse all occurrences of 2 or more blank lines into a single blank line.
--          Also trims leading/trailing blank lines.
-- NOTE:    For contact note processing, use preserveSingleBlankLines() instead
--          to preserve intentional single blank line formatting.
-- USE CASE: Reports, exports, final cleanup where aggressive collapsing is desired
-------------------------------------------------------------------------------
on collapseMultipleBlankLines(theText)
	try
		-- Collapse all 3+ blank lines to 2, then all 2+ blank lines to 1
		set prevLen to -1
		set txt to theText as text
		repeat while prevLen ‚â† (length of txt)
			set prevLen to length of txt
			set txt to my utilitiesScript's replaceText(txt, return & return & return, return & return)
		end repeat
		-- Now collapse all 2 blank lines to 1
		set prevLen to -1
		repeat while prevLen ‚â† (length of txt)
			set prevLen to length of txt
			set txt to my utilitiesScript's replaceText(txt, return & return, return)
		end repeat
		-- Trim leading blank lines
		repeat while txt begins with return or txt begins with linefeed
			set txt to text 2 thru -1 of txt
		end repeat
		-- Trim trailing blank lines
		repeat while txt ends with return or txt ends with linefeed
			set txt to text 1 thru -2 of txt
		end repeat
		return txt
	on error
		return theText
	end try
end collapseMultipleBlankLines

-- ============================================
-- Handler: parseLocaleNumber  
-- VERSION: 0.9.9-manual-parse (2025-07-03)
-- PURPOSE: MANUAL PARSING - Bypass AppleScript locale coercion entirely
-- ============================================
on parseLocaleNumber(numberText)
	if numberText is missing value or numberText is "" then return 0.0
	
	try
		set inputText to numberText as string
		set inputText to my replaceText(inputText, " ", "")
		
		-- Find decimal separator position
		set decimalPos to 0
		set foundComma to false
		set foundDot to false
		
		repeat with i from (length of inputText) to 1 by -1
			set char to character i of inputText
			if char is "," and not foundComma then
				set decimalPos to i
				set foundComma to true
				exit repeat
			else if char is "." and not foundDot then
				set decimalPos to i
				set foundDot to true
				exit repeat
			end if
		end repeat
		
		-- Split into integer and decimal parts
		if decimalPos > 0 then
			set integerPart to text 1 thru (decimalPos - 1) of inputText
			set decimalPart to text (decimalPos + 1) thru -1 of inputText
			
			-- Remove any remaining separators from integer part
			set integerPart to my replaceText(integerPart, ",", "")
			set integerPart to my replaceText(integerPart, ".", "")
			
			-- Build final number manually
			set integerValue to integerPart as integer
			set decimalValue to decimalPart as integer
			set decimalPlaces to length of decimalPart
			
			-- Calculate final result
			set result to integerValue + (decimalValue / (10 ^ decimalPlaces))
			return result
		else
			-- No decimal point - treat as integer
			set cleanInteger to my replaceText(inputText, ",", "")
			set cleanInteger to my replaceText(cleanInteger, ".", "")
			return cleanInteger as integer
		end if
		
	on error parseErr
		my moduleLogError("Utilities", "parseLocaleNumber manual parse failed on: " & numberText & " - " & parseErr)
		return 0.0
	end try
end parseLocaleNumber

-------------------------------------------------------------------------------
--  formatNumber(num, decimals)           ‚ñ∏  PUBLIC  (NEW)
--  Returns theNumber as text, rounded to *decimals* places,
--  locale-safe (always ‚Äú.‚Äù) and zero-padded.
-------------------------------------------------------------------------------
on formatNumber(theValue, decimals)
	try
		if decimals < 0 then set decimals to 0
		set factor to (10 ^ decimals)
		set rounded to (round (theValue * factor)) / factor
		
		-- Coerce to text and normalise decimal separator
		set txt to rounded as text
		set txt to my replaceText(txt, ",", ".")
		
		-- Ensure we have a dot when decimals > 0
		if decimals > 0 then
			if txt does not contain "." then set txt to txt & "."
			
			-- Pad with zeros on the right
			set dotPos to offset of "." in txt
			set currentDecimals to (length of txt) - dotPos
			repeat while currentDecimals < decimals
				set txt to txt & "0"
				set currentDecimals to currentDecimals + 1
			end repeat
		end if
		
		return txt
	on error errMsg
		my moduleLogWarning("Utilities", "formatNumber failed: " & errMsg)
		return theValue as text
	end try
end formatNumber

-- Helper: Get minimum of a list of numbers
on minOfList(numList)
	set minVal to item 1 of numList
	repeat with n in numList
		if n < minVal then set minVal to n
	end repeat
	return minVal
end minOfList

-- ============================================
-- Handler: joinText
-- VERSION: 0.9.0-alpha3 (2025-05-21)
-- PURPOSE: Join a list of items into text using the given delimiter, with full
--          logging and bulletproof type conversion.
-- CHANGELOG:
--   - 0.9.0-alpha3: Forces all items to string, logs what is joined and result.
-- ============================================
on joinText(theList, theDelimiter)
	try
		-- Save original delimiters
		set oldDelimiters to AppleScript's text item delimiters
		
		-- Defensive: force all items to text, handle missing value
		set cleanedList to {}
		repeat with i from 1 to (count of theList)
			set thisItem to item i of theList
			if thisItem is missing value then
				set end of cleanedList to ""
			else
				set end of cleanedList to (thisItem as text)
			end if
		end repeat
		
		-- my moduleLogDebug("Utilities", "[joinText] Joining " & (count of cleanedList) & " items, delimiter='" & theDelimiter)
		
		-- Join using the delimiter
		set AppleScript's text item delimiters to theDelimiter
		set theText to cleanedList as text
		
		-- Restore original delimiters
		set AppleScript's text item delimiters to oldDelimiters
		
		return theText
	on error errMsg
		set AppleScript's text item delimiters to oldDelimiters
		my moduleLogError("Utilities", "[joinText] ERROR message:" & errMsg)
		return ""
	end try
end joinText

-- Safely convert a list to string with proper error handling
on listToString(aList, delimiter)
	-- Ensure inputs are of correct type
	if aList is missing value then return ""
	
	try
		-- Direct handling of simple lists
		set resultString to ""
		repeat with i from 1 to count of aList
			-- Add the item with careful type handling
			try
				set thisItem to item i of aList as string
				if i > 1 then
					set resultString to resultString & delimiter & thisItem
				else
					set resultString to thisItem
				end if
			on error
				-- If an item can't be converted, skip it
				my moduleLogError("Utilities", "Could not convert list item to string, skipping")
			end try
		end repeat
		return resultString
	on error errMsg
		my moduleLogError("Utilities", "Error in listToString: " & errMsg)
		return ""
	end try
end listToString

-- Remove leading and trailing whitespace with robust handling
on trimWhitespace(theText)
	-- Check for empty string
	if theText is "" then return ""
	
	-- Trim leading whitespace
	set trimmedText to theText
	set textLength to length of trimmedText
	set startIndex to 1
	
	repeat while startIndex ‚â§ textLength
		set firstChar to text startIndex thru startIndex of trimmedText
		if firstChar is not " " and firstChar is not tab and firstChar is not linefeed and firstChar is not return then
			exit repeat
		end if
		set startIndex to startIndex + 1
	end repeat
	
	if startIndex > textLength then
		-- String was all whitespace
		return ""
	end if
	
	-- Trim trailing whitespace
	set endIndex to textLength
	
	repeat while endIndex ‚â• startIndex
		set lastChar to text endIndex thru endIndex of trimmedText
		if lastChar is not " " and lastChar is not tab and lastChar is not linefeed and lastChar is not return then
			exit repeat
		end if
		set endIndex to endIndex - 1
	end repeat
	
	-- Extract the trimmed portion
	return text startIndex thru endIndex of trimmedText
end trimWhitespace

-- Trim all leading returns from a text block
on trimLeadingReturns(txt as text)
	repeat while txt begins with return
		set txt to text 2 thru -1 of txt
	end repeat
	return txt
end trimLeadingReturns

-------------------------------------------------------------------------------
-- Handler: normalizeForBlockSearch
-- VERSION: 1.0.0 (2025-06-09)
-- PURPOSE: Replace all carriage returns and linefeeds in a string with spaces.
-------------------------------------------------------------------------------
on normalizeForBlockSearch(rawText)
	set t to rawText as text
	set t to my replaceText(t, return, " ")
	set t to my replaceText(t, linefeed, " ")
	return t
end normalizeForBlockSearch

-------------------------------------------------------------------------------
-- Handler: findAllIndices
-- VERSION: 1.0.0 (2025-06-09)
-- PURPOSE: Find all indices (character offsets) of a substring within a string.
-------------------------------------------------------------------------------
on findAllIndices(sourceText, searchText)
	set indices to {}
	set src to sourceText as text
	set sText to searchText as text
	set searchPos to 1
	repeat
		set idx to offset of sText in (text searchPos thru -1 of src)
		if idx = 0 then exit repeat
		set idx to idx + searchPos - 1
		set end of indices to idx
		set searchPos to idx + 1
		if searchPos > (length of src) then exit repeat
	end repeat
	return indices
end findAllIndices

-------------------------------------------------------------------------------
-- Handler: safeSubstring
-- VERSION: 1.0.0 (2025-06-09)
-- PURPOSE: Safely extracts a substring, adjusting out-of-bounds indices.
-------------------------------------------------------------------------------
on safeSubstring(sourceText, startIdx, endIdx)
	set t to sourceText as text
	set lenT to length of t
	set sIdx to startIdx
	set eIdx to endIdx
	if sIdx < 1 then set sIdx to 1
	if eIdx > lenT then set eIdx to lenT
	if sIdx > eIdx then return ""
	return text sIdx thru eIdx of t
end safeSubstring

-- ============================================
-- Handler: indexOfItem
-- VERSION: 1.0.0-revamp (2025-07-07)
-- PURPOSE: Find index of item in list (helper for menu dispatchers)
-- INPUTS:  targetItem (text) - item to find
--          searchList (list) - list to search in
-- RETURNS: integer - index of item (0 if not found)
-- NOTES:   Used by navigation dispatcher pattern
-- ============================================
on indexOfItem(targetItem, searchList)
	repeat with i from 1 to count of searchList
		if item i of searchList is targetItem then return i
	end repeat
	return 0
end indexOfItem

-- =============================================================================
-- Handler: sortList
-- VERSION: 1.0.0 (2025-07-15)
-- PURPOSE: Simple alphabetical sort for small lists
-- INPUTS:  theList - list to sort
-- RETURNS: list - sorted copy of the list
-- =============================================================================
on sortList(theList)
	-- Create a copy to avoid modifying original
	set sortedList to theList
	
	-- Bubble sort (adequate for small lists of groups)
	repeat with i from 1 to (count of sortedList) - 1
		repeat with j from i + 1 to count of sortedList
			if item i of sortedList > item j of sortedList then
				set temp to item i of sortedList
				set item i of sortedList to item j of sortedList
				set item j of sortedList to temp
			end if
		end repeat
	end repeat
	
	return sortedList
end sortList

-- ============================================
-- Utilities ‚Ä¢ Stats‚ÄëText Parsing Helpers   ‚ù¨NEW¬†2025‚Äë07‚Äë07 fix 2025 sept 7‚ù≠
-- VERSION: 0.9.9.5
-- PURPOSE: Convert between flat‚Äëtext ‚Äúkey : value‚Äù metrics and AppleScript
--          records. Shared by cumulative statistics, performance history, etc.
-- DEPENDS: splitText, trimWhitespace, replaceText, joinText,
--          recordKeys, parseLocaleNumber (utilities.txt)
-- ============================================

on statsTextToRecord(theText)
	global utilitiesScript
	set handlerName to "statsTextToRecord"
	utilitiesScript's moduleLogDebug("Utilities", handlerName & " ‚Äì parsing text‚Ä¶")
	
	-- Default structure
	set outRec to {totalContacts:0, totalChars:0, totalKB:0, avgCharsPerContact:0, percentSaved:0}
	if theText is missing value or theText = "" then return outRec
	
	-- FIX: Quick pre-process for known legacy issue
	-- Replace the specific malformed pattern
	set fixedText to utilitiesScript's replaceText(theText, "1,0Total Characters", "1" & return & "Total Characters")
	set fixedText to utilitiesScript's replaceText(fixedText, "2,0Total Characters", "2" & return & "Total Characters")
	set fixedText to utilitiesScript's replaceText(fixedText, ",0Total", return & "Total")
	
	-- Split lines with existing helper
	set lineList to utilitiesScript's splitText(fixedText, return)
	
	repeat with L in lineList
		set tLine to utilitiesScript's trimWhitespace(L)
		if tLine ‚â† "" and tLine does not start with "#" and tLine does not start with "--" then
			if tLine contains ":" then
				try -- Wrap in try to handle any parsing errors
					set AppleScript's text item delimiters to ":"
					set {kRaw, vRaw} to text items 1 thru 2 of tLine
					set kClean to utilitiesScript's trimWhitespace(kRaw)
					set vNum to utilitiesScript's parseLocaleNumber(utilitiesScript's trimWhitespace(vRaw))
					if vNum is missing value then set vNum to 0
					
					if kClean begins with "Total Contacts" then
						set outRec's totalContacts to vNum as integer -- Force integer
					else if kClean begins with "Total Characters" then
						set outRec's totalChars to vNum as integer -- Force integer
					else if kClean begins with "Total KB" then
						set outRec's totalKB to vNum
					else if kClean begins with "Average" then
						set outRec's avgCharsPerContact to vNum
					else if kClean begins with "Percent" then
						set outRec's percentSaved to vNum
					end if
				on error
					-- Skip this line if parsing fails
				end try
			end if
		end if
	end repeat
	
	utilitiesScript's moduleLogDebug("Utilities", handlerName & " ‚Äì OK")
	return outRec
end statsTextToRecord


-- Fixed version with correct logging (sept 7th 2025 update)
on statsRecordToText(statsRec, orderedKeys)
	global utilitiesScript
	set handlerName to "statsRecordToText"
	
	if class of statsRec is not record then
		my moduleLogWarning("Utilities", handlerName & " ‚Äì input is not a record; returning empty text")
		return ""
	end if
	
	-- Define the keys we know about in order
	if orderedKeys is missing value then
		set keyList to {"totalContacts", "totalChars", "totalKB", "avgCharsPerContact", "percentSaved"}
	else
		set keyList to orderedKeys
	end if
	
	set outLines to {}
	
	repeat with k in keyList
		try
			-- Use explicit property access instead of dynamic
			if k as text is "totalContacts" then
				set v to statsRec's totalContacts
				-- FIX 1: Force integer for contacts
				set v to v as integer
				set end of outLines to ("Total Contacts : " & v)
				
			else if k as text is "totalChars" then
				set v to statsRec's totalChars
				-- FIX 2: Force integer for characters
				set v to v as integer
				set end of outLines to ("Total Characters : " & v)
				
			else if k as text is "totalKB" then
				set v to statsRec's totalKB
				set end of outLines to ("Total KB : " & (v as text))
				
			else if k as text is "avgCharsPerContact" then
				set v to statsRec's avgCharsPerContact
				set end of outLines to ("Average Characters Per Contact : " & (v as text))
				
			else if k as text is "percentSaved" then
				set v to statsRec's percentSaved
				set end of outLines to ("Percent Saved : " & (v as text))
			end if
			
		on error keyErr
			my moduleLogDebug("Utilities", handlerName & " ‚Äì key '" & k & "' not found: " & keyErr)
		end try
	end repeat
	
	-- FIX 3: Ensure proper line joining
	set oldTIDs to AppleScript's text item delimiters
	try
		-- Use explicit return character
		set AppleScript's text item delimiters to return
		set outText to outLines as text
	on error
		-- Fallback to manual joining
		set outText to ""
		repeat with i from 1 to count of outLines
			if i > 1 then set outText to outText & return
			set outText to outText & (item i of outLines)
		end repeat
	end try
	set AppleScript's text item delimiters to oldTIDs
	
	my moduleLogInfo("Utilities", handlerName & " ‚Äì generated " & (count of outLines) & " lines of stats text")
	
	return outText
end statsRecordToText

-------------------------------------------------------------------------------
-- Handler: setLogLevel
-- VERSION: 0.9.9 (2025-06-24)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Authoritative setter for log level with phase-aware logging
-- CHANGE: Added startup phase detection to prevent logging during initialization
-- WHY:    setLogLevel() was logging "Log level now X" during startup, violating single-buffer
-- WHEN:   Called during configuration setup and runtime level changes
-- HOW:    Checks loggingActive flag to stay silent during startup
-- BREAKS:  Nothing - maintains same functionality, eliminates startup logging
-------------------------------------------------------------------------------
on setLogLevel(newLevel)
	global loggingActive -- Phase detection for single-buffer approach
	
	-- Coerce & clamp (unchanged logic)
	try
		if newLevel as integer ‚â§ kLogLevelError then
			set logLevel to kLogLevelError
		else if newLevel as integer ‚â• kLogLevelDebug then
			set logLevel to kLogLevelDebug
		else
			set logLevel to newLevel as integer
		end if
	on error
		-- default to INFO on bad input
		set logLevel to kLogLevelInfo
	end try
	
	-- mirror shadow variables used during early init (unchanged)
	set gLogLevel to logLevel
	
	-- PHASE-AWARE LOGGING: Only log during runtime phase
	try
		if loggingActive is true then
			-- RUNTIME PHASE: Normal logging allowed
			my safeLog(MODULE_NAME, "Log level now " & logLevel, kLogLevelDebug, missing value)
		else
			-- STARTUP PHASE: Silent operation - ContactManager will log configuration success
		end if
	on error
		-- Fallback: if loggingActive undefined, assume startup phase and stay silent
	end try
	
	return logLevel
end setLogLevel

-------------------------------------------------------------------------------
--  setDebugMode(isDebug) ‚Ä¢ convenience toggle (true¬†‚á¢¬†DEBUG¬†/¬†false¬†‚á¢¬†INFO)
-------------------------------------------------------------------------------
on setDebugMode(isDebug)
	if isDebug then
		setLogLevel(kLogLevelDebug)
	else
		setLogLevel(kLogLevelInfo)
	end if
	return true
end setDebugMode

-- Get the last recorded version from history
on getLastRecordedVersion()
	-- Try multiple locations for the history file
	set historyPath to ""
	
	-- Try session folder first
	set sessionFolder to getCurrentSessionFolder()
	if sessionFolder is not "" then
		set sessionHistoryPath to sessionFolder & "script_versions.history"
		if my fileExists(sessionHistoryPath) then
			set historyPath to sessionHistoryPath
		end if
	end if
	
	-- Fall back to standard location
	if historyPath is "" then
		set standardHistoryPath to (path to documents folder as string) & "CCC Script:script_versions.history"
		if my fileExists(standardHistoryPath) then
			set historyPath to standardHistoryPath
		end if
	end if
	
	-- If no history file found
	if historyPath is "" then
		log "No version history file found"
		return ""
	end if
	
	try
		-- Use shell command to get the last line (more reliable)
		set posixPath to POSIX path of historyPath
		set lastLine to do shell script "tail -n 1 " & quoted form of posixPath
		
		-- Extract version from line like "6.0.0-alpha3_2025-04-25_10-59-53 | date"
		if lastLine contains "_" then
			set versionEnd to offset of "_" in lastLine
			set versionPart to text 1 thru (versionEnd - 1) of lastLine
			
			log "Last recorded version: " & versionPart
			return versionPart
		end if
	on error errMsg
		log "Error getting last recorded version: " & errMsg
		return ""
	end try
	
	return ""
end getLastRecordedVersion

-- Reliably detect the folder containing script modules
on getModulesFolder()
	try
		-- Get script path
		set myPath to path to me as string
		
		-- Extract path using basic string operations
		set ASTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to ":"
		set pathParts to text items of myPath
		
		-- Remove last item (script name)
		set lastItemIndex to count of pathParts
		set pathParts to items 1 thru (lastItemIndex - 1) of pathParts
		
		-- Rebuild path
		set AppleScript's text item delimiters to ":"
		set modulesFolder to pathParts as string
		if modulesFolder does not end with ":" then
			set modulesFolder to modulesFolder & ":"
		end if
		set AppleScript's text item delimiters to ASTID
		
		return modulesFolder
	on error getPathErr
		log "Error determining modules folder: " & getPathErr
		
		-- Last resort: try to use the script folder global variable
		global scriptFolder
		if scriptFolder is not "" and scriptFolder is not missing value then
			return scriptFolder
		else
			-- Absolute last resort: return documents folder
			return (path to documents folder as string)
		end if
	end try
end getModulesFolder

-------------------------------------------------------------------------------
-- Handler: escalateToDebugMode
-- VERSION: 0.9.10 (2025-06-26)
-- PURPOSE: Centralized, single-call handler for auto-escalating all logging to DEBUG
--           when error threshold is hit. Emits visible milestone, synchronizes modules.
-- INPUTS:   escalationReason (text, optional) ‚Äì extra context for log message
-- OUTPUT:   true if escalation performed, false if already escalated
-- USAGE:    Call from error-logging after LOG_ESCALATE_AFTER_ERRORS is exceeded.
-------------------------------------------------------------------------------
on escalateToDebugMode(escalationReason)
	-- Prevent double escalation
	if my autoEscalated is true then return false
	
	-- Set escalation flags (properties only)
	set my autoEscalated to true
	set my logLevel to my kLogLevelDebug
	
	-- Milestone log entry: both session log and console
	set logMsg to "Log level auto-escalated to DEBUG for this session (" & (my consecutiveErrorCount as string) & " errors"
	if escalationReason is not missing value and escalationReason is not "" then
		set logMsg to logMsg & ": " & escalationReason
	end if
	set logMsg to logMsg & ")"
	my milestoneLog("Utilities", logMsg)
	
	-- Attempt to notify peer modules to synchronize debugMode/logLevel
	try
		if (myContactManager is not missing value) then
			myContactManager's synchronizeLogSettings()
		end if
	end try
	try
		if (myContactOperations is not missing value) then
			myContactOperations's synchronizeLogSettings()
		end if
	end try
	-- (If missing, document in module header and log a warning)
	
	return true
end escalateToDebugMode



-- ==============================================
-- GENERIC FILE & FOLDER PROCESSING HANDLERS + PATH MANAGEMENT
-- ==============================================

-- ================================================================
-- Handler: createFolderPath
-- VERSION: 6.0.0-alpha29 (2025-05-18)
-- PURPOSE: Robust, recursive creation of any folder path using Finder,
--          with shell fallback. Canonical folder creation for entire project.
-- ================================================================
on createFolderPath(folderPath)
	try
		-- Use Finder to recursively build folder
		tell application "Finder"
			if exists folder folderPath then
				my safeLog("Utilities", "createFolderPath found Folder already exists: " & folderPath, 2, missing value)
				return true
			end if
			
			set pathComponents to my splitText(folderPath, ":")
			set currentPath to ""
			repeat with i from 1 to count of pathComponents
				set component to item i of pathComponents
				if component is not "" then
					if currentPath is "" then
						set currentPath to component
					else
						set currentPath to currentPath & ":" & component
					end if
					if not (exists folder currentPath) then
						if i > 1 then
							set parentComponents to items 1 thru (i - 1) of pathComponents
							set parentPath to my joinText(parentComponents, ":")
							make new folder at parentPath with properties {name:component}
						else
							make new folder at (path to desktop) with properties {name:component}
						end if
					end if
				end if
			end repeat
			return true
		end tell
	on error errMsg
		my safeLog("Utilities", "createFolderPath error (Finder): " & errMsg, 0, missing value)
		try
			set posixPath to POSIX path of folderPath
			do shell script "mkdir -p " & quoted form of posixPath
			my safeLog("Utilities", "createFolderPath used shell fallback: " & posixPath, 1, missing value)
			return true
		on error shellErr
			my safeLog("Utilities", "createFolderPath shell fallback failed: " & shellErr, 0, missing value)
			return false
		end try
	end try
end createFolderPath

-- ==============================================
-- Helper: Sanitize file names (no special chars)
-- ==============================================
on sanitizeFileName(theName)
	set forbiddenChars to {":", "/", "\\", "*", "?", "\"", "<", ">", "|"}
	set cleanName to theName
	repeat with badChar in forbiddenChars
		set AppleScript's text item delimiters to badChar
		set cleanName to text items of cleanName as string
		set AppleScript's text item delimiters to ""
	end repeat
	-- Collapse multiple spaces and trim
	set AppleScript's text item delimiters to " "
	set cleanName to text items of cleanName as string
	set AppleScript's text item delimiters to " "
	return cleanName
end sanitizeFileName

on fileExists(pathRef)
	-- Optional DEBUG audit
	if (my logLevel ‚â§ my kLogLevelDebug) then my moduleLogDebug(MODULE_NAME, "Checking if file exists: " & pathRef)
	
	try
		--  The coercion to alias succeeds only if the item truly exists.
		set _ to (pathRef as alias)
		
		if (my logLevel ‚â§ my kLogLevelDebug) then my moduleLogDebug(MODULE_NAME, "File exists: " & pathRef)
		return true
		
	on error errMsg
		-- Any error means the path is missing or malformed.
		if (my logLevel ‚â§ my kLogLevelDebug) then my moduleLogDebug(MODULE_NAME, "File does not exist / error: " & errMsg)
		return false
	end try
end fileExists

-- ADDED: Extract filename from a full path
-- VERSION: 6.0.0-alpha15 (2025-04-28)
-- PURPOSE: Helper to get just the filename part from a full path
on getFilenameFromPath(fullPath)
	-- Find the last colon in the path
	set lastColonPos to 0
	repeat with i from (length of fullPath) to 1 by -1
		if character i of fullPath is ":" then
			set lastColonPos to i
			exit repeat
		end if
	end repeat
	
	-- Extract the filename part
	if lastColonPos > 0 then
		return text (lastColonPos + 1) thru -1 of fullPath
	else
		-- Fallback if no colon found
		return fullPath
	end if
end getFilenameFromPath

-- ============================================
-- Handler: saveTextToFile (FIXED - Using Proven Pattern)
-- VERSION: 1.1.0-file-creation (2025-07-04) - Uses proven touch pattern
-- PURPOSE: Enhanced saveTextToFile using the same pattern as createVersionedBackup
-- ============================================
on saveTextToFile(theText, hfsPath)
	try
		-- Try if file exists
		set fileAlias to (hfsPath as alias)
	on error
		-- File doesn't exist, create it using the PROVEN PATTERN from createVersionedBackup
		my moduleLogDebug("Utilities", "saveTextToFile will create: " & hfsPath & " as it was not found and does not exist yet")
		-- ToDo : investigate why this message appears on top of console Log
		
		-- ‚úÖ USE THE EXACT SAME PATTERN AS createVersionedBackup() and saveReportToFile()
		do shell script "touch " & quoted form of (POSIX path of hfsPath)
		set fileAlias to (hfsPath as alias)
	end try
	
	-- Write using alias (proven method)
	try
		set fRef to open for access fileAlias with write permission
		set eof of fRef to 0
		write theText as ¬´class utf8¬ª to fRef
		close access fRef
		return true
		
	on error errMsg
		try
			close access fRef
		end try
		my moduleLogError("Utilities", "saveTextToFile failed: " & errMsg)
		return false
	end try
end saveTextToFile

-------------------------------------------------------------------------------
--  ‚ú¶  Helper: appendLineToFile(filePath, lineText) ‚Üí boolean
--  VERSION: 6.0.0-alpha25+historyRefactor (2025-05-15)
--  PURPOSE: Append `lineText` plus a trailing LF to `filePath`, creating
--           the file if it doesn‚Äôt exist. Logs and returns false on failure.
-------------------------------------------------------------------------------
on appendLineToFile(filePath as text, lineText as text)
	try
		set fRef to open for access filePath with write permission
		write (lineText & return) to fRef starting at eof
		close access fRef
		return true
	on error errMsg
		try
			close access fRef
		end try
		my safeLog("Utilities", "appendLineToFile failed: " & errMsg, kLogLevelError, missing value)
		return false
	end try
end appendLineToFile

-- ============================================
-- Handler: readTextFile
-- VERSION: 1.0.0 (2025‚Äë07‚Äë07)
-- PURPOSE: Safely read an entire UTF‚Äë8 file and return {success:bool, text:str}.
-- INPUTS:  hfsPath (string) ‚Äì HFS path to file (may be posix‚Äëconverted first).
-- RETURNS: record {success:boolean, text:string}
-- NOTES:   ‚Ä¢ Shields callers from ‚Äòfile not found‚Äô & encoding errors.
--          ‚Ä¢ Always closes access handle, even on failure.
-- ============================================
on readTextFile(hfsPath)
	try
		-- Check if file exists first
		tell application "System Events"
			if not (exists file hfsPath) then return {success:false, text:""}
		end tell
	end try
	try
		set theAlias to (hfsPath as alias)
		set fRef to open for access theAlias
		set t to read fRef as ¬´class utf8¬ª
		close access fRef
		return {success:true, text:t}
	on error errMsg number errNum
		try
			close access file hfsPath -- just in case
		end try
		my moduleLogWarning("Utilities", "readTextFile failed (" & errNum & "): " & errMsg)
		return {success:false, text:""}
	end try
end readTextFile

-------------------------------------------------------------------------------
-- Handler: getBaseCCCFolder
-- VERSION: 1.0.0 (2025‚Äë07‚Äë07)
-- PURPOSE: Return the canonical base folder path used by all CCC scripts.
-- RETURNS: string ‚Äì HFS path ¬´‚Ä¶Documents:CCC Script:¬ª (with trailing colon).
-- ============================================
on getBaseCCCFolder()
	return (path to documents folder as string) & "CCC Script:"
end getBaseCCCFolder

-- ==============================================
-- BACKUP & RESTORE FUNCTIONS
-- ==============================================

-- Find the latest backup for an entity
on findLatestBackup(entityName, backupType)
	my moduleLogDebug("Utilities", "Finding latest backup for " & entityName & " (" & backupType & ")")
	
	-- Construct the entity folder path
	global backupFolder
	if backupFolder is missing value or backupFolder is "" then
		setupFolders()
	end if
	
	-- Get type-specific subfolder
	set typeFolder to backupFolder & backupType & "s:"
	
	-- Get entity-specific folder
	set entitySafeName to sanitizeFileName(entityName)
	set entityFolder to typeFolder & entitySafeName & ":"
	
	-- Check if folder exists
	set folderExists to false
	try
		tell application "System Events"
			set folderExists to exists folder entityFolder
		end tell
	on error
		set folderExists to false
	end try
	
	if not folderExists then
		my moduleLogDebug("Utilities", "No backups found - folder doesn't exist: " & entityFolder)
		return ""
	end if
	
	-- Get all backup files in the folder using more reliable shell commands
	try
		set posixPath to POSIX path of entityFolder
		set listFilesCmd to "ls -t " & quoted form of posixPath & " | grep -v .DS_Store | head -n 1"
		set latestFileName to do shell script listFilesCmd
		
		if latestFileName is not "" then
			set latestPath to entityFolder & latestFileName
			my moduleLogDebug("Utilities", "Latest backup found: " & latestPath)
			return latestPath
		else
			my moduleLogDebug("Utilities", "No backup files found in folder")
			return ""
		end if
	on error shellErr
		my moduleLogError("Utilities", "Error finding latest backup via shell: " & shellErr)
		
		-- Fall back to Finder method
		try
			tell application "Finder"
				set backupFiles to every file of folder entityFolder
				if (count of backupFiles) is 0 then
					my moduleLogDebug("Utilities", "No backup files found in folder")
					return ""
				end if
				
				-- Find the latest backup based on modification date
				set latestFile to item 1 of backupFiles
				set latestModDate to modification date of latestFile
				
				repeat with aFile in backupFiles
					if modification date of aFile > latestModDate then
						set latestFile to aFile
						set latestModDate to modification date of aFile
					end if
				end repeat
				
				set latestPath to (entityFolder & (name of latestFile)) as string
				my moduleLogDebug("Utilities", "Latest backup found via Finder: " & latestPath)
				return latestPath
			end tell
		on error finderErr
			my moduleLogError("Utilities", "Error finding latest backup via Finder: " & finderErr)
			return ""
		end try
	end try
end findLatestBackup

-- Extract content from a backup file
on extractContentFromBackup(backupPath)
	my moduleLogDebug("Utilities", "Extracting content from backup: " & backupPath)
	
	-- First check if file exists
	set fileExistsFlag to false
	try
		tell application "System Events"
			set fileExistsFlag to exists file backupPath
		end tell
	on error
		set fileExistsFlag to false
	end try
	
	if not fileExistsFlag then
		my moduleLogError("Utilities", "Backup file does not exist: " & backupPath)
		return ""
	end if
	
	-- Try using shell command first (more reliable)
	try
		set posixPath to POSIX path of backupPath
		set grepCmd to "grep -A 100000 \"===== BACKUP CONTENT =====\" " & quoted form of posixPath & " | tail -n +2"
		set extractedContent to do shell script grepCmd
		
		if extractedContent is not "" then
			my moduleLogDebug("Utilities", "Successfully extracted content via shell (length: " & (length of extractedContent) & ")")
			return extractedContent
		end if
	on error shellErr
		my moduleLogError("Utilities", "Shell extraction failed: " & shellErr)
		-- Fall back to AppleScript method
	end try
	
	-- Fall back to AppleScript method
	try
		-- Read the backup file
		set backupFile to open for access backupPath
		set backupContent to read backupFile
		close access backupFile
		
		-- Find the content section after the metadata header
		set contentMarker to "===== BACKUP CONTENT ====="
		if backupContent contains contentMarker then
			set ASTID to AppleScript's text item delimiters
			set AppleScript's text item delimiters to contentMarker
			set contentParts to text items of backupContent
			
			if (count of contentParts) ‚â• 2 then
				-- Get everything after the marker
				set AppleScript's text item delimiters to ""
				set extractedContent to "" & text item 2 of contentParts
				
				-- Remove leading returns
				if extractedContent starts with return & return then
					set extractedContent to text 3 thru -1 of extractedContent
				else if extractedContent starts with return then
					set extractedContent to text 2 thru -1 of extractedContent
				end if
				
				set AppleScript's text item delimiters to ASTID
				my moduleLogDebug("Utilities", "Successfully extracted content via AppleScript (length: " & (length of extractedContent) & ")")
				return extractedContent
			end if
			
			set AppleScript's text item delimiters to ASTID
		end if
		
		my moduleLogError("Utilities", "Could not find content section in backup")
		return ""
	on error errMsg
		try
			close access backupFile
		end try
		my moduleLogError("Utilities", "Error extracting content from backup: " & errMsg)
		return ""
	end try
end extractContentFromBackup

-- Manage backup retention (cleanup old backups)
on manageBackupRetention(entityName, backupType, maxVersions)
	my moduleLogDebug("Utilities", "Managing backup retention for " & entityName & " (" & backupType & ")")
	
	-- Default to keeping 5 versions if not specified
	if maxVersions is missing value then set maxVersions to 5
	
	-- Construct the entity folder path
	global backupFolder
	if backupFolder is missing value or backupFolder is "" then
		setupFolders()
	end if
	
	-- Get type-specific subfolder
	set typeFolder to backupFolder & backupType & "s:"
	
	-- Get entity-specific folder
	set entitySafeName to sanitizeFileName(entityName)
	set entityFolder to typeFolder & entitySafeName & ":"
	
	-- Check if folder exists
	set folderExists to false
	try
		tell application "System Events"
			set folderExists to exists folder entityFolder
		end tell
	on error
		set folderExists to false
	end try
	
	if not folderExists then
		my moduleLogDebug("Utilities", "No backups found - folder doesn't exist: " & entityFolder)
		return {success:true, reason:"No backups to clean", removed:0}
	end if
	
	-- Try using shell commands first (more reliable)
	try
		set posixPath to POSIX path of entityFolder
		
		-- Count files in the folder
		set countCmd to "ls -1 " & quoted form of posixPath & " | grep -v .DS_Store | wc -l"
		set fileCount to do shell script countCmd
		set fileCount to fileCount as integer
		
		if fileCount ‚â§ maxVersions then
			my moduleLogDebug("Utilities", "Only " & fileCount & " backups exist, below threshold of " & maxVersions)
			return {success:true, reason:"Backup count below threshold", removed:0}
		end if
		
		-- Calculate how many files to remove
		set filesToRemove to fileCount - maxVersions
		
		-- List files oldest first
		set listCmd to "ls -tr " & quoted form of posixPath & " | grep -v .DS_Store | head -n " & filesToRemove
		set oldestFiles to do shell script listCmd
		
		-- Split the result into a list of filenames
		set ASTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to return
		set oldestFilesList to text items of oldestFiles
		set AppleScript's text item delimiters to ASTID
		
		-- Delete the oldest files
		set removedFiles to 0
		repeat with filename in oldestFilesList
			try
				set deleteCmd to "rm " & quoted form of (posixPath & filename)
				do shell script deleteCmd
				set removedFiles to removedFiles + 1
				my moduleLogDebug("Utilities", "Deleted old backup: " & filename)
			on error deleteErr
				my moduleLogError("Utilities", "Error deleting backup: " & deleteErr)
			end try
		end repeat
		
		return {success:true, reason:"Cleaned " & removedFiles & " old backups", removed:removedFiles}
	on error shellErr
		my moduleLogError("Utilities", "Shell command error: " & shellErr)
		
		-- Fall back to Finder method
		try
			tell application "Finder"
				-- Get all backup files in the folder
				set backupFiles to every file of folder entityFolder
				set fileCount to count of backupFiles
				
				if fileCount ‚â§ maxVersions then
					my moduleLogDebug("Utilities", "Only " & fileCount & " backups exist, below threshold of " & maxVersions)
					return {success:true, reason:"Backup count below threshold", removed:0}
				end if
				
				-- Sort files by modification date (oldest first)
				set sortedFiles to {}
				repeat with aFile in backupFiles
					set end of sortedFiles to {file:aFile, modDate:modification date of aFile}
				end repeat
				
				-- Sort oldest first using bubble sort
				repeat with i from 1 to (count of sortedFiles) - 1
					repeat with j from i + 1 to count of sortedFiles
						if modDate of item i of sortedFiles > modDate of item j of sortedFiles then
							-- Swap items
							set temp to item i of sortedFiles
							set item i of sortedFiles to item j of sortedFiles
							set item j of sortedFiles to temp
						end if
					end repeat
				end repeat
				
				-- Determine how many files to remove
				set filesToRemove to fileCount - maxVersions
				set removedFiles to 0
				
				-- Delete oldest files
				repeat with i from 1 to filesToRemove
					try
						set fileToDelete to file of item i of sortedFiles
						set filename to name of fileToDelete
						delete fileToDelete
						set removedFiles to removedFiles + 1
						my moduleLogDebug("Utilities", "Deleted old backup: " & filename)
					on error deleteErr
						my moduleLogError("Utilities", "Error deleting backup: " & deleteErr)
					end try
				end repeat
				
				return {success:true, reason:"Cleaned " & removedFiles & " old backups", removed:removedFiles}
			end tell
		on error finderErr
			my moduleLogError("Utilities", "Finder method error: " & finderErr)
			return {success:false, reason:"Error cleaning backups: " & finderErr, removed:0}
		end try
	end try
end manageBackupRetention

-- Show all items with backups of a specific type
on listBackupEntities(backupType)
	my moduleLogDebug("Utilities", "Listing entities with " & backupType & " backups")
	
	-- Get backup type folder
	global backupFolder
	if backupFolder is missing value or backupFolder is "" then
		setupFolders()
	end if
	
	-- Type-specific subfolder
	set typeFolder to backupFolder & backupType & "s:"
	
	-- Check if folder exists
	set folderExists to false
	try
		tell application "System Events"
			set folderExists to exists folder typeFolder
		end tell
	on error
		set folderExists to false
	end try
	
	if not folderExists then
		my moduleLogDebug("Utilities", "Backup type folder doesn't exist: " & typeFolder)
		return {}
	end if
	
	-- Try shell commands first (more reliable)
	try
		set posixPath to POSIX path of typeFolder
		set listCmd to "ls -1 " & quoted form of posixPath & " | grep -v .DS_Store"
		set entitiesList to do shell script listCmd
		
		-- Process the results
		set entityList to {}
		
		if entitiesList is not "" then
			-- Split the result into a list
			set ASTID to AppleScript's text item delimiters
			set AppleScript's text item delimiters to return
			set entitiesArray to text items of entitiesList
			set AppleScript's text item delimiters to ASTID
			
			-- Process each entity
			repeat with entityName in entitiesArray
				try
					-- Count versions
					set entityPath to typeFolder & entityName & ":"
					set versionCount to 0
					
					set posixEntityPath to POSIX path of entityPath
					set countCmd to "ls -1 " & quoted form of posixEntityPath & " | grep -v .DS_Store | wc -l"
					set versionCount to do shell script countCmd
					set versionCount to versionCount as integer
					
					-- Add to list if it has backups
					if versionCount > 0 then
						set end of entityList to {name:entityName, path:entityPath, versionCount:versionCount}
					end if
				on error entityErr
					my moduleLogError("Utilities", "Error processing entity folder: " & entityErr)
				end try
			end repeat
		end if
		
		my moduleLogDebug("Utilities", "Found " & (count of entityList) & " entities with backups")
		return entityList
	on error shellErr
		my moduleLogError("Utilities", "Shell method error: " & shellErr)
		
		-- Fall back to Finder method
		try
			tell application "Finder"
				-- Get all entity folders
				set entityFolders to every folder of folder typeFolder
				
				-- Process each entity folder
				set entityList to {}
				repeat with entityFolder in entityFolders
					try
						set entityName to name of entityFolder
						set entityPath to (typeFolder & entityName & ":")
						
						-- Count versions
						set versionCount to 0
						if exists folder entityPath then
							set versionFiles to every file of folder entityPath
							set versionCount to count of versionFiles
						end if
						
						-- Add to list if it has backups
						if versionCount > 0 then
							set end of entityList to {name:entityName, path:entityPath, versionCount:versionCount}
						end if
					on error entityErr
						my moduleLogError("Utilities", "Error processing entity folder: " & entityErr)
					end try
				end repeat
				
				my moduleLogDebug("Utilities", "Found " & (count of entityList) & " entities with backups")
				return entityList
			end tell
		on error finderErr
			my moduleLogError("Utilities", "Finder method error: " & finderErr)
			return {}
		end try
	end try
end listBackupEntities

-- Show all available versions for backup browsing
on listBackupVersions(entityName, backupType)
	my moduleLogDebug("Utilities", "Listing backup versions for " & entityName & " (" & backupType & ")")
	
	-- Construct path
	global backupFolder
	if backupFolder is missing value or backupFolder is "" then
		setupFolders()
	end if
	
	-- Type-specific subfolder
	set typeFolder to backupFolder & backupType & "s:"
	
	-- Entity folder
	set entitySafeName to sanitizeFileName(entityName)
	set entityFolder to typeFolder & entitySafeName & ":"
	
	-- Check if folder exists
	set folderExists to false
	try
		tell application "System Events"
			set folderExists to exists folder entityFolder
		end tell
	on error
		set folderExists to false
	end try
	
	if not folderExists then
		my moduleLogDebug("Utilities", "Entity folder doesn't exist: " & entityFolder)
		return {}
	end if
	
	-- Try shell commands first (more reliable)
	try
		set posixPath to POSIX path of entityFolder
		set listCmd to "ls -lt " & quoted form of posixPath & " | grep -v .DS_Store | sed '1d' | awk '{print $9,$6,$7,$8,$5}'"
		set versionsList to do shell script listCmd
		
		-- Process the results
		set versionList to {}
		
		if versionsList is not "" then
			-- Split the result into a list
			set ASTID to AppleScript's text item delimiters
			set AppleScript's text item delimiters to return
			set versionsArray to text items of versionsList
			set AppleScript's text item delimiters to ASTID
			
			-- Process each version
			repeat with versionLine in versionsArray
				try
					-- Parse the line (format: filename date time size)
					set ASTID to AppleScript's text item delimiters
					set AppleScript's text item delimiters to space
					set lineItems to text items of versionLine
					set AppleScript's text item delimiters to ASTID
					
					if (count of lineItems) ‚â• 4 then
						set filename to item 1 of lineItems
						set filePath to entityFolder & filename
						
						-- Parse version from filename (format: "v2025-4-16_10-30-45.txt")
						set versionStr to ""
						if filename starts with "v" and filename ends with ".txt" then
							-- Extract the timestamp part
							set versionStr to text 2 thru ((length of filename) - 4) of filename
						else
							-- Use what we have
							set versionStr to filename
						end if
						
						-- Format size string
						set fileSize to item 4 of lineItems as integer
						set sizeStr to ""
						if fileSize < 1024 then
							set sizeStr to fileSize & " bytes"
						else if fileSize < (1024 * 1024) then
							set sizeKB to (fileSize / 1024) as real
							set sizeStr to ((round (sizeKB * 10)) / 10) & " KB"
						else
							set sizeMB to (fileSize / (1024 * 1024)) as real
							set sizeStr to ((round (sizeMB * 10)) / 10) & " MB"
						end if
						
						-- Format date/time string
						set dateStr to item 2 of lineItems & " " & item 3 of lineItems
						
						-- Add to list
						set end of versionList to {version:versionStr, path:filePath, timeStr:dateStr, sizeStr:sizeStr, size:fileSize}
					end if
				on error lineErr
					my moduleLogError("Utilities", "Error processing version line: " & lineErr)
				end try
			end repeat
		end if
		
		my moduleLogDebug("Utilities", "Found " & (count of versionList) & " versions")
		return versionList
	on error shellErr
		my moduleLogError("Utilities", "Shell method error: " & shellErr)
		
		-- Fall back to Finder method
		try
			tell application "Finder"
				-- Get all version files
				set versionFiles to every file of folder entityFolder
				set versionList to {}
				
				-- Process each version file
				repeat with versionFile in versionFiles
					try
						set filename to name of versionFile as string
						set filePath to (entityFolder & filename) as string
						set fileSize to size of versionFile
						
						-- Parse version from filename
						set versionStr to ""
						if filename starts with "v" and filename ends with ".txt" then
							-- Extract the timestamp part
							set versionStr to text 2 thru ((length of filename) - 4) of filename
						else
							-- Use what we have
							set versionStr to filename
						end if
						
						-- Format display strings
						set modDateObj to modification date of versionFile
						set timeStr to (modDateObj as string)
						
						-- Format size string
						set sizeStr to ""
						if fileSize < 1024 then
							set sizeStr to fileSize & " bytes"
						else if fileSize < (1024 * 1024) then
							set sizeKB to (fileSize / 1024) as real
							set sizeStr to ((round (sizeKB * 10)) / 10) & " KB"
						else
							set sizeMB to (fileSize / (1024 * 1024)) as real
							set sizeStr to ((round (sizeMB * 10)) / 10) & " MB"
						end if
						
						-- Add to list
						set end of versionList to {version:versionStr, path:filePath, timeStr:timeStr, sizeStr:sizeStr, size:fileSize, modDate:modDateObj}
					on error versionErr
						my moduleLogError("Utilities", "Error processing version file: " & versionErr)
					end try
				end repeat
				
				-- Sort by modification date (newest first)
				if (count of versionList) > 1 then
					-- Sort using bubble sort
					repeat with i from 1 to (count of versionList) - 1
						repeat with j from i + 1 to count of versionList
							if modDate of item i of versionList < modDate of item j of versionList then
								-- Swap items
								set temp to item i of versionList
								set item i of versionList to item j of versionList
								set item j of versionList to temp
							end if
						end repeat
					end repeat
				end if
				
				my moduleLogDebug("Utilities", "Found " & (count of versionList) & " versions")
				return versionList
			end tell
		on error finderErr
			my moduleLogError("Utilities", "Finder method error: " & finderErr)
			return {}
		end try
	end try
end listBackupVersions

-- Generate a content hash for backup change detection
on getContentHash(theContent)
	try
		-- For more reliable hashing across different content types
		if theContent is missing value then
			return "d41d8cd98f00b204e9800998ecf8427e" -- MD5 of empty string
		end if
		
		-- Convert to string for consistent hashing
		set theString to theContent as string
		
		-- IMPROVED: Use a more robust approach for content hashing
		set contentLength to length of theString
		set hashValue to "len" & contentLength
		
		-- Take content samples for better hash quality
		if contentLength > 0 then
			-- Sample from start
			set startSize to 50
			if contentLength < startSize then
				set startSize to contentLength
			end if
			set startSample to text 1 thru startSize of theString
			
			-- Calculate checksum of start sample
			set startSum to 0
			repeat with i from 1 to length of startSample
				set charCode to ASCII number (character i of startSample)
				set startSum to startSum + charCode
			end repeat
			
			set hashValue to hashValue & "-s" & startSum
			
			-- Sample from end if long enough
			if contentLength > 100 then
				set endStart to contentLength - 49
				set endSample to text endStart thru -1 of theString
				
				-- Calculate checksum of end sample
				set endSum to 0
				repeat with i from 1 to length of endSample
					set charCode to ASCII number (character i of endSample)
					set endSum to endSum + charCode
				end repeat
				
				set hashValue to hashValue & "-e" & endSum
			end if
			
			-- Sample from middle for longer content
			if contentLength > 200 then
				set midStart to contentLength div 2 - 25
				set midSample to text midStart thru (midStart + 49) of theString
				
				-- Calculate checksum of middle sample
				set midSum to 0
				repeat with i from 1 to length of midSample
					set charCode to ASCII number (character i of midSample)
					set midSum to midSum + charCode
				end repeat
				
				set hashValue to hashValue & "-m" & midSum
			end if
		end if
		
		return hashValue
	on error errMsg
		my moduleLogError("Utilities", "Error generating content hash: " & errMsg)
		-- Fallback to timestamp-based hash
		set currentTime to (current date) as string
		set safeTime to my replaceText(currentTime, ":", "-")
		return "fallback-" & safeTime
	end try
end getContentHash

-------------------------------------------------------------------------------
-- UNIFIED LOGGING SYSTEM: POLICY, DISPLAY, & ROUTING RULES (2025-06-20, POLICY UPDATE)
-------------------------------------------------------------------------------
--  SYSTEM OVERVIEW:
--   ‚Ä¢ All log calls (Info, Warning, Error, Debug, Milestone) MUST go through module-level facades
--     (cmLogXXX in ContactManager, coLogXXX in ContactOperations), delegating to Utilities‚Äô logging handlers.
--   ‚Ä¢ During early startup, logs are buffered and flushed to the session log once Utilities is ready.
--   ‚Ä¢ Milestone and Error logs ALWAYS appear in BOTH the console and session log‚Äîregardless of module state.
--   ‚Ä¢ Warnings and Info:
--        ‚Äì ALWAYS appear in session log (regardless of mode).
--        ‚Äì Appear in Console ONLY in Debug mode (incl. auto-escalation).
--   ‚Ä¢ Fallback: If Utilities isn‚Äôt loaded, log outputs directly to console (timestamp + emoji + message), buffer for flush.
--   ‚Ä¢ Changing log/debug level via UI or handler MUST synchronize to all modules (use synchronizeLogSettings).
--   ‚Ä¢ Never call deprecated logError/logDebug/etc. directly‚Äîalways use facades.
--   ‚Ä¢ No log is lost: fallback always logs to console, buffers if session file not ready.

--  DISPLAY RULES (Console and Session File):
--   ‚Ä¢ Log output is ALWAYS formatted with emoji and ISO timestamp.
--   ‚Ä¢ [module] tag appears:
--        ‚Äì In session log: Only in Debug mode (including via auto-escalation to Debug)
--        ‚Äì In console: Only for Errors
--   ‚Ä¢ Example formats:
--        ‚Äì Milestone:   YYYY-MM-DD HH:MM:SS üìç Message
--        ‚Äì Info:        YYYY-MM-DD HH:MM:SS ‚ÑπÔ∏è Message
--        ‚Äì Debug:       YYYY-MM-DD HH:MM:SS üîç [Module] Message (session log, Debug mode)
--        ‚Äì Warning:     YYYY-MM-DD HH:MM:SS ‚ö†Ô∏è Message (session log: [Module] in Debug mode)
--        ‚Äì Error:       YYYY-MM-DD HH:MM:SS üî¥ [Module] Message (Console & session log, any mode)
--   ‚Ä¢ Console output:
--        ‚Äì Milestones always, Errors always (with [Module]),
--        ‚Äì Warnings/Info ONLY in Debug mode, no [Module] except for Errors.
--   ‚Ä¢ Session log:
--        ‚Äì All events, [Module] appears only in Debug mode (including via auto-escalate).

--  AUTO-ESCALATE:
--   ‚Ä¢ If error count reaches escalation threshold, session log switches to Debug mode for remainder of run.
--   ‚Ä¢ All subsequent session log entries show [module]; Warnings/Info appear in console until session end.

--  IMPLEMENTATION NOTES:
--   ‚Ä¢ All fallback and error paths must emit to BOTH console and file log, regardless of state.
--   ‚Ä¢ Buffering/fallback ensures all logs are either written or flushed when ready.
--   ‚Ä¢ All wrappers and logging handlers should remain grouped under this header for clarity.
-------------------------------------------------------------------------------

-- ------------------------------------------------------------------
--  Public shim ‚Äì keeps call-sites working
-- ------------------------------------------------------------------
on moduleLogDebug(theModule, theMessage)
	my safeLog(theModule, theMessage, kLogLevelDebug, missing value)
end moduleLogDebug

on moduleLogInfo(theModule, theMessage)
	my safeLog(theModule, theMessage, kLogLevelInfo, missing value)
end moduleLogInfo

on moduleLogWarning(theModule, theMessage)
	my safeLog(theModule, theMessage, kLogLevelWarning, missing value)
end moduleLogWarning

on moduleLogError(theModule, theMessage)
	my safeLog(theModule, theMessage, kLogLevelError, missing value)
end moduleLogError

-- Log as milestone but don't duplicate console output if already logged by caller
-------------------------------------------------------------------------------
on milestoneLog(moduleName, msg)
	my safeLog(moduleName, msg, kLogLevelMilestone, missing value)
end milestoneLog

-- ============================================
-- Handler: initializeLogging
-- VERSION: 1.0.2-readable-logging (2025-07-03)
-- AUTHOR: Philippe Dewost + Claude/Anthropic  
-- PURPOSE: Simplified logging initialization with readable fallback logging
-- CHANGES: Uses moduleLogXXX functions for immediate log level visibility
-- REPLACES: safeLog() calls with readable moduleLogWarning/Error/Debug/Info calls
-- ============================================
on initializeLogging()
	global logFile, sessionLogPath, logsFolder, debugMode, scriptVersion
	global loggingActive -- Phase detection for single-buffer approach
	global kLogLevelError, kLogLevelInfo, kLogLevelDebug, kLogLevelWarning, logLevel
	
	-- 1. CONFIGURATION SETUP (unchanged from original)
	set configurationSuccess to false
	try
		-- Determine runtime phase for logging behavior
		set isRuntimePhase to false
		try
			if loggingActive is true then
				set isRuntimePhase to true
			end if
		on error
			-- loggingActive undefined, assume startup phase
			set isRuntimePhase to false
		end try
		
		-- Phase-aware configuration setup
		my setLoggingConfiguration(missing value, missing value)
		set configurationSuccess to true
		
	on error configErr
		-- Configuration errors are not critical for basic logging
		set configurationSuccess to false
		if isRuntimePhase then
			my moduleLogWarning("Utilities", "Logging configuration failed (non-critical): " & configErr)
		end if
	end try
	
	-- 2. ‚úÖ ENHANCED SESSION LOG PATH SETUP WITH FALLBACK LOGGING
	set pathSetupSuccess to false
	try
		-- Validate logsFolder exists and is usable
		if logsFolder is not "" and logsFolder is not missing value then
			try
				-- Generate timestamp for unique session log filename
				set timestamp to formatTimestamp(current date)
				set sessionLogPath to logsFolder & "Session_" & timestamp & ".txt"
				set pathSetupSuccess to true
				if isRuntimePhase then
					my moduleLogDebug("Utilities", "Session log path set: " & sessionLogPath)
				end if
			on error timestampErr
				-- ‚úÖ WARNING: First fallback
				if isRuntimePhase then
					my moduleLogWarning("Utilities", "formatTimestamp failed, trying shell timestamp: " & timestampErr)
				end if
				
				try
					set simpleTimestamp to do shell script "date '+%Y-%m-%d_%H-%M-%S'"
					set sessionLogPath to logsFolder & "Session_" & simpleTimestamp & ".txt"
					set pathSetupSuccess to true
					if isRuntimePhase then
						my moduleLogWarning("Utilities", "Using shell timestamp fallback: " & sessionLogPath)
					end if
				on error shellErr
					-- ‚úÖ WARNING: Second fallback
					if isRuntimePhase then
						my moduleLogWarning("Utilities", "Shell timestamp failed, using basic date string: " & shellErr)
					end if
					
					set basicTimestamp to ((current date) as string)
					set cleanTimestamp to my replaceText(basicTimestamp, ":", "-")
					set sessionLogPath to logsFolder & "Session_" & cleanTimestamp & ".txt"
					set pathSetupSuccess to true
					if isRuntimePhase then
						my moduleLogWarning("Utilities", "Using basic timestamp fallback: " & sessionLogPath)
					end if
				end try
			end try
		else
			-- ‚úÖ WARNING: logsFolder unavailable
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "logsFolder unavailable, falling back to Documents folder")
			end if
			
			try
				set documentsFolder to (path to documents folder as string)
				set sessionLogPath to documentsFolder & "CCC_Session_Log.txt"
				set pathSetupSuccess to true
				if isRuntimePhase then
					my moduleLogWarning("Utilities", "Using Documents folder fallback: " & sessionLogPath)
				end if
			on error documentsErr
				-- ‚úÖ WARNING: Final path fallback
				if isRuntimePhase then
					my moduleLogWarning("Utilities", "Documents folder failed, using Desktop fallback: " & documentsErr)
				end if
				
				set desktopFolder to (path to desktop as string)
				set sessionLogPath to desktopFolder & "CCC_Session_Log.txt"
				set pathSetupSuccess to true
				if isRuntimePhase then
					my moduleLogWarning("Utilities", "Using Desktop fallback: " & sessionLogPath)
				end if
			end try
		end if
	on error pathErr
		-- ‚úÖ ERROR: All path setup strategies failed
		if isRuntimePhase then
			my moduleLogError("Utilities", "All path setup strategies failed, using minimal default: " & pathErr)
		end if
		
		set sessionLogPath to "CCC_Session_Log.txt"
		set pathSetupSuccess to true
	end try
	
	-- 3. ‚úÖ ENHANCED LOG FILE HEADER CREATION WITH FALLBACK LOGGING
	set headerCreationSuccess to false
	try
		-- Build comprehensive header with system and session information
		set headerText to "===============================================" & return
		set headerText to headerText & "CONTACT MANAGEMENT SYSTEM - SESSION LOG" & return
		set headerText to headerText & "===============================================" & return
		
		-- Session information with safe fallbacks
		try
			set headerText to headerText & "Session Started: " & ((current date) as string) & return
		on error timestampErr
			set headerText to headerText & "Session Started: [Timestamp Error]" & return
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "Header timestamp failed, using placeholder: " & timestampErr)
			end if
		end try
		
		-- Version information with safe fallback
		try
			if scriptVersion is not missing value and scriptVersion is not "" then
				set headerText to headerText & "Version: " & scriptVersion & return
			else
				set headerText to headerText & "Version: 0.9.0-alpha4" & return
				if isRuntimePhase then
					my moduleLogWarning("Utilities", "scriptVersion unavailable, using default version")
				end if
			end if
		on error versionErr
			set headerText to headerText & "Version: [Version Unknown]" & return
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "Version detection failed: " & versionErr)
			end if
		end try
		
		-- Debug mode status with safe fallback
		try
			set headerText to headerText & "Default Debug mode is: " & (debugMode as string) & return
		on error debugErr
			set headerText to headerText & "Default Debug mode is: true" & return
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "debugMode detection failed, assuming true: " & debugErr)
			end if
		end try
		
		-- Log file path information
		set headerText to headerText & "Log File: " & sessionLogPath & return & return
		
		-- Log level legend for user reference
		set headerText to headerText & "# Log Level Emoji Legend: üî¥=ERROR | ‚ö†Ô∏è=WARNING  | ‚ÑπÔ∏è=INFO  | üîç=DEBUG  | üìç =MILESTONE" & return
		set headerText to headerText & "(DEBUG mode: add [Module] for all logs; can be set in ContactManager script)" & return
		set headerText to headerText & "===============================================" & return & return
		
		set headerCreationSuccess to true
		
	on error headerErr
		-- ‚úÖ WARNING: Detailed header failed, trying minimal header
		if isRuntimePhase then
			my moduleLogWarning("Utilities", "Detailed header creation failed, using minimal header: " & headerErr)
		end if
		
		try
			set headerText to "=== CONTACT MANAGEMENT SYSTEM LOG ===" & return
			set headerText to headerText & "Session: " & ((current date) as string) & return
			set headerText to headerText & "===============================================" & return & return
			set headerCreationSuccess to true
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "Using minimal header fallback")
			end if
		on error minimalHeaderErr
			-- ‚úÖ WARNING: Even minimal header failed, using absolute minimum
			if isRuntimePhase then
				my moduleLogWarning("Utilities", "Minimal header failed, using absolute minimum: " & minimalHeaderErr)
			end if
			
			set headerText to "Contact Management System Session Log" & return & return
			set headerCreationSuccess to true
		end try
	end try
	
	-- 4. ‚úÖ ENHANCED FILE CREATION WITH SAVETEXT-TO-FILE AND FALLBACK LOGGING
	set fileCreationSuccess to false
	try
		if isRuntimePhase then
			my moduleLogDebug("Utilities", "Attempting session log file creation via saveTextToFile")
		end if
		
		set fileCreationSuccess to my saveTextToFile(headerText, sessionLogPath)
		
		if fileCreationSuccess then
			if isRuntimePhase then
				my moduleLogDebug("Utilities", "Session log file created successfully via saveTextToFile")
			end if
		else
			-- ‚úÖ ERROR: saveTextToFile failed completely
			if isRuntimePhase then
				my moduleLogError("Utilities", "saveTextToFile failed - all file creation strategies exhausted")
			end if
		end if
		
	on error saveTextErr
		-- ‚úÖ ERROR: saveTextToFile call itself failed
		if isRuntimePhase then
			my moduleLogError("Utilities", "Critical error calling saveTextToFile: " & saveTextErr)
		end if
		set fileCreationSuccess to false
	end try
	
	-- 5. ‚úÖ ENHANCED INITIALIZATION STATUS REPORTING
	try
		if isRuntimePhase and fileCreationSuccess then
			-- RUNTIME PHASE: Log successful initialization
			my moduleLogInfo("Utilities", "‚úÖ Session logging initialized successfully: " & sessionLogPath)
		else if isRuntimePhase and not fileCreationSuccess then
			-- ‚úÖ ERROR: Complete initialization failure
			my moduleLogError("Utilities", "‚ùå Session log initialization failed - console logging only")
		end if
		-- STARTUP PHASE: Silent operation - no logging about initialization status
	on error reportErr
		-- ‚úÖ ERROR: Even status reporting failed
		if isRuntimePhase then
			my moduleLogError("Utilities", "Status reporting failed: " & reportErr)
		end if
	end try
	
	-- 6. RETURN STATUS (unchanged from original)
	set initializationResult to {success:fileCreationSuccess, path:sessionLogPath, configSuccess:configurationSuccess, headerSuccess:headerCreationSuccess}
	
	-- For backward compatibility, return simple boolean if caller expects it
	return fileCreationSuccess
end initializeLogging

-------------------------------------------------------------------------------
-- Handler: setLoggingConfiguration
-- VERSION: 0.9.9 (2025-06-23)
-- AUTHOR: Philippe Dewost + Claude/Anthropic  
-- PURPOSE: Centralized logging configuration with phase-aware logging
-- CHANGE: Added startup phase detection to prevent logging during initialization
-- WHY:    setLoggingConfiguration() was logging during startup, violating single-buffer
-- WHEN:   Called during initializeLogging() and settings changes
-- HOW:    Checks loggingActive flag to stay silent during startup
-- BREAKS:  Nothing - maintains same configuration logic, eliminates startup logging
-------------------------------------------------------------------------------
on setLoggingConfiguration(newLogLevel, newDebugMode)
	global kLogLevelError, kLogLevelInfo, kLogLevelDebug, logLevel, debugMode
	global loggingActive -- Phase detection for single-buffer approach
	
	-- Ensure log level constants are defined (unchanged core logic)
	if kLogLevelError is missing value then set kLogLevelError to 0
	if kLogLevelInfo is missing value then set kLogLevelInfo to 1
	if kLogLevelDebug is missing value then set kLogLevelDebug to 2
	
	-- Set the debug mode flag if provided
	if newDebugMode is not missing value then
		set debugMode to newDebugMode
		
		-- PHASE-AWARE LOGGING: Only log during runtime phase
		try
			if loggingActive is true then
				-- RUNTIME PHASE: Normal logging allowed
				my safeLog("Utilities", "Debug mode set to: " & debugMode, kLogLevelInfo, missing value)
			else
				-- STARTUP PHASE: Silent operation - ContactManager will log configuration success
			end if
		on error phaseErr
			-- Fallback: if loggingActive undefined, assume startup phase and stay silent
		end try
		
		-- Auto-adjust log level based on debug mode if not explicitly set
		if newLogLevel is missing value then
			if debugMode then
				set newLogLevel to kLogLevelDebug
			else
				set newLogLevel to kLogLevelInfo
			end if
		end if
	end if
	
	-- Set the log level if provided or defaulted
	if newLogLevel is not missing value then
		-- Validate log level (ensure it's in range 0-2)
		if newLogLevel < 0 or newLogLevel > 2 then
			set newLogLevel to kLogLevelInfo -- Default to INFO for invalid values
		end if
		
		set logLevel to newLogLevel
		
		-- Get level name for logging (unchanged logic)
		set levelName to "INFO"
		if logLevel = kLogLevelError then set levelName to "ERROR"
		if logLevel = kLogLevelDebug then set levelName to "DEBUG"
		
		-- PHASE-AWARE LOGGING: Only log during runtime phase
		try
			if loggingActive is true then
				-- RUNTIME PHASE: Normal logging allowed
				my safeLog("Utilities", "Log level set to: " & logLevel & " (" & levelName & ")", kLogLevelInfo, missing value)
			else
				-- STARTUP PHASE: Silent operation - ContactManager will log configuration success
			end if
		on error phaseErr
			-- Fallback: if loggingActive undefined, assume startup phase and stay silent
		end try
	end if
	
	-- Return the current configuration (unchanged)
	return {logLevel:logLevel, debugMode:debugMode}
end setLoggingConfiguration

-------------------------------------------------------------------------------
-- Handler: safeLog
-- VERSION: 0.9.9 (2025-06-21)
-- AUTHOR: Philippe Dewost + Claude/ChatGPT
-- PURPOSE: Centralized, level-filtered logging; enforces display/visibility rules for both console and session log.
-- CHANGELOG:
--   ‚Ä¢ v0.9.9: Implements complete display filtering per unified logging policy.
--            (Console: milestones/errors always, info/warnings only in debug; session file: all events, but [module] only in debug.)
--            Suppresses all debug/info/warning logs from console/session file if not in debugMode.
-------------------------------------------------------------------------------
on safeLog(aModule, aMessage, logLevelPassed, optionalTs)
	global debugMode, logLevel, consecutiveErrorCount, autoEscalated
	global kLogLevelError, kLogLevelWarning, kLogLevelMilestone, kLogLevelInfo, kLogLevelDebug
	
	-- ENSURE GLOBAL VARIABLES ARE ACCESSIBLE
	try
		if autoEscalated is missing value then set autoEscalated to false
	on error
		set autoEscalated to false
	end try
	
	try
		if consecutiveErrorCount is missing value then set consecutiveErrorCount to 0
	on error
		set consecutiveErrorCount to 0
	end try
	
	-- 0 ‚ñ∏ Detect error
	set isError to (logLevelPassed = kLogLevelError)
	try
		if aMessage starts with "ERROR:" then set isError to true
	end try
	
	-- 1 ‚ñ∏ Auto-escalation (unchanged)
	if isError then
		set consecutiveErrorCount to consecutiveErrorCount + 1
		-- Only auto-escalate if not already in DEBUG mode
		if consecutiveErrorCount ‚â• LOG_ESCALATE_AFTER_ERRORS and logLevel ‚â† kLogLevelDebug then
			set logLevel to kLogLevelDebug
			set autoEscalated to true
			my moduleLogWarning("Utilities", "Auto‚Äëescalated to DEBUG after " & consecutiveErrorCount & " errors")
		end if
	else
		set consecutiveErrorCount to 0
	end if
	
	-- 2 ‚ñ∏ Compose timestamp
	if (optionalTs is missing value) then
		set logTime to my getISOTimestamp(missing value)
	else
		set logTime to my getISOTimestamp(optionalTs)
	end if
	
	-- 3 ‚ñ∏ ENFORCE DISPLAY POLICY
	
	-- (A) Debug logs: Only visible anywhere in debugMode
	if (logLevelPassed = kLogLevelDebug) and (not debugMode) and (not autoEscalated) then
		return -- suppress from both file & console
	end if
	
	-- (B) Info/Warning: Only output to CONSOLE in debugMode
	if ((logLevelPassed = kLogLevelInfo) or (logLevelPassed = kLogLevelWarning)) then
		if not debugMode then
			-- Only output to file (never console); let directFileLog decide destination
			try
				my directFileLog(aModule, aMessage, logLevelPassed, logTime)
			end try
			return -- suppress from console unless debugMode
		end if
	end if
	
	-- (C) Milestone & Error: Always go everywhere
	try
		my directFileLog(aModule, aMessage, logLevelPassed, logTime)
	on error
		log "‚ùå[safeLog() LOG ERROR] Could not write log entry"
	end try
end safeLog
-------------------------------------------------------------------------------
-- Policy Summary: Only safeLog() makes output/display decisions. All other handlers just buffer/route.
-------------------------------------------------------------------------------

-------------------------------------------------------------------------------
-- Handler: directFileLog
-- VERSION: 0.9.10 (2025-06-24)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Formats and writes log entry to session file with appropriate console echo
-- CHANGE: Added proper missing value handling for module names
-- WHY:    Missing value moduleName was creating "[missing value]" in log entries
-- WHEN:   Called by safeLog() after filtering decisions are made
-- HOW:    Check for missing value and convert to empty string before formatting
-- BREAKS:  Nothing - maintains same interface, adds defensive missing value handling
-- POLICY:  Console shows progress (Milestones+Errors always) + debug details (when debugMode=true)
--          Session log: Errors/Warnings always show module, Info/Debug only in debug mode
-------------------------------------------------------------------------------
on directFileLog(moduleName, message, level, optionalTs)
	global debugMode, sessionLogPath
	global kLogLevelError, kLogLevelWarning, kLogLevelMilestone, kLogLevelInfo, kLogLevelDebug
	
	-- 1. TIMESTAMP PROCESSING WITH FALLBACK (unchanged)
	-- Generate ISO timestamp if not provided, with robust error handling
	set logTime to ""
	try
		if optionalTs is missing value then
			set logTime to my getISOTimestamp(current date)
		else
			set logTime to my getISOTimestamp(optionalTs)
		end if
	on error tsErr
		-- Fallback to basic timestamp if ISO formatting fails
		try
			if optionalTs is missing value then
				set logTime to (current date) as string
			else
				set logTime to optionalTs as string
			end if
		on error
			set logTime to "[TIMESTAMP_ERROR]"
		end try
	end try
	
	-- 2. EMOJI AND LABEL RETRIEVAL WITH FALLBACK (unchanged)
	-- Get display formatting with robust error handling
	set emoji to "‚ùì" -- Safe fallback
	set label to "UNKNOWN" -- Safe fallback
	try
		set {emoji, label} to my getLogLevelEmojiLabel(level)
	on error emojiErr
		-- Fallback emoji mapping if getLogLevelEmojiLabel fails
		if level = kLogLevelError then
			set emoji to "üî¥"
		else if level = kLogLevelWarning then
			set emoji to "‚ö†Ô∏è"
		else if level = kLogLevelMilestone then
			set emoji to "üìç"
		else if level = kLogLevelInfo then
			set emoji to "‚ÑπÔ∏è"
		else if level = kLogLevelDebug then
			set emoji to "üîç"
		else
			set emoji to "‚ùì" -- Unknown level
		end if
	end try
	
	-- 3. MODULE NAME NORMALIZATION (NEW)
	-- Handle missing value module names to prevent "[missing value]" in output
	set normalizedModuleName to ""
	try
		if moduleName is missing value then
			set normalizedModuleName to ""
		else
			set normalizedModuleName to moduleName as string
		end if
	on error
		set normalizedModuleName to ""
	end try
	
	-- 4. MODULE TAG LOGIC (ENHANCED)
	-- Apply module masking based on level and debug mode per unified logging policy
	set logEntry to ""
	try
		if (level = kLogLevelError or level = kLogLevelWarning) then
			-- Errors and Warnings always show module tag (for troubleshooting)
			if normalizedModuleName is not "" then
				set logEntry to logTime & " " & emoji & " [" & normalizedModuleName & "] " & message
			else
				set logEntry to logTime & " " & emoji & " " & message
			end if
		else if (debugMode is true) then
			-- In debug mode, all messages show module tag
			if normalizedModuleName is not "" then
				set logEntry to logTime & " " & emoji & " [" & normalizedModuleName & "] " & message
			else
				set logEntry to logTime & " " & emoji & " " & message
			end if
		else
			-- Standard mode: no module tag for Info/Debug/Milestone
			set logEntry to logTime & " " & emoji & " " & message
		end if
	on error formatErr
		-- Emergency fallback formatting if module logic fails
		if normalizedModuleName is not "" then
			set logEntry to logTime & " " & emoji & " [" & normalizedModuleName & "] " & message
		else
			set logEntry to logTime & " " & emoji & " " & message
		end if
	end try
	
	-- 5. SESSION LOG FILE WRITING (unchanged)
	-- Write to session log with existing error handling
	set fileWriteSuccess to false
	try
		if sessionLogPath is not "" and sessionLogPath is not missing value then
			set logFile to open for access sessionLogPath with write permission
			write (logEntry & return) to logFile as ¬´class utf8¬ª starting at eof
			close access logFile
			set fileWriteSuccess to true
		end if
	on error logErr
		-- Ensure file is closed on any error
		try
			close access logFile
		on error
			-- Ignore close errors - file might already be closed
		end try
		set fileWriteSuccess to false
	end try
	
	-- 6. CONSOLE ECHO LOGIC (unchanged)
	-- NEW: Proper console echo based on unified logging policy
	-- Always echo: Milestones + Errors (progress monitoring)
	-- Debug mode only: Warnings + Info + Debug (detailed troubleshooting)
	set shouldEchoToConsole to false
	try
		-- Check debug mode availability with fallback
		set currentDebugMode to false
		try
			set currentDebugMode to debugMode
		on error
			set currentDebugMode to false -- Safe fallback if debugMode undefined
		end try
		
		-- Apply console echo policy
		if (level = kLogLevelMilestone or level = kLogLevelError) then
			-- ALWAYS echo milestones and errors for progress monitoring
			set shouldEchoToConsole to true
		else if (currentDebugMode is true) then
			-- DEBUG MODE: also echo warnings, info, and debug messages
			if (level = kLogLevelWarning or level = kLogLevelInfo or level = kLogLevelDebug) then
				set shouldEchoToConsole to true
			end if
		end if
		
		-- Perform console echo if determined necessary
		if shouldEchoToConsole then
			log logEntry
		end if
		
	on error consoleErr
		-- FAILSAFE: If console logic fails, default to original behavior (echo milestones/warnings/errors)
		if (level = kLogLevelMilestone or level = kLogLevelWarning or level = kLogLevelError) then
			try
				log logEntry
			on error
				-- Last resort console output
				log "[CONSOLE_ERROR] " & message
			end try
		end if
	end try
	
	-- 7. EMERGENCY FALLBACK
	if not fileWriteSuccess then
		log "‚ùå [LOGGING_EMERGENCY] " & normalizedModuleName & ": " & message
	end if
	
	-- 8. RETURN STATUS (unchanged)
	-- Return success status for diagnostic purposes (backward compatible - callers can ignore)
	return fileWriteSuccess
end directFileLog

--  Filter on logLevel, queue during bootstrap, append atomically in UTF-8 once the file is ready.
-------------------------------------------------------------------------------
--  `_appendToLog` uses the queued logging pipeline for efficiency.
--  `_appendToLogFallback` bypasses the queue and writes synchronously, ensuring that critical messages are not lost when the queue is inactive.
on _appendToLog(messageLevel, msgText)
	-- Honour current verbosity threshold
	if messageLevel > logLevel then return
	
	-- Bootstrapping: queue until initialiseLogging() sets gLoggingActive + gLogFileAlias
	if (gLoggingActive is false) or (gLogFileAlias is missing value) then
		set end of initialLogQueue to msgText
		return
	end if
	
	-- ---------- UTF-8-safe append (replaces open-for-access block) ----------
	try
		set posixPath to POSIX path of gLogFileAlias
		-- printf guarantees UTF-8; one newline added after each entry
		do shell script "/usr/bin/printf '%s\\n' " & quoted form of msgText & " >> " & quoted form of posixPath
	on error errMsg number errNum
		-- Push back to queue so no data is lost, then continue
		set end of initialLogQueue to "‚ö†Ô∏è [Logging] ERROR " & errNum & ": " & errMsg & return & msgText
	end try
end _appendToLog

-------------------------------------------------------------------------------
-- Handler: _appendToLogFallback
-- VERSION: 0.9.8 (2025-06-13)
-- AUTHOR: Philippe Dewost + Claude/Anthropic enhancements
-- PURPOSE: Fallback logging mechanism with guaranteed console visibility and smart queue management
-- PARAMETERS:
--   aModule (text) - Module name
--   aMessage (text) - Log message
--   aLevelNum (integer) - Log level (0=ERROR, 1=INFO, 2=DEBUG, etc.)
-- DEPENDENCIES: processLogQueue()
-- RETURNS: Boolean - always returns true
-- BEHAVIOR:
--   - Provides guaranteed console logging for immediate visibility
--   - Queues messages for later file writing when system becomes ready
--   - Attempts immediate queue flush if logging system is operational
--   - Uses UTF-8 safe timestamp generation
-- CHANGELOG:
--   0.9.8: Added smart queue flush and improved console visibility
--   0.9.7: Enhanced error handling and timestamp formatting
--   0.9.6: Initial fallback implementation
-------------------------------------------------------------------------------
on _appendToLogFallback(aModule, aMessage, aLevelNum)
	-- Guard: missing value ‚áí default to INFO (1)
	if aLevelNum is missing value then set aLevelNum to 1
	
	-- Choose emoji / label based on level
	set {emo, lbl} to {"‚ÑπÔ∏è", "INFO"}
	if aLevelNum = 0 then set {emo, lbl} to {"üî¥", "ERROR"}
	if aLevelNum = 2 then set {emo, lbl} to {"üîç", "DEBUG"}
	if aLevelNum = 3 then set {emo, lbl} to {"‚ö†Ô∏è", "WARNING"}
	if aLevelNum = 9 then set {emo, lbl} to {"üìç", "MILESTONE"}
	
	-- Generate UTF-8 safe timestamp
	set ts to do shell script "/bin/date '+%Y-%m-%d %H:%M:%S'"
	set finalLine to ts & space & emo & space & "[" & aModule & "] " & lbl & ": " & aMessage
	
	-- Always show in console for immediate visibility during bootstrap/errors
	log finalLine
	
	-- Queue for later flush with smart retry logic
	try
		set end of initialLogQueue to finalLine
		
		-- Attempt immediate flush if logging system is ready
		-- This ensures messages don't get stuck in queue during normal operations
		if gLoggingActive is true and gLogFileAlias is not missing value and logFilePath is not "" then
			-- Try to flush the queue immediately
			try
				my processLogQueue()
			on error queueErr
				-- Queue flush failed, but message is still queued for later retry
				-- Don't log this error to avoid recursion
			end try
		end if
		
	on error queueErr
		-- Even queueing failed - at least we have console output
		log "‚ö†Ô∏è [Logging] Failed to queue message, console-only: " & queueErr
	end try
	
	return true
end _appendToLogFallback

-------------------------------------------------------------------------------
--  ‚ú¶  Handler: _writeBanner(bannerText)                                     ‚ú¶
-------------------------------------------------------------------------------
on _writeBanner(bannerText)
	set ts to (current date) as string
	my _appendToLog(kLogLevelInfo, ts & " ‚ÑπÔ∏è [Utilities] INFO: " & bannerText)
end _writeBanner





-------------------------------------------------------------------------------
-- Handler: getLogLevelEmojiLabel
-- VERSION: 1.0.0 (2025-06-17)
-- PURPOSE: Map log level (numeric or string) to {emoji, label} for display.
-------------------------------------------------------------------------------
on getLogLevelEmojiLabel(level)
	if (level is kLogLevelMilestone or level is 9 or level is "MILESTONE") then
		return {emojiMilestone, "MILESTONE"}
	else if (level is kLogLevelWarning or level is 3 or level is "WARNING") then
		return {emojiWarning, "WARNING"}
	else if (level is kLogLevelError or level is 0 or level is "ERROR") then
		return {emojiError, "ERROR"}
	else if (level is kLogLevelDebug or level is 2 or level is "DEBUG") then
		return {emojiDebug, "DEBUG"}
	else
		return {emojiInfo, "INFO"}
	end if
end getLogLevelEmojiLabel


-------------------------------------------------------------------------------
-- Handler: initializeLogConstants
-- VERSION: 0.9.8-fix1 (2025-06-13)  
-- AUTHOR: Philippe Dewost + Claude/Anthropic enhancements
-- PURPOSE: Initialize LOG_LEVEL_* runtime globals if they don't exist
-- PARAMETERS: None
-- DEPENDENCIES: None
-- RETURNS: Boolean - always true
-- BEHAVIOR:
--   - Sets up runtime globals for log levels
--   - Safe to call multiple times
--   - Ensures constants are available before logging operations
-- CHANGELOG:
--   0.9.8-fix1: New handler to ensure runtime globals are initialized
-------------------------------------------------------------------------------
on initializeLogConstants()
	global LOG_LEVEL_ERROR, LOG_LEVEL_INFO, LOG_LEVEL_DEBUG, LOG_LEVEL_WARNING, LOG_LEVEL_MILESTONE
	
	-- Initialize if not already set
	if LOG_LEVEL_ERROR is missing value then set LOG_LEVEL_ERROR to 0
	if LOG_LEVEL_INFO is missing value then set LOG_LEVEL_INFO to 1
	if LOG_LEVEL_DEBUG is missing value then set LOG_LEVEL_DEBUG to 2
	if LOG_LEVEL_WARNING is missing value then set LOG_LEVEL_WARNING to 3
	if LOG_LEVEL_MILESTONE is missing value then set LOG_LEVEL_MILESTONE to 9
	
	return true
end initializeLogConstants

------------------------------------------------------------
--  _appendFile(destAlias, textBlock)  ‚Ä¢ low‚Äëlevel UTF‚Äë8 writer  ‚úß Œ±21.1
--  Called only by processLogQueue to flush pre‚Äëinitialisation lines.
--  CHANGES:
--    ‚Ä¢ Uses AppleScript‚Äôs¬†write¬†‚Ä¶¬†as¬†¬´class utf8¬ª to guarantee UTF‚Äë8.
--    ‚Ä¢ Removes legacy ASCII fallback that produced "?" for emoji.
-------------------------------------------------------------------------------
on _appendFile(destAlias, textBlock)
	try
		set logHandle to open for access destAlias with write permission
		-- Force UTF‚Äë8 so emojis and non‚ÄëASCII glyphs survive intact
		write textBlock as ¬´class utf8¬ª to logHandle starting at eof
		close access logHandle
		return true
	on error errMsg number errNum
		try
			close access logHandle
		end try
		-- Console only ‚Äì avoid recursion into logging
		log "‚ÄºÔ∏è [Logging] _appendFile failed " & errNum & ": " & errMsg
		return false
	end try
end _appendFile

-------------------------------------------------------------------------------
-- Handler: processLogQueue
-- VERSION: 0.9.8-revert (2025-06-13)
-- PURPOSE: Process queued log messages with original LOG_LEVEL_* constants
-------------------------------------------------------------------------------
on processLogQueue()
	-- Use utilities.txt's own constants
	global LOG_LEVEL_ERROR, LOG_LEVEL_DEBUG, gLogFileAlias, logFilePath, initialLogQueue, logLevel
	
	-- Nothing to flush
	if initialLogQueue is {} then return true
	
	try
		-- Ensure valid alias before processing
		if gLogFileAlias is missing value then
			if logFilePath is not "" and logFilePath is not missing value then
				try
					set gLogFileAlias to (logFilePath as alias)
				on error aliasErr
					log "‚ÄºÔ∏è [Logging] Cannot create alias for: " & logFilePath & " (" & aliasErr & ")"
					return false
				end try
			else
				log "‚ÄºÔ∏è [Logging] processLogQueue called but logFilePath not ready"
				return false
			end if
		end if
		
		-- Store queue count for logging
		set queueCount to count of initialLogQueue
		
		-- Rebuild each queued line with ISO timestamp + emoji
		set rebuilt to {}
		repeat with q in initialLogQueue
			set {lvl, plainMsg} to _splitEarlyLineContents(q)
			
			set {emo, lab} to {"‚ÑπÔ∏è", "INFO"}
			-- Use utilities.txt's own LOG_LEVEL_* constants
			if lvl = LOG_LEVEL_ERROR then set {emo, lab} to {"üî¥", "ERROR"}
			if lvl = LOG_LEVEL_DEBUG then set {emo, lab} to {"üîç", "DEBUG"}
			
			set end of rebuilt to ((current date) as string) & space & emo & space & plainMsg
		end repeat
		
		-- Join all rebuilt lines
		set queuedBlock to my joinText(rebuilt, return) & return
		
		-- Append in one atomic write
		my _appendFile(gLogFileAlias, queuedBlock)
		
		-- Clear queue only after successful write
		set initialLogQueue to {}
		
		-- Log success if we have debug logging enabled
		if logLevel ‚â• LOG_LEVEL_DEBUG then
			log "‚úÖ [Logging] processLogQueue processed " & queueCount & " queued entries successfully"
		end if
		
		return true
		
	on error errMsg number errNum
		log "‚ÄºÔ∏è [Logging] processLogQueue failed " & errNum & ": " & errMsg
		return false
	end try
end processLogQueue

-------------------------------------------------------------------------------
-- Handler: _splitEarlyLineContents
-- VERSION: 0.9.8-fix1 (2025-06-13)
-- AUTHOR: Philippe Dewost + Claude/Anthropic enhancements
-- PURPOSE: Parse early log queue entries with proper constant usage
-- PARAMETERS:
--   q (text) - Queued log entry in format "[Module] LEVEL: message"
-- DEPENDENCIES: LOG_LEVEL_* runtime globals
-- RETURNS: {level, plainMsg} - parsed level number and message text
-- BEHAVIOR:
--   - Parses log entries from startup queue
--   - Uses runtime LOG_LEVEL_* globals for consistency
--   - Defaults to INFO level if parsing fails
-- CHANGELOG:
--   0.9.8-fix1: Fixed constant names to use LOG_LEVEL_* globals
--   0.9.8: Initial implementation with kLogLevel* (BROKEN)
-------------------------------------------------------------------------------
on _splitEarlyLineContents(q)
	-- Access runtime globals
	global LOG_LEVEL_INFO, LOG_LEVEL_DEBUG, LOG_LEVEL_ERROR
	
	-- Default to INFO if parse fails
	set lvl to LOG_LEVEL_INFO
	set plainMsg to q as text
	
	try
		-- Extract leading "[Module]" and level tag
		set AppleScript's text item delimiters to "] "
		set tmp to text item 2 of q -- "LEVEL: message"
		set AppleScript's text item delimiters to ": "
		set lvlTag to text item 1 of tmp -- "INFO" / "DEBUG" / "ERROR"
		set plainMsg to text item 2 of tmp -- "message"
		
		-- Use LOG_LEVEL_* runtime globals instead of properties
		if lvlTag is "DEBUG" then set lvl to LOG_LEVEL_DEBUG
		if lvlTag is "ERROR" then set lvl to LOG_LEVEL_ERROR
	end try
	
	set AppleScript's text item delimiters to {""}
	return {lvl, plainMsg}
end _splitEarlyLineContents

-- ADDED: Separate function to check and perform log rotation
-- VERSION: 6.0.0-alpha15 (2025-04-28)
-- PURPOSE: More reliable log file rotation with better error handling
on checkLogFileForRotation(currentLogPath)
	global logsFolder
	-- Alpha19 debug fix
	-- Silence the size message unless we are at DEBUG level *and*
	-- the file is >75 % of the rotation threshold OR a rotation just happened
	if logLevel = kLogLevelDebug then
		set rotationThreshold to 1024 * 1024 -- 1 MB
		-- Claude 3.7 Alpha19.1 fix replacing fPath with currentLogPath
		set fileSize to (do shell script "stat -f%z " & quoted form of POSIX path of currentLogPath) as integer
		if fileSize > (rotationThreshold * 0.75) then my moduleLogDebug("Utilities", "Log file size: " & fileSize & ¬¨
			" bytes (Rotation threshold: " & rotationThreshold & " bytes)")
	end if
	try
		-- Check if the file exists first
		tell application "System Events"
			if not (exists file currentLogPath) then
				return false -- No rotation needed for non-existent file
			end if
		end tell
		
		-- Get file size using shell command for reliability
		set posixPath to POSIX path of currentLogPath
		set fileSizeCmd to "stat -f%z " & quoted form of posixPath & " 2>/dev/null || echo '0'"
		set fileSize to do shell script fileSizeCmd
		
		-- Convert to number and check size (1MB threshold)
		set fileSize to fileSize as integer
		
		-- Debug output for tracking rotation decisions
		log "Log file size: " & fileSize & " bytes (Rotation threshold: 1048576 bytes)"
		
		-- Only rotate if size exceeds threshold
		if fileSize > 1048576 then -- Over 1MB
			log "Log file size exceeds 1MB, initiating rotation..."
			
			-- FIXED: Get just the filename without path for better naming
			set currentLogFilename to getFilenameFromPath(currentLogPath)
			
			-- Generate a new timestamp for rotated log
			set newTimestamp to do shell script "date '+%Y-%m-%d_%H-%M-%S'"
			
			-- IMPROVED: Create a more distinct filename for the rotated log
			set rotatedFilename to "rotated_" & newTimestamp & "_" & currentLogFilename
			set rotatedPath to logsFolder & rotatedFilename
			
			-- FIXED: Ensure we're not rotating to the same path
			if rotatedPath is equal to currentLogPath then
				set rotatedPath to logsFolder & "rotated_" & newTimestamp & "_" & (random number from 1000 to 9999) & ".txt"
			end if
			
			-- Move current log to rotated path
			try
				-- Use shell mv command for more reliability
				do shell script "mv " & quoted form of posixPath & " " & quoted form of (POSIX path of rotatedPath)
				log "Log rotated to: " & rotatedPath
				
				-- Create new log file with rotation notice
				set rotationText to "===== LOG ROTATED AT " & ((current date) as string) & " =====" & return
				set rotationText to rotationText & "Previous log: " & rotatedPath & return
				set rotationText to rotationText & "Rotation reason: File exceeded 1MB size limit" & return
				set rotationText to rotationText & "=======================================" & return & return
				
				do shell script "echo " & quoted form of rotationText & " > " & quoted form of posixPath
				
				-- Add log entry about rotation
				set rotationEntry to do shell script "date '+%Y-%m-%d %H:%M:%S'"
				set rotationEntry to rotationEntry & " üîÑ [SYSTEM] INFO: Log file rotated due to size (over 1MB)"
				do shell script "echo " & quoted form of rotationEntry & " >> " & quoted form of posixPath
				
				return true
			on error mvErr
				log "Error rotating log file: " & mvErr
				return false
			end try
		else
			return false -- No rotation needed
		end if
	on error checkErr
		log "Error checking log file for rotation: " & checkErr
		return false
	end try
end checkLogFileForRotation


-- ADDED: Emergency logging as a separate function
-- VERSION: 6.0.0-alpha15 (2025-04-28)
-- PURPOSE: More robust fallback logging mechanism
on emergencyLogging(logEntry)
	try
		-- Try to find any log file in logs folder
		global logsFolder, logFilePath
		
		-- IMPROVED: Try to use the logs folder if available
		if logsFolder is not "" and logsFolder is not missing value then
			-- Create a new emergency log file
			set emergencyTimestamp to do shell script "date '+%Y-%m-%d_%H-%M-%S'"
			set emergencyPath to logsFolder & "emergency_log_" & emergencyTimestamp & ".txt"
			
			-- Create with proper header
			set headerText to "===== EMERGENCY LOG CREATED " & emergencyTimestamp & " =====" & return
			headerText to headerText & "Created due to failure in primary logging system" & return
			headerText to headerText & "=======================================" & return & return
			
			do shell script "echo " & quoted form of (headerText & logEntry) & " > " & quoted form of (POSIX path of emergencyPath)
			
			-- Update primary log path if possible
			if logFilePath is missing value or logFilePath is "" then
				set logFilePath to emergencyPath
			end if
			
			log "Created emergency log at: " & emergencyPath
			return true
		end if
		
		-- If that failed, try CCC Script folder
		set cccLogFolder to (path to documents folder as string) & "CCC Script:Logs:"
		
		-- Ensure the folder exists
		do shell script "mkdir -p " & quoted form of (POSIX path of cccLogFolder)
		
		-- Generate a new log filename with timestamp
		set newTimestamp to do shell script "date '+%Y-%m-%d_%H-%M-%S'"
		set newLogPath to POSIX path of (cccLogFolder & "emergency_log_" & newTimestamp & ".txt")
		
		do shell script "echo " & quoted form of ("===== EMERGENCY LOG =====" & return & logEntry) & " > " & quoted form of newLogPath
		return true
		
	on error emergencyErr
		-- Final fallback: Desktop
		try
			set desktopPath to (path to desktop folder as string) & "CMS_emergency_log.txt"
			
			-- Check if file exists
			set fileExists to false
			try
				tell application "System Events"
					set fileExists to exists file desktopPath
				end tell
			end try
			
			if fileExists then
				-- Append to existing file
				do shell script "echo " & quoted form of logEntry & " >> " & quoted form of (POSIX path of desktopPath)
			else
				-- Create new file with header
				set headerText to "===== EMERGENCY LOG =====" & return
				do shell script "echo " & quoted form of (headerText & logEntry) & " > " & quoted form of (POSIX path of desktopPath)
			end if
			
			return true
		on error finalErr
			log "All logging methods failed. Console-only logging active."
			return false
		end try
	end try
end emergencyLogging


-- ======
-- PERFORMANCE TRACKING SYSTEM (June 25th 2025)
-- The PTS learns from CCC sessions to establish and update user system's performance profile
-- Estimates average processing time for both simulation and real mode
-- Establishes a history of all contacts processed over time and the performance evolution and averages
-- Uses these estimations for large batches processing
-- ======

-- =============================================================================
-- Handler: recordSessionPerformance (WITH BASELINE THRESHOLD CONTROL)
-- VERSION: 3.0.0-baseline-threshold (2025-09-09)
-- PURPOSE: Record session performance with optional baseline update control
-- STRATEGY: Always record session for audit trail, optionally update baseline
-- 
-- CHANGELOG:
--   ‚Ä¢ 3.0.0-baseline-threshold (2025-09-09): 
--     - Added updateBaseline property check for baseline control
--     - Preserves all session history regardless of flag
--     - Backward compatible: missing property defaults to true
--     - Prevents small operations from skewing performance predictions
--   ‚Ä¢ 2.1.0-simplified (2025-07-08): Previous simplified version
-- 
-- INPUTS: sessRec (record) with properties:
--   ‚Ä¢ contacts (integer) - Number of contacts processed [REQUIRED]
--   ‚Ä¢ elapsedSec (real) - Processing time in seconds [REQUIRED]
--   ‚Ä¢ mode (text) - "simulation" or "update" [REQUIRED]
--   ‚Ä¢ updateBaseline (boolean) - Whether to update baseline [OPTIONAL via try/error]
-- 
-- RETURNS: boolean - Success/failure of recording operation
-- 
-- BACKWARD COMPATIBILITY:
--   Existing calls: {mode:"update", contacts:10, elapsedSec:5.0}
--   New calls: {mode:"update", contacts:10, elapsedSec:5.0, updateBaseline:false}
-- 
-- BEHAVIOR:
--   ‚Ä¢ ALWAYS records session line to performance_history.txt (audit trail)
--   ‚Ä¢ ONLY updates baseline averages if updateBaseline is true (or missing)
--   ‚Ä¢ Missing updateBaseline property = true (preserves existing behavior)
-- =============================================================================
on recordSessionPerformance(sessRec)
	set handlerName to "recordSessionPerformance"
	
	-- ‚ñ∏ 1. Validate & extract REQUIRED parameters
	try
		if sessRec is missing value then error "session record missing"
		
		-- Extract required properties (these MUST exist)
		set sContacts to sessRec's contacts
		set sSeconds to sessRec's elapsedSec
		set sMode to sessRec's mode
		
		-- Validate required values
		if sContacts ‚â§ 0 then error "invalid contact count: " & sContacts
		if sSeconds ‚â§ 0 then set sSeconds to 1.0E-3
		if sMode is not "simulation" and sMode is not "update" then
			error "invalid mode: " & sMode
		end if
		
	on error validationErr
		my moduleLogError("Utilities", handlerName & "(): Parameter validation failed - " & validationErr)
		return false
	end try
	
	-- ‚ñ∏ 2. Check for OPTIONAL updateBaseline property (AppleScript way)
	set shouldUpdateBaseline to true -- Default preserves existing behavior
	try
		-- This will error if property doesn't exist - that's normal in AppleScript
		set shouldUpdateBaseline to sessRec's updateBaseline
		
		-- Validate it's actually a boolean
		if class of shouldUpdateBaseline is not boolean then
			my moduleLogWarning("Utilities", handlerName & "(): updateBaseline not boolean, using default (true)")
			set shouldUpdateBaseline to true
		else
			my moduleLogDebug("Utilities", handlerName & "(): updateBaseline explicitly set to " & shouldUpdateBaseline)
		end if
		
	on error
		-- Property doesn't exist - this is the normal "optional" pattern in AppleScript
		-- Use default value (true) for backward compatibility
		my moduleLogDebug("Utilities", handlerName & "(): updateBaseline not provided, using default (true)")
		set shouldUpdateBaseline to true
	end try
	
	-- Log decision for small batches
	if sContacts < 5 and shouldUpdateBaseline then
		my moduleLogDebug("Utilities", handlerName & "(): Small batch (" & sContacts & " contacts) will update baseline - consider setting updateBaseline:false")
	end if
	
	-- ‚ñ∏ 3. Load performance history (ALWAYS needed for session recording)
	try
		set perfHistory to my loadPerformanceHistory()
	on error loadErr
		my moduleLogError("Utilities", handlerName & "(): Failed to load history: " & loadErr)
		return false
	end try
	
	-- ‚ñ∏ 4. CONDITIONALLY update performance history counters based on flag
	if shouldUpdateBaseline then
		try
			-- Update counters based on mode (ORIGINAL LOGIC PRESERVED)
			if sMode is "simulation" then
				-- Update simulation mode counters
				set oldSessionCount to perfHistory's simulationMode's sessionCount
				set oldTotalContacts to perfHistory's simulationMode's totalContacts
				set oldTotalTime to perfHistory's simulationMode's totalProcessingTime
				
				set perfHistory's simulationMode's sessionCount to oldSessionCount + 1
				set perfHistory's simulationMode's totalContacts to oldTotalContacts + sContacts
				set perfHistory's simulationMode's totalProcessingTime to oldTotalTime + sSeconds
				
				-- Recalculate average
				if perfHistory's simulationMode's totalContacts > 0 then
					set newAvg to (perfHistory's simulationMode's totalProcessingTime) / (perfHistory's simulationMode's totalContacts)
					set perfHistory's simulationMode's avgSecondsPerContact to newAvg
					
					my moduleLogDebug("Utilities", handlerName & "(): Updated simulation baseline - " & ¬¨
						"sessions:" & (oldSessionCount + 1) & ", contacts:" & (oldTotalContacts + sContacts) & ¬¨
						", avg:" & (round (newAvg * 1000)) / 1000 & "s/contact")
				end if
				
			else if sMode is "update" then
				-- Update update mode counters
				set oldSessionCount to perfHistory's updateMode's sessionCount
				set oldTotalContacts to perfHistory's updateMode's totalContacts
				set oldTotalTime to perfHistory's updateMode's totalProcessingTime
				
				set perfHistory's updateMode's sessionCount to oldSessionCount + 1
				set perfHistory's updateMode's totalContacts to oldTotalContacts + sContacts
				set perfHistory's updateMode's totalProcessingTime to oldTotalTime + sSeconds
				
				-- Recalculate average
				if perfHistory's updateMode's totalContacts > 0 then
					set newAvg to (perfHistory's updateMode's totalProcessingTime) / (perfHistory's updateMode's totalContacts)
					set perfHistory's updateMode's avgSecondsPerContact to newAvg
					
					my moduleLogDebug("Utilities", handlerName & "(): Updated update baseline - " & ¬¨
						"sessions:" & (oldSessionCount + 1) & ", contacts:" & (oldTotalContacts + sContacts) & ¬¨
						", avg:" & (round (newAvg * 1000)) / 1000 & "s/contact")
				end if
			end if
			
			-- Log baseline update confirmation
			my moduleLogInfo("Utilities", handlerName & "(): Baseline updated for " & sMode & " mode (" & sContacts & " contacts in " & (round (sSeconds * 10)) / 10 & "s)")
			
		on error updateErr
			my moduleLogError("Utilities", handlerName & "(): Failed to update counters: " & updateErr)
			-- Continue to save session line even if baseline update fails
		end try
	else
		-- Baseline update skipped - log this decision
		my moduleLogDebug("Utilities", handlerName & "(): Baseline update SKIPPED for " & sContacts & " contacts (updateBaseline=false)")
	end if
	
	-- ‚ñ∏ 5. Build session line with debug mode indicator (ALWAYS EXECUTED)
	try
		-- Check debug mode
		set debugIndicator to ""
		global autoEscalated, logLevel, kLogLevelDebug
		try
			if autoEscalated then
				set debugIndicator to " (debug)"
			else if logLevel ‚â• kLogLevelDebug then
				set debugIndicator to " (debug)"
			end if
		on error
			-- Ignore if these globals not available
		end try
		
		-- Calculate metrics
		if sSeconds > 0 then
			set contactsPerSec to sContacts / sSeconds
			set secondsPerContact to sSeconds / sContacts
		else
			set contactsPerSec to 0
			set secondsPerContact to 0
		end if
		
		-- Build session line with baseline skip indicator if applicable
		set baselineIndicator to ""
		if not shouldUpdateBaseline then
			set baselineIndicator to " [no baseline update]"
		end if
		
		-- Format session line
		set sessionLine to (my getISOTimestamp(current date)) & " - " & ¬¨
			sContacts & " contacts - " & ¬¨
			(my formatNumber(sSeconds, 1)) & "s - " & ¬¨
			sMode & debugIndicator & " - " & ¬¨
			(my formatNumber(contactsPerSec, 1)) & " contacts/s - " & ¬¨
			(my formatNumber(secondsPerContact, 3)) & "s/contact" & ¬¨
			baselineIndicator
		
		my moduleLogDebug("Utilities", handlerName & "(): Session line: " & sessionLine)
		
	on error buildErr
		my moduleLogError("Utilities", handlerName & "(): Failed to build session line: " & buildErr)
		return false
	end try
	
	-- ‚ñ∏ 6. ALWAYS save session to history file (maintains complete audit trail)
	try
		set saveResult to my savePerformanceHistoryWithSession(perfHistory, sessionLine)
		
		if saveResult then
			if shouldUpdateBaseline then
				my moduleLogDebug("Utilities", handlerName & "(): Session recorded and baseline updated successfully")
			else
				my moduleLogDebug("Utilities", handlerName & "(): Session recorded successfully (baseline unchanged)")
			end if
		else
			my moduleLogWarning("Utilities", handlerName & "(): Failed to save session history")
		end if
		
		return saveResult
		
	on error saveErr
		my moduleLogError("Utilities", handlerName & "(): Failed to save history: " & saveErr)
		return false
	end try
end recordSessionPerformance

-- ============================================
-- Handler: getPerformanceBaseline
-- VERSION: 0.9.15-defensive-access (2025-07-09)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Get performance baseline with defensive property access to prevent French locale errors
-- INPUTS:  processingMode (text) - "simulation", "update", or "statistics_rebuild"
-- RETURNS: Record {avgSecondsPerContact, sessionCount, profile, hasHistory}
-- FIXES:   Added defensive record property access to prevent "La variable X n'est pas d√©finie" errors
-- ============================================
on getPerformanceBaseline(processingMode)
	set handlerName to "getPerformanceBaseline"
	
	-- ‚úÖ INPUT VALIDATION AND MODE MAPPING (unchanged)
	try
		set originalMode to processingMode as string
		
		-- ‚úÖ NEW: Intelligent mode mapping for accurate performance estimates
		if processingMode is "statistics_rebuild" then
			set mappedMode to "simulation"
			my moduleLogDebug("Utilities", handlerName & "(): Mapping statistics_rebuild to simulation baseline (read-only operation)")
		else
			set mappedMode to processingMode
			my moduleLogDebug("Utilities", handlerName & "(): Using direct mode mapping: " & processingMode)
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Original mode: " & originalMode & " ‚Üí Mapped mode: " & mappedMode)
		
	on error mappingErr
		-- ‚úÖ FAILSAFE: If mapping fails, use original mode with warning
		my moduleLogWarning("Utilities", handlerName & "(): Mode mapping failed: " & mappingErr & " - using original mode: " & processingMode)
		set mappedMode to processingMode as string
	end try
	
	-- Continue with existing logic using mappedMode instead of processingMode
	my moduleLogDebug("Utilities", handlerName & "(): Retrieving baseline for " & mappedMode & " mode")
	
	try
		-- Load performance history using enhanced parser
		set perfHistory to my loadPerformanceHistory()
		
		-- ‚úÖ DEFENSIVE: Validate record structure before accessing properties
		if perfHistory is missing value then
			my moduleLogError("Utilities", handlerName & "(): Performance history is missing value")
			error "Performance history unavailable"
		end if
		
		-- ‚úÖ ENHANCED: Use debug-aware mode selection with defensive access
		if mappedMode contains "simulation" then
			try
				set modeData to perfHistory's simulationMode
				if modeData is missing value then error "simulationMode property missing"
				set modeLabel to "simulation"
			on error simErr
				my moduleLogError("Utilities", handlerName & "(): Cannot access simulationMode: " & simErr)
				error "simulationMode access failed"
			end try
		else if mappedMode contains "update" then
			try
				set modeData to perfHistory's updateMode
				if modeData is missing value then error "updateMode property missing"
				set modeLabel to "update"
			on error updateErr
				my moduleLogError("Utilities", handlerName & "(): Cannot access updateMode: " & updateErr)
				error "updateMode access failed"
			end try
		else
			-- Default fallback
			try
				set modeData to perfHistory's simulationMode
				if modeData is missing value then error "simulationMode fallback missing"
				set modeLabel to "simulation (fallback)"
				my moduleLogWarning("Utilities", handlerName & "(): Unknown mode " & mappedMode & ", using simulation fallback")
			on error fallbackErr
				my moduleLogError("Utilities", handlerName & "(): Fallback mode access failed: " & fallbackErr)
				error "All mode access failed"
			end try
		end if
		
		-- ‚úÖ DEFENSIVE: Validate and extract individual properties with explicit error handling
		try
			set sessionCountValue to modeData's sessionCount
			if sessionCountValue is missing value then set sessionCountValue to 0
		on error sessionErr
			my moduleLogError("Utilities", handlerName & "(): sessionCount access failed: " & sessionErr)
			set sessionCountValue to 0
		end try
		
		try
			set avgSecondsValue to modeData's avgSecondsPerContact
			if avgSecondsValue is missing value then
				if modeLabel contains "simulation" then
					set avgSecondsValue to 0.04
				else
					set avgSecondsValue to 0.08
				end if
			end if
		on error avgErr
			my moduleLogError("Utilities", handlerName & "(): avgSecondsPerContact access failed: " & avgErr)
			if modeLabel contains "simulation" then
				set avgSecondsValue to 0.04
			else
				set avgSecondsValue to 0.08
			end if
		end try
		
		try
			set profileValue to perfHistory's systemPerformanceProfile
			if profileValue is missing value then set profileValue to "Unknown"
		on error profileErr
			my moduleLogError("Utilities", handlerName & "(): systemPerformanceProfile access failed: " & profileErr)
			set profileValue to "Unknown"
		end try
		
		-- ‚úÖ VALIDATION: Ensure reasonable values
		if sessionCountValue < 0 then set sessionCountValue to 0
		if avgSecondsValue ‚â§ 0 then
			if modeLabel contains "simulation" then
				set avgSecondsValue to 0.04
			else
				set avgSecondsValue to 0.08
			end if
		end if
		
		-- ‚úÖ SUCCESS: Return validated baseline
		set baselineResult to ¬¨
			¬¨
				¬¨
					{avgSecondsPerContact:avgSecondsValue, sessionCount:sessionCountValue, profile:profileValue, hasHistory:(sessionCountValue > 0)} ¬¨
						
		
		my moduleLogInfo("Utilities", handlerName & "(): Retrieved " & modeLabel & " baseline: " & avgSecondsValue & "s/contact (" & sessionCountValue & " sessions)")
		return baselineResult
		
	on error baselineErr
		-- ‚úÖ ENHANCED: Provide English context for French locale errors
		set englishError to "Baseline access failed (check record structure): " & baselineErr
		my moduleLogError("Utilities", handlerName & "(): " & englishError)
		
		-- ‚úÖ FALLBACK: Return safe default baseline
		if mappedMode contains "update" then
			set fallbackSeconds to 0.08
		else
			set fallbackSeconds to 0.04
		end if
		
		return ¬¨
			¬¨
				¬¨
					{avgSecondsPerContact:fallbackSeconds, sessionCount:0, profile:"Fallback (" & mappedMode & ")", hasHistory:false} ¬¨
						
	end try
end getPerformanceBaseline

-------------------------------------------------------------------------------
-- Handler: getDebugAwareBaseline  
-- VERSION: 1.0.0-debug-aware (2025-07-09)
-- PURPOSE: Get baseline that accounts for debug mode performance impact
-- INPUTS:  processingMode (text), isDebugMode (boolean)
-- RETURNS: Record with appropriate baseline for current debug state
-- FUTURE:  Will differentiate baselines once enough data collected
-------------------------------------------------------------------------------
on getDebugAwareBaseline(processingMode, isDebugMode)
	set handlerName to "getDebugAwareBaseline"
	
	-- Load standard baseline
	set standardBaseline to my getPerformanceBaseline(processingMode)
	
	if isDebugMode then
		-- ‚úÖ FUTURE: When we have enough debug mode data, load debug-specific baselines
		-- For now, apply estimated 3x slowdown factor
		set debugBaseline to ¬¨
			¬¨
				¬¨
					{avgSecondsPerContact:((standardBaseline's avgSecondsPerContact) * 3.0), sessionCount:standardBaseline's sessionCount, profile:standardBaseline's profile & " (debug estimated)", hasHistory:standardBaseline's hasHistory} ¬¨
						
		
		my moduleLogDebug("Utilities", handlerName & "(): Applied 3x debug slowdown factor")
		return debugBaseline
	else
		return standardBaseline
	end if
end getDebugAwareBaseline

-- ============================================
-- Handler: estimateProcessingTime
-- VERSION: 0.9.15-defensive-baseline (2025-07-09)
-- PURPOSE: Enhanced time estimation with defensive baseline access
-- ============================================
on estimateProcessingTime(totalContacts, contactsProcessed, elapsedSeconds, processingMode)
	set handlerName to "estimateProcessingTime"
	
	-- ‚úÖ INPUT VALIDATION FIRST (before getting baseline)
	try
		set totalContacts to totalContacts as integer
		set contactsProcessed to contactsProcessed as integer
		set elapsedSeconds to elapsedSeconds as real
		if elapsedSeconds < 0 then set elapsedSeconds to 0.0
	on error inputErr
		my moduleLogError("Utilities", handlerName & "(): Input validation failed: " & inputErr)
		-- Return safe fallback estimates
		return {estimatedTotalTime:60.0, estimatedRemainingTime:60.0, scaledRate:1.0, hasHistory:false}
	end try
	
	my moduleLogDebug("Utilities", handlerName & "(): Estimating for " & totalContacts & " contacts, " & contactsProcessed & " done, " & elapsedSeconds & "s elapsed, mode=" & processingMode)
	
	try
		-- ‚úÖ GET BASELINE FIRST
		set baseline to my getPerformanceBaseline(processingMode)
		
		-- ‚úÖ THEN DEFENSIVELY ACCESS BASELINE PROPERTIES
		try
			if baseline is missing value then error "Baseline record is missing value"
			
			set defaultSeconds to baseline's avgSecondsPerContact
			if defaultSeconds is missing value or defaultSeconds ‚â§ 0 then
				my moduleLogWarning("Utilities", handlerName & "(): Invalid avgSecondsPerContact, using fallback")
				set defaultSeconds to 0.04
			end if
		on error baselineErr
			my moduleLogError("Utilities", handlerName & "(): Cannot access baseline properties: " & baselineErr)
			set defaultSeconds to 0.04
			-- Create fallback baseline record
			set baseline to {avgSecondsPerContact:0.04, sessionCount:0, profile:"Fallback", hasHistory:false}
		end try
		
		my moduleLogDebug("Utilities", handlerName & "(): Baseline: " & defaultSeconds & "s/contact, history=" & baseline's hasHistory)
		
		-- ‚úÖ CONTINUE WITH EXISTING LOGIC (unchanged)
		-- Calculate current session rate
		set currentSessionRate to 0.0
		if contactsProcessed > 0 and elapsedSeconds > 0 then
			set currentSessionRate to elapsedSeconds / contactsProcessed
			my moduleLogDebug("Utilities", handlerName & "(): Current session: " & currentSessionRate & "s/contact")
		end if
		
		-- Get hybrid estimate (uses proper numeric inputs)
		set hybridEstimate to my calculateHybridEstimate(defaultSeconds, currentSessionRate, contactsProcessed, baseline's hasHistory)
		my moduleLogDebug("Utilities", handlerName & "(): Hybrid estimate: " & hybridEstimate & "s/contact")
		
		-- Apply batch size scaling (guaranteed numeric input)
		set scaledEstimate to my applyBatchSizeScaling(hybridEstimate, totalContacts)
		my moduleLogDebug("Utilities", handlerName & "(): Scaled for batch size: " & scaledEstimate & "s/contact")
		
		-- Calculate final estimates
		set estimatedTotalTime to scaledEstimate * totalContacts
		set estimatedRemainingTime to scaledEstimate * (totalContacts - contactsProcessed)
		
		-- Ensure reasonable minimums
		if estimatedRemainingTime < 0.1 then set estimatedRemainingTime to 0.1
		if estimatedTotalTime < 0.1 then set estimatedTotalTime to 0.1
		
		my moduleLogDebug("Utilities", handlerName & "(): Final estimates - remaining: " & estimatedRemainingTime & "s, total: " & estimatedTotalTime & "s")
		
		return {estimatedTotalTime:estimatedTotalTime, estimatedRemainingTime:estimatedRemainingTime, scaledRate:(1.0 / scaledEstimate), hasHistory:baseline's hasHistory}
		
	on error estErr
		set englishError to "Time estimation failed (baseline access issue): " & estErr
		my moduleLogError("Utilities", handlerName & "(): " & englishError)
		-- Return conservative fallback
		set fallbackTotal to totalContacts * 0.1
		set fallbackRemaining to (totalContacts - contactsProcessed) * 0.1
		return {estimatedTotalTime:fallbackTotal, estimatedRemainingTime:fallbackRemaining, scaledRate:10.0, hasHistory:false}
	end try
end estimateProcessingTime

-- ============================================
-- Handler: formatTimeEstimate
-- VERSION: 1.0.2 (2025-07-03)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Format time in seconds to human-readable format (1s, 2m30s, 1h15m)
-- INPUTS:  totalSeconds (real) - time in seconds to format
-- RETURNS: text - formatted time string
-- EXAMPLES: 
--   45 seconds ‚Üí "45s"
--   90 seconds ‚Üí "1m30s" 
--   3665 seconds ‚Üí "1h1m5s"
--   0.5 seconds ‚Üí "1s" (rounded up)
-- NOTES:   Handles edge cases gracefully, doesn't modify input parameter
-- CHANGELOG:
--   1.0.1: Fixed reserved word conflict with 'seconds' variable name
--   1.0.0: Initial implementation based on session logs and usage patterns
-- ============================================
on formatTimeEstimate(totalSeconds)
	set handlerName to "formatTimeEstimate"
	
	try
		-- Input validation and type conversion
		if totalSeconds is missing value then
			my moduleLogWarning("Utilities", handlerName & "(): Missing value input, using 0")
			set totalSeconds to 0
		end if
		
		-- Convert to number if it's text (defensive programming)
		if class of totalSeconds is text then
			try
				set totalSeconds to totalSeconds as real
			on error
				my moduleLogWarning("Utilities", handlerName & "(): Cannot convert text '" & totalSeconds & "' to number, using 0")
				return "0s"
			end try
		end if
		
		-- Use local variable with non-reserved name
		set timeValue to totalSeconds as real
		
		-- Handle negative or zero values
		if timeValue ‚â§ 0 then
			return "0s"
		end if
		
		-- Round very small values up to 1 second
		if timeValue < 1 then
			return "1s"
		end if
		
		-- Calculate hours, minutes, seconds
		set hoursCount to timeValue div 3600
		set remainingAfterHours to timeValue mod 3600
		set minutesCount to remainingAfterHours div 60
		set secondsCount to remainingAfterHours mod 60
		
		-- Round remaining seconds
		set secondsCount to round secondsCount
		
		-- Declare result variable
		set resultText to ""
		
		-- Build formatted string based on magnitude
		if hoursCount > 0 then
			-- Format: "1h15m" or "1h15m30s"
			set resultText to (hoursCount as integer) & "h"
			if minutesCount > 0 then
				set resultText to resultText & (minutesCount as integer) & "m"
			end if
			if secondsCount > 0 and hoursCount < 2 then -- Show seconds only for < 2 hours
				set resultText to resultText & (secondsCount as integer) & "s"
			end if
			return resultText
			
		else if minutesCount > 0 then
			-- Format: "15m" or "15m30s"
			set resultText to (minutesCount as integer) & "m"
			if secondsCount > 0 then
				set resultText to resultText & (secondsCount as integer) & "s"
			end if
			return resultText
			
		else
			-- Format: "45s"
			return (secondsCount as integer) & "s"
		end if
		
	on error formatErr
		my moduleLogError("Utilities", handlerName & "(): Formatting error: " & formatErr)
		return "unknown"
	end try
end formatTimeEstimate

-------------------------------------------------------------------------------
-- Handler: loadPerformanceHistory
-- VERSION: 0.9.12 (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Load performance history from dedicated file with fallback defaults
-- INPUTS:  None
-- RETURNS: Performance history record with mode-specific data
-- NOTES:   Creates default structure if file missing, uses existing file path patterns
-- DEPENDENCIES: parsePerformanceData(), existing path management, logging system
-------------------------------------------------------------------------------
on loadPerformanceHistory()
	set handlerName to "loadPerformanceHistory"
	
	-- Return cached version if already loaded
	if performanceHistoryLoaded and cachedPerformanceHistory is not missing value then
		my moduleLogDebug("Utilities", handlerName & "(): Using cached performance history")
		return cachedPerformanceHistory
	end if
	
	-- Define default performance history structure
	set defaultHistory to {version:"1.0", lastUpdated:(current date), systemInfo:"", simulationMode:{sessionCount:0, totalContacts:0, totalProcessingTime:0, avgSecondsPerContact:0.04, recentSessions:{}}, updateMode:{sessionCount:0, totalContacts:0, totalProcessingTime:0, avgSecondsPerContact:0.08, recentSessions:{}}, systemPerformanceProfile:"Unknown", lastCalibration:(current date), maxSessionHistory:50, autoCleanupThreshold:100}
	
	try
		set perfFilePath to (path to documents folder as string) & "CCC Script:performance_history.txt"
		my moduleLogDebug("Utilities", handlerName & "(): Loading from: " & perfFilePath)
		
		-- Check if file exists using existing pattern
		set fileExists to false
		try
			tell application "System Events"
				if exists file perfFilePath then set fileExists to true
			end tell
		on error
			set fileExists to false
		end try
		
		if not fileExists then
			my moduleLogInfo("Utilities", handlerName & "(): No performance history found, creating default")
			-- Save default structure and return it
			my avePerformanceHistoryWithSession(defaultHistory, missing value)
			return defaultHistory
		end if
		
		-- Load existing file using PROVEN file access pattern (same as savePerformanceHistory)
		set fileRef to missing value
		try
			-- PROVEN PATTERN: Convert to alias first (eliminates current application error)
			set fileAlias to (perfFilePath as alias)
			set fileRef to open for access fileAlias
			set rawText to read fileRef
			close access fileRef
			my moduleLogDebug("Utilities", handlerName & "(): File loaded, " & (length of rawText) & " characters")
			
		on error fileErr
			try
				if fileRef is not missing value then close access fileRef
			end try
			my moduleLogWarning("Utilities", handlerName & "(): File read error: " & fileErr)
			return defaultHistory
		end try
		
		-- Parse performance data
		set parsedHistory to my parsePerformanceData(rawText, defaultHistory)
		my moduleLogInfo("Utilities", handlerName & "(): Loaded performance history - sim:" & parsedHistory's simulationMode's sessionCount & " sessions, update:" & parsedHistory's updateMode's sessionCount & " sessions")
		
		-- ‚úÖ CACHE THE RESULT:
		set cachedPerformanceHistory to parsedHistory
		set performanceHistoryLoaded to true
		
		return parsedHistory
		
	on error loadErr
		my moduleLogError("Utilities", handlerName & "(): Load failed: " & loadErr)
		-- ‚úÖ CACHE THE DEFAULT:
		set cachedPerformanceHistory to defaultHistory
		set performanceHistoryLoaded to true
		return defaultHistory
	end try
end loadPerformanceHistory

-- =============================================================================
-- Handler: buildPerformanceHistoryTemplate
-- VERSION: 1.1.0-creation-date (2025-07-09)
-- PURPOSE: Create default performance history file template with creation date
-- RETURNS: text - complete default file content with creation timestamp
-- CHANGES: Added creation date to headers as requested
-- =============================================================================
on buildPerformanceHistoryTemplate()
	set LF to return
	set creationTimestamp to my getISOTimestamp(current date)
	
	return "# Contact Management System - Performance History" & LF & ¬¨
		"# Auto-generated file - do not edit manually" & LF & ¬¨
		"# Created: " & creationTimestamp & LF & LF & ¬¨
		"version:1.0" & LF & ¬¨
		"lastUpdated:" & creationTimestamp & LF & ¬¨
		"systemPerformanceProfile:Unknown" & LF & ¬¨
		"maxSessionHistory:50" & LF & ¬¨
		"autoCleanupThreshold:100" & LF & LF & ¬¨
		"# Simulation Mode Performance Data" & LF & ¬¨
		"simulation_sessionCount:0" & LF & ¬¨
		"simulation_totalContacts:0" & LF & ¬¨
		"simulation_totalTime:0.0" & LF & ¬¨
		"simulation_avgSeconds:0.04" & LF & LF & ¬¨
		"# Update Mode Performance Data" & LF & ¬¨
		"update_sessionCount:0" & LF & ¬¨
		"update_totalContacts:0" & LF & ¬¨
		"update_totalTime:0.0" & LF & ¬¨
		"update_avgSeconds:0.08" & LF & LF & ¬¨
		"# Session History (All Sessions - Permanent Record)" & LF
end buildPerformanceHistoryTemplate

-- =============================================================================
-- Handler: savePerformanceHistoryWithSession
-- VERSION: 0.9.11-verificationFix (2025-07-09)
-- PURPOSE: Persist performance history and append the current session, with a
--          robust two‚Äëpass verification that now tolerates either ":" or "="
--          after the key.  Adds early‚Äëexit success on the fast path and more
--          defensive error handling.
-- CHANGELOG:
--   ‚Ä¢ 0.9.11‚ÄëverificationFix ‚Äì verification now accepts both ":" and "=" between
--     key and value; falls back to numeric extraction if the marker contains
--     extra whitespace; restores text‚Äëitem‚Äëdelimiter state.
--   ‚Ä¢ 0.9.10 ‚Äì minor logging tweaks (internal).
--   ‚Ä¢ 0.9.9  ‚Äì original "enhanced" version with alternativeSessionAppend().
-- =============================================================================
on savePerformanceHistoryWithSession(perfHistory, currentSessionData)
	-- *** 1. Sanity checks ********************************************************
	set handlerName to "savePerformanceHistoryWithSession"
	if perfHistory is missing value then
		my moduleLogError("Utilities", handlerName & "(): Cannot save ‚Äì history record is missing value")
		return false
	end if
	
	-- *** 2. Build the complete file **********************************************
	try
		set perfFilePath to (my getBaseCCCFolder()) & "performance_history.txt"
		my createFolderPath(my getBaseCCCFolder())
		
		set LF to return
		set metaBlock to ¬¨
			"# Contact Management System - Performance History" & LF & ¬¨
			"# Auto-generated file - do not edit manually" & LF & LF & ¬¨
			"version:" & perfHistory's version & LF & ¬¨
			"lastUpdated:" & (my getISOTimestamp(current date)) & LF & ¬¨
			"systemPerformanceProfile:" & perfHistory's systemPerformanceProfile & LF & ¬¨
			"maxSessionHistory:" & (perfHistory's maxSessionHistory as integer) & LF & ¬¨
			"autoCleanupThreshold:" & (perfHistory's autoCleanupThreshold as integer) & LF & LF
		
		-- Simulation counters
		set simMode to perfHistory's simulationMode
		set simBlock to ¬¨
			"# Simulation Mode Performance Data" & LF & ¬¨
			"simulation_sessionCount:" & (simMode's sessionCount as integer) & LF & ¬¨
			"simulation_totalContacts:" & (simMode's totalContacts as integer) & LF & ¬¨
			"simulation_totalTime:" & (my formatNumber(simMode's totalProcessingTime, 1)) & LF & ¬¨
			"simulation_avgSeconds:" & (my formatNumber(simMode's avgSecondsPerContact, 3)) & LF & LF
		
		-- Update counters
		set updMode to perfHistory's updateMode
		set updBlock to ¬¨
			"# Update Mode Performance Data" & LF & ¬¨
			"update_sessionCount:" & (updMode's sessionCount as integer) & LF & ¬¨
			"update_totalContacts:" & (updMode's totalContacts as integer) & LF & ¬¨
			"update_totalTime:" & (my formatNumber(updMode's totalProcessingTime, 1)) & LF & ¬¨
			"update_avgSeconds:" & (my formatNumber(updMode's avgSecondsPerContact, 3)) & LF & LF
		
		set fileContent to metaBlock & simBlock & updBlock
		
		-- *** 2a. Merge existing session history *********************************
		try
			set res to my readTextFile(perfFilePath)
			if res's success then
				set oldContent to res's text
				set fileContent to my alternativeSessionAppend(fileContent, oldContent, currentSessionData)
			else
				set fileContent to fileContent & "# Session History (All Sessions - Permanent Record)" & LF
				if currentSessionData is not missing value and currentSessionData is not "" then set fileContent to fileContent & currentSessionData & LF
			end if
		on error appendErr
			my moduleLogWarning("Utilities", handlerName & "(): Session append failed: " & appendErr)
			set fileContent to fileContent & "# Session History (All Sessions - Permanent Record)" & LF
			if currentSessionData is not missing value and currentSessionData is not "" then set fileContent to fileContent & currentSessionData & LF
		end try
		
		-- *** 3. Persist to disk ****************************************************
		if my saveTextToFile(fileContent, perfFilePath) is false then
			my moduleLogError("Utilities", handlerName & "(): Failed to save performance history to file")
			return false
		end if
		
		-- ‚úÖ COPY TO SESSION REPORTS FOLDER
		try
			set sessionReportsFolder to getCurrentSessionFolder() & "Reports:"
			my createFolderPath(sessionReportsFolder)
			set sessionPerfPath to sessionReportsFolder & "performance_history.txt"
			
			tell application "Finder"
				duplicate file perfFilePath to folder sessionReportsFolder with replacing
			end tell
			
			my moduleLogInfo("Utilities", handlerName & "(): Copied to session: " & sessionPerfPath)
		on error copyErr
			my moduleLogWarning("Utilities", handlerName & "(): Session copy failed: " & copyErr)
		end try
		
		return true
		
	on error topErr
		my moduleLogError("Utilities", handlerName & "(): Fatal error: " & topErr)
		return false
	end try
end savePerformanceHistoryWithSession

-------------------------------------------------------------------------------
-- Handler: alternativeSessionAppend
-- VERSION: 1.0.0-alternative (2025-07-09)
-- PURPOSE: Safe session history append using paragraph-based processing
-- INPUTS:  fileContent (text) - main file content to append to
--          oldContent (text) - existing file content
--          currentSessionData (text) - new session data to append
-- RETURNS: text - complete file content with session history appended
-- STRATEGY: Process line-by-line instead of character positions to avoid AppleScript text errors
-------------------------------------------------------------------------------
on alternativeSessionAppend(fileContent, oldContent, currentSessionData)
	set handlerName to "alternativeSessionAppend"
	set LF to return
	
	try
		-- Force text coercion to prevent object errors
		set oldContent to oldContent as text
		set fileContent to fileContent as text
		
		my moduleLogDebug("Utilities", handlerName & "(): Processing " & (length of oldContent) & " chars of old content")
		
		-- Split into paragraphs for line-by-line processing
		set oldLines to paragraphs of oldContent
		set sessionStartFound to false
		set sessionLines to {}
		set sessionHeaderLine to "# Session History (All Sessions - Permanent Record)"
		
		my moduleLogDebug("Utilities", handlerName & "(): Processing " & (count of oldLines) & " lines")
		
		-- Find and extract existing session history
		repeat with i from 1 to (count of oldLines)
			set oneLine to item i of oldLines
			
			-- Check for session history start
			if oneLine contains sessionHeaderLine then
				set sessionStartFound to true
				my moduleLogDebug("Utilities", handlerName & "(): Found session history at line " & i)
			end if
			
			-- Collect session history lines
			if sessionStartFound then
				set end of sessionLines to oneLine
			end if
		end repeat
		
		-- Build final content
		if sessionStartFound then
			-- Existing session history found - preserve it
			set existingSessionHistory to my joinText(sessionLines, LF)
			set resultContent to fileContent & existingSessionHistory
			my moduleLogDebug("Utilities", handlerName & "(): Preserved " & (count of sessionLines) & " existing session lines")
			
			-- Add new session if provided
			if currentSessionData is not missing value and currentSessionData is not "" then
				-- Ensure we end with newline before adding new session
				if not (resultContent ends with LF) then
					set resultContent to resultContent & LF
				end if
				set resultContent to resultContent & currentSessionData & LF
				my moduleLogInfo("Utilities", handlerName & "(): Appended new session data")
			end if
			
		else
			-- No existing session history - create new section
			set resultContent to fileContent & sessionHeaderLine & LF
			if currentSessionData is not missing value and currentSessionData is not "" then
				set resultContent to resultContent & currentSessionData & LF
				my moduleLogInfo("Utilities", handlerName & "(): Created new session history with data")
			else
				my moduleLogInfo("Utilities", handlerName & "(): Created new empty session history section")
			end if
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Final content: " & (length of resultContent) & " characters")
		return resultContent
		
	on error altErr
		my moduleLogError("Utilities", handlerName & "(): Alternative append failed: " & altErr)
		-- Ultimate fallback
		return fileContent & "# Session History (All Sessions - Permanent Record)" & LF
	end try
end alternativeSessionAppend

-------------------------------------------------------------------------------
-- Handler: parsePerformanceData
-- VERSION: 0.9.17-scientific-notation (2025-06-27)
-- AUTHOR: Philippe Dewost + Claude/Anthropic  
-- PURPOSE: Parse performance history with enhanced number handling including scientific notation
-- CHANGELOG:
--   ‚Ä¢ 0.9.17-scientific-notation: Added proper scientific notation parsing before parseLocaleNumber
--   ‚Ä¢ Scientific notation (E/e format) now parsed correctly then validated for reasonableness
--   ‚Ä¢ Preserves legitimate fast processing times in scientific notation format
--   ‚Ä¢ Enhanced debugging shows parsing method used (scientific vs decimal)
--   ‚Ä¢ 0.9.16-locale-safe: Use existing parseLocaleNumber for all numeric conversions
--   ‚Ä¢ Eliminates scientific notation and locale decimal separator issues
--   ‚Ä¢ Enhanced debugging for number conversion tracking
-------------------------------------------------------------------------------
on parsePerformanceData(rawText, defaultHistory)
	set handlerName to "parsePerformanceData"
	
	if rawText is "" or rawText is missing value then
		my moduleLogInfo("Utilities", handlerName & "(): Empty input, returning defaults")
		return defaultHistory
	end if
	
	try
		-- Start with default structure
		set parsedHistory to defaultHistory
		
		-- Parse line by line
		set ASTID to AppleScript's text item delimiters
		set AppleScript's text item delimiters to return
		set allLines to text items of rawText
		set AppleScript's text item delimiters to ":"
		
		my moduleLogDebug("Utilities", handlerName & "(): Parsing " & (count of allLines) & " lines")
		
		repeat with lineItem in allLines
			set lineText to lineItem as string
			if lineText contains ":" then
				set keyValue to text items of lineText
				if (count of keyValue) ‚â• 2 then
					set keyName to item 1 of keyValue
					set valueText to item 2 of keyValue
					
					-- ‚úÖ USE EXISTING parseLocaleNumber FOR ALL NUMERIC CONVERSIONS
					if keyName contains "_sessionCount" or keyName contains "_totalContacts" then
						set numericValue to my parseLocaleNumber(valueText)
						my moduleLogDebug("Utilities", handlerName & "(): " & keyName & " = " & valueText & " ‚Üí " & numericValue)
						
						if keyName is "simulation_sessionCount" then
							set parsedHistory's simulationMode's sessionCount to numericValue as integer
						else if keyName is "simulation_totalContacts" then
							set parsedHistory's simulationMode's totalContacts to numericValue as integer
						else if keyName is "update_sessionCount" then
							set parsedHistory's updateMode's sessionCount to numericValue as integer
						else if keyName is "update_totalContacts" then
							set parsedHistory's updateMode's totalContacts to numericValue as integer
						end if
						
					else if keyName contains "_totalTime" or keyName contains "_avgSeconds" then
						-- ‚úÖ NEW: Handle scientific notation properly BEFORE parseLocaleNumber
						set cleanValueText to valueText
						set parsingMethod to "decimal"
						
						-- Convert scientific notation to decimal if present
						if valueText contains "E" or valueText contains "e" then
							set parsingMethod to "scientific"
							try
								-- Replace comma decimal separator with dot for AppleScript
								set cleanValueText to my replaceText(valueText, ",", ".")
								-- AppleScript can parse scientific notation directly
								set numericValue to cleanValueText as real
								my moduleLogDebug("Utilities", handlerName & "(): Parsed scientific notation " & valueText & " ‚Üí " & numericValue)
							on error sciErr
								my moduleLogWarning("Utilities", handlerName & "(): Could not parse scientific notation " & valueText & ": " & sciErr)
								-- Use fallback values
								if keyName contains "avgSeconds" then
									set numericValue to 0.05 -- 50ms per contact fallback
								else
									set numericValue to 0.0 -- Zero total time fallback
								end if
							end try
						else
							-- Regular decimal parsing
							set numericValue to my parseLocaleNumber(valueText)
						end if
						
						my moduleLogDebug("Utilities", handlerName & "(): " & keyName & " = " & valueText & " ‚Üí " & numericValue & " (" & parsingMethod & ")")
						
						-- ‚úÖ VALIDATION: Reject unrealistic time values (regardless of format)
						if numericValue > 86400 then -- More than 24 hours is suspicious
							my moduleLogWarning("Utilities", handlerName & "(): Unrealistic " & keyName & " value " & numericValue & "s (>24h), using fallback")
							if keyName contains "avgSeconds" then
								set numericValue to 0.05 -- 50ms per contact fallback
							else
								set numericValue to 0.0 -- Zero total time fallback
							end if
						end if
						
						if keyName is "simulation_totalTime" then
							set parsedHistory's simulationMode's totalProcessingTime to numericValue
						else if keyName is "simulation_avgSeconds" then
							set parsedHistory's simulationMode's avgSecondsPerContact to numericValue
						else if keyName is "update_totalTime" then
							set parsedHistory's updateMode's totalProcessingTime to numericValue
						else if keyName is "update_avgSeconds" then
							set parsedHistory's updateMode's avgSecondsPerContact to numericValue
						end if
						
					else if keyName is "maxSessionHistory" or keyName is "autoCleanupThreshold" then
						set numericValue to my parseLocaleNumber(valueText) as integer
						my moduleLogDebug("Utilities", handlerName & "(): " & keyName & " = " & valueText & " ‚Üí " & numericValue)
						
						if keyName is "maxSessionHistory" then
							set parsedHistory's maxSessionHistory to numericValue
						else if keyName is "autoCleanupThreshold" then
							set parsedHistory's autoCleanupThreshold to numericValue
						end if
						
					else
						-- Non-numeric fields (version, profile, etc.)
						if keyName is "version" then
							set parsedHistory's version to valueText
						else if keyName is "systemPerformanceProfile" then
							set parsedHistory's systemPerformanceProfile to valueText
						end if
					end if
				end if
			end if
		end repeat
		
		set AppleScript's text item delimiters to ASTID
		
		-- ‚úÖ FINAL VALIDATION: Ensure reasonable values
		if parsedHistory's simulationMode's avgSecondsPerContact > 10 then
			my moduleLogWarning("Utilities", handlerName & "(): Simulation avgSeconds too high, resetting to default")
			set parsedHistory's simulationMode's avgSecondsPerContact to 0.04
		end if
		
		if parsedHistory's updateMode's avgSecondsPerContact > 10 then
			my moduleLogWarning("Utilities", handlerName & "(): Update avgSeconds too high, resetting to default")
			set parsedHistory's updateMode's avgSecondsPerContact to 0.08
		end if
		
		my moduleLogInfo("Utilities", handlerName & "(): Successfully parsed performance data")
		return parsedHistory
		
	on error parseErr
		set AppleScript's text item delimiters to ASTID
		my moduleLogError("Utilities", handlerName & "(): Parse failed: " & parseErr)
		return defaultHistory
	end try
end parsePerformanceData

-------------------------------------------------------------------------------
-- Handler: calculateHybridEstimate
-- VERSION: 0.9.13-locale-fix (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Calculate hybrid time estimate using baseline and current session data
-- INPUTS:  baselineSeconds (real), currentSessionSeconds (real), contactsProcessed (integer), hasHistoricalData (boolean)
-- RETURNS: Real - Hybrid estimate in seconds per contact
-- NOTES:   Uses proper numeric inputs from parsePerformanceData(), no locale conversion needed
-- CHANGELOG:
--   ‚Ä¢ 0.9.13-locale-fix: Removed locale conversion (now handled upstream in parsePerformanceData)
--   ‚Ä¢ Simplified logic since inputs are guaranteed to be proper numbers
--   ‚Ä¢ Enhanced debug logging for calculation transparency
-------------------------------------------------------------------------------
on calculateHybridEstimate(baselineSeconds, currentSessionSeconds, contactsProcessed, hasHistoricalData)
	set handlerName to "calculateHybridEstimate"
	
	-- Validate numeric inputs (should be proper numbers from parsePerformanceData)
	if baselineSeconds ‚â§ 0 then set baselineSeconds to 0.04
	if currentSessionSeconds < 0 then set currentSessionSeconds to 0.0
	if contactsProcessed < 0 then set contactsProcessed to 0
	
	try
		my moduleLogDebug("Utilities", handlerName & "(): Calculating hybrid - baseline:" & baselineSeconds & "s, current:" & currentSessionSeconds & "s, progress:" & contactsProcessed & ", hasHistory:" & hasHistoricalData)
		
		-- Handle no historical data case
		if not hasHistoricalData then
			my moduleLogDebug("Utilities", handlerName & "(): No historical data available")
			if contactsProcessed < 3 then
				my moduleLogDebug("Utilities", handlerName & "(): Early session, no history - using baseline")
				return baselineSeconds
			else
				-- Use current session data if we have some progress
				my moduleLogDebug("Utilities", handlerName & "(): Using current session data: " & currentSessionSeconds & "s/contact")
				return currentSessionSeconds
			end if
		end if
		
		-- Handle very early in session (first few contacts)
		if contactsProcessed < 3 then
			my moduleLogDebug("Utilities", handlerName & "(): Very early session - 90% baseline weight")
			set hybridEstimate to baselineSeconds * 0.9 + currentSessionSeconds * 0.1
		else if contactsProcessed < 10 then
			my moduleLogDebug("Utilities", handlerName & "(): Early session - 70% baseline weight")
			set hybridEstimate to baselineSeconds * 0.7 + currentSessionSeconds * 0.3
		else if contactsProcessed < 25 then
			my moduleLogDebug("Utilities", handlerName & "(): Mid session - 50% baseline weight")
			set hybridEstimate to baselineSeconds * 0.5 + currentSessionSeconds * 0.5
		else
			my moduleLogDebug("Utilities", handlerName & "(): Late session - 30% baseline weight")
			set hybridEstimate to baselineSeconds * 0.3 + currentSessionSeconds * 0.7
		end if
		
		-- Handle current session having no data (division by zero protection)
		if currentSessionSeconds = 0.0 then
			my moduleLogDebug("Utilities", handlerName & "(): No current data - using baseline: " & baselineSeconds & "s/contact")
			return baselineSeconds
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Hybrid calculation result: " & hybridEstimate & "s/contact")
		return hybridEstimate
		
	on error calcErr
		my moduleLogError("Utilities", handlerName & "(): Calculation failed: " & calcErr)
		my moduleLogDebug("Utilities", handlerName & "(): Falling back to baseline: " & baselineSeconds)
		return baselineSeconds
	end try
end calculateHybridEstimate

-------------------------------------------------------------------------------
-- Handler: calculateiCloudOverhead
-- VERSION: 0.9.12 (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Calculate iCloud sync overhead multiplier based on batch size
-- INPUTS:  contactCount (integer) - Total number of contacts being processed
-- RETURNS: Real - Overhead multiplier (1.0 = no overhead, >1.0 = slower)
-- NOTES:   Accounts for iCloud sync delays that increase with batch size
-- DEPENDENCIES: Existing logging system
-------------------------------------------------------------------------------
on calculateiCloudOverhead(contactCount)
	set handlerName to "calculateiCloudOverhead"
	
	-- Validate input
	if contactCount ‚â§ 0 then
		my moduleLogWarning("Utilities", handlerName & "(): Invalid contact count: " & contactCount)
		return 1.0
	end if
	
	try
		my moduleLogDebug("Utilities", handlerName & "(): Calculating iCloud overhead for " & contactCount & " contacts")
		
		-- Progressive overhead based on batch size
		-- Larger batches create more iCloud sync contention
		set overhead to 1.0
		
		if contactCount ‚â§ 50 then
			-- Small batches: minimal overhead
			set overhead to 1.1 -- 10% slower than simulation
			my moduleLogDebug("Utilities", handlerName & "(): Small batch overhead: " & overhead & "x")
		else if contactCount ‚â§ 200 then
			-- Medium batches: moderate overhead
			set overhead to 1.3 -- 30% slower
			my moduleLogDebug("Utilities", handlerName & "(): Medium batch overhead: " & overhead & "x")
		else if contactCount ‚â§ 1000 then
			-- Large batches: significant overhead
			set overhead to 1.5 -- 50% slower
			my moduleLogDebug("Utilities", handlerName & "(): Large batch overhead: " & overhead & "x")
		else if contactCount ‚â§ 5000 then
			-- Very large batches: substantial overhead
			set overhead to 1.7 -- 70% slower
			my moduleLogDebug("Utilities", handlerName & "(): Very large batch overhead: " & overhead & "x")
		else
			-- Massive batches: maximum overhead
			set overhead to 2.0 -- 100% slower (double the time)
			my moduleLogDebug("Utilities", handlerName & "(): Massive batch overhead: " & overhead & "x")
		end if
		
		return overhead
		
	on error overheadErr
		my moduleLogError("Utilities", handlerName & "(): Calculation failed: " & overheadErr)
		return 1.2 -- Conservative fallback
	end try
end calculateiCloudOverhead

-------------------------------------------------------------------------------
-- Handler: applyBatchSizeScaling
-- VERSION: 0.9.13-locale-fix (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Apply batch size scaling to base processing time estimate
-- INPUTS:  baseTimePerContact (real), totalContacts (integer)
-- RETURNS: Real - Scaled time per contact in seconds
-- NOTES:   Enhanced with input validation, uses proper numeric types
-- CHANGELOG:
--   ‚Ä¢ 0.9.13-locale-fix: Added input validation and type safety
--   ‚Ä¢ Simplified logic since inputs are guaranteed to be proper numbers
--   ‚Ä¢ Enhanced logging for scaling transparency
-------------------------------------------------------------------------------
on applyBatchSizeScaling(baseTimePerContact, totalContacts)
	set handlerName to "applyBatchSizeScaling"
	
	-- ‚úÖ INPUT VALIDATION
	try
		set baseTime to baseTimePerContact as real
		set contactCount to totalContacts as integer
		
		if baseTime ‚â§ 0 then set baseTime to 0.04
		if contactCount ‚â§ 0 then set contactCount to 1
	on error inputErr
		my moduleLogError("Utilities", handlerName & "(): Input validation failed: " & inputErr)
		return 0.04
	end try
	
	my moduleLogDebug("Utilities", handlerName & "(): Applying batch scaling - base:" & baseTime & "s, count:" & contactCount)
	
	try
		-- Apply scaling based on batch size
		if contactCount < 100 then
			my moduleLogDebug("Utilities", handlerName & "(): Small batch - no scaling")
			set scaledTime to baseTime
		else if contactCount < 500 then
			my moduleLogDebug("Utilities", handlerName & "(): Medium batch - 5% efficiency gain")
			set scaledTime to baseTime * 0.95
		else if contactCount < 2000 then
			my moduleLogDebug("Utilities", handlerName & "(): Large batch - 10% efficiency gain")
			set scaledTime to baseTime * 0.9
		else
			my moduleLogDebug("Utilities", handlerName & "(): Very large batch - 15% efficiency gain")
			set scaledTime to baseTime * 0.85
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Scaled time: " & scaledTime & "s/contact")
		return scaledTime
		
	on error scaleErr
		my moduleLogError("Utilities", handlerName & "(): Scaling failed: " & scaleErr)
		return baseTime
	end try
end applyBatchSizeScaling

-------------------------------------------------------------------------------
-- Handler: addToRollingWindow
-- VERSION: 0.9.12 (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Maintain rolling window of recent session records with automatic cleanup
-- INPUTS:  sessionList (list) - Current list of session records
--          newSession (record) - New session record to add
--          maxSize (integer) - Maximum number of sessions to keep
-- RETURNS: List - Updated session list with new record, oldest removed if needed
-- NOTES:   Maintains chronological order, prevents unbounded growth of session history
-- DEPENDENCIES: Existing logging system
-------------------------------------------------------------------------------
on addToRollingWindow(sessionList, newSession, maxSize)
	set handlerName to "addToRollingWindow"
	
	-- Validate inputs
	if maxSize ‚â§ 0 then
		my moduleLogWarning("Utilities", handlerName & "(): Invalid max size: " & maxSize)
		return {}
	end if
	
	if newSession is missing value then
		my moduleLogWarning("Utilities", handlerName & "(): New session is missing value")
		return sessionList
	end if
	
	try
		-- Handle missing or invalid session list
		set workingList to {}
		if sessionList is not missing value then
			try
				set workingList to sessionList as list
			on error
				my moduleLogWarning("Utilities", handlerName & "(): Could not coerce session list, starting fresh")
				set workingList to {}
			end try
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Adding session to window - current size: " & (count of workingList) & ", max: " & maxSize)
		
		-- Add new session to end of list (most recent)
		set end of workingList to newSession
		
		-- Trim to maximum size if needed (remove oldest from beginning)
		set currentSize to count of workingList
		if currentSize > maxSize then
			set sessionsToRemove to currentSize - maxSize
			my moduleLogDebug("Utilities", handlerName & "(): Trimming " & sessionsToRemove & " old sessions")
			
			-- Create new list with only the most recent sessions
			set trimmedList to {}
			repeat with i from (sessionsToRemove + 1) to currentSize
				set end of trimmedList to item i of workingList
			end repeat
			set workingList to trimmedList
		end if
		
		my moduleLogDebug("Utilities", handlerName & "(): Rolling window updated - final size: " & (count of workingList))
		return workingList
		
	on error windowErr
		my moduleLogError("Utilities", handlerName & "(): Rolling window update failed: " & windowErr)
		-- Return original list or at least the new session
		try
			if sessionList is not missing value then
				return sessionList
			else
				return {newSession}
			end if
		on error
			return {}
		end try
	end try
end addToRollingWindow

-------------------------------------------------------------------------------
-- Handler: calculatePerformanceProfile
-- VERSION: 0.9.12 (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Analyze recent session performance to determine system performance profile
-- INPUTS:  recentSessions (list) - List of recent session records
-- RETURNS: Text - Performance profile: "Fast", "Medium", "Slow", or "Unknown"
-- NOTES:   Analyzes contacts/second rates to classify system performance characteristics
-- DEPENDENCIES: Existing logging system
-------------------------------------------------------------------------------
on calculatePerformanceProfile(recentSessions)
	set handlerName to "calculatePerformanceProfile"
	
	-- Validate input
	if recentSessions is missing value then
		my moduleLogDebug("Utilities", handlerName & "(): No session data provided")
		return "Unknown"
	end if
	
	try
		set sessionCount to count of recentSessions
		my moduleLogDebug("Utilities", handlerName & "(): Analyzing " & sessionCount & " recent sessions")
		
		if sessionCount = 0 then
			my moduleLogDebug("Utilities", handlerName & "(): No sessions to analyze")
			return "Unknown"
		end if
		
		-- Need at least 3 sessions for reliable profiling
		if sessionCount < 3 then
			my moduleLogDebug("Utilities", handlerName & "(): Insufficient sessions (" & sessionCount & ") for profiling")
			return "Unknown"
		end if
		
		-- Calculate average contacts per second from recent sessions
		set totalRate to 0
		set validSessions to 0
		
		repeat with sessionRecord in recentSessions
			try
				-- Extract rate from session record
				set sessionRate to sessionRecord's contactsPerSecond
				if sessionRate > 0 then
					set totalRate to totalRate + sessionRate
					set validSessions to validSessions + 1
				end if
			on error sessionErr
				my moduleLogDebug("Utilities", handlerName & "(): Could not extract rate from session: " & sessionErr)
			end try
		end repeat
		
		if validSessions = 0 then
			my moduleLogWarning("Utilities", handlerName & "(): No valid session rates found")
			return "Unknown"
		end if
		
		set avgRate to totalRate / validSessions
		my moduleLogDebug("Utilities", handlerName & "(): Average rate: " & ((round (avgRate * 100)) / 100) & " contacts/sec from " & validSessions & " sessions")
		
		-- Classify performance based on average rate
		set profile to "Unknown"
		
		if avgRate ‚â• 30 then
			-- Very fast systems: Modern Macs, fast SSDs
			set profile to "Fast"
			my moduleLogDebug("Utilities", handlerName & "(): Fast system profile (‚â•30 contacts/sec)")
		else if avgRate ‚â• 15 then
			-- Good performance: Recent Macs, decent hardware
			set profile to "Medium"
			my moduleLogDebug("Utilities", handlerName & "(): Medium system profile (15-29 contacts/sec)")
		else if avgRate ‚â• 5 then
			-- Slower systems: Older Macs, slower storage
			set profile to "Slow"
			my moduleLogDebug("Utilities", handlerName & "(): Slow system profile (5-14 contacts/sec)")
		else
			-- Very slow: Network issues, very old hardware, or system problems
			set profile to "Slow"
			my moduleLogWarning("Utilities", handlerName & "(): Very slow performance detected (<5 contacts/sec) - may indicate system issues")
		end if
		
		my moduleLogInfo("Utilities", handlerName & "(): System performance profile: " & profile & " (" & ((round (avgRate * 10)) / 10) & " contacts/sec)")
		return profile
		
	on error profileErr
		my moduleLogError("Utilities", handlerName & "(): Profile calculation failed: " & profileErr)
		return "Unknown"
	end try
end calculatePerformanceProfile

-------------------------------------------------------------------------------
-- Handler: cleanupOldSessions
-- VERSION: 0.9.12 (2025-06-25)
-- AUTHOR: Philippe Dewost + Claude/Anthropic
-- PURPOSE: Clean up old session records to prevent unbounded performance history growth
-- INPUTS:  sessionList (list) - Current list of session records
--          maxKeep (integer) - Maximum number of recent sessions to keep
-- RETURNS: List - Cleaned session list with only most recent sessions
-- NOTES:   Keeps most recent sessions, removes oldest ones, maintains chronological order
-- DEPENDENCIES: Existing logging system
-------------------------------------------------------------------------------
on cleanupOldSessions(sessionList, maxKeep)
	set handlerName to "cleanupOldSessions"
	
	-- Validate inputs
	if maxKeep ‚â§ 0 then
		my moduleLogWarning("Utilities", handlerName & "(): Invalid maxKeep: " & maxKeep)
		return {}
	end if
	
	if sessionList is missing value then
		my moduleLogDebug("Utilities", handlerName & "(): No session list provided")
		return {}
	end if
	
	try
		set currentCount to count of sessionList
		my moduleLogDebug("Utilities", handlerName & "(): Cleaning session list - current: " & currentCount & ", max: " & maxKeep)
		
		-- If already within limits, no cleanup needed
		if currentCount ‚â§ maxKeep then
			my moduleLogDebug("Utilities", handlerName & "(): No cleanup needed")
			return sessionList
		end if
		
		-- Calculate how many sessions to remove
		set sessionsToRemove to currentCount - maxKeep
		my moduleLogInfo("Utilities", handlerName & "(): Removing " & sessionsToRemove & " old sessions (keeping " & maxKeep & " most recent)")
		
		-- Create new list with only the most recent sessions
		-- Assumes sessions are in chronological order (oldest first, newest last)
		set cleanedList to {}
		repeat with i from (sessionsToRemove + 1) to currentCount
			try
				set end of cleanedList to item i of sessionList
			on error itemErr
				my moduleLogWarning("Utilities", handlerName & "(): Could not copy session " & i & ": " & itemErr)
			end try
		end repeat
		
		set finalCount to count of cleanedList
		my moduleLogDebug("Utilities", handlerName & "(): Cleanup complete - final count: " & finalCount)
		
		-- Verify we kept the right number
		if finalCount > maxKeep then
			my moduleLogWarning("Utilities", handlerName & "(): Cleanup verification failed - expected ‚â§" & maxKeep & ", got " & finalCount)
		end if
		
		return cleanedList
		
	on error cleanupErr
		my moduleLogError("Utilities", handlerName & "(): Cleanup failed: " & cleanupErr)
		-- Return original list as fallback
		try
			return sessionList
		on error
			return {}
		end try
	end try
end cleanupOldSessions

-- ==============================================
-- DATE FORMATTING FUNCTIONS 
-- ==============================================

on formatDateHumanReadable(theDate)
	-- Get date components
	set y to year of theDate as integer
	set m to month of theDate as integer
	set d to day of theDate as integer
	set hh to hours of theDate as integer
	set mm to minutes of theDate as integer
	
	-- Month names
	set monthNames to {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
	set monthName to item m of monthNames
	
	-- Format: "June 10, 2025 17h 52"
	return monthName & " " & d & ", " & y & " " & hh & "h" & mm
end formatDateHumanReadable

-- Convert system date strings to human readable format
on convertSystemDateToHuman(systemDateString)
	try
		-- Parse system format like "2025-6-6 10:25:17"
		set AppleScript's text item delimiters to " "
		set dateParts to text items of systemDateString
		if (count of dateParts) ‚â• 2 then
			set datePart to item 1 of dateParts
			set timePart to item 2 of dateParts
			
			-- Parse date part "2025-6-6"
			set AppleScript's text item delimiters to "-"
			set dateComponents to text items of datePart
			if (count of dateComponents) = 3 then
				set y to item 1 of dateComponents as integer
				set m to item 2 of dateComponents as integer
				set d to item 3 of dateComponents as integer
				
				-- Parse time part "10:25:17"
				set AppleScript's text item delimiters to ":"
				set timeComponents to text items of timePart
				if (count of timeComponents) ‚â• 2 then
					set hh to item 1 of timeComponents as integer
					set mm to item 2 of timeComponents as integer
					
					-- Convert to human format
					set monthNames to {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"}
					set monthName to item m of monthNames
					
					set AppleScript's text item delimiters to ""
					return monthName & " " & d & ", " & y & " " & hh & "h " & mm
				end if
			end if
		end if
		
		-- Fallback if parsing fails
		set AppleScript's text item delimiters to ""
		return systemDateString
		
	on error
		set AppleScript's text item delimiters to ""
		return systemDateString
	end try
end convertSystemDateToHuman

-- ============================================
-- Handler: getISOTimestamp
-- VERSION: 0.9.9 (2025-06-16)
-- PURPOSE: Returns the current date/time as YYYY-MM-DD hh:mm:ss (ISO 8601)
-- INPUTS:  dateObj (date), optional (defaults to current date)
-- RETURNS: text
-- ============================================
on getISOTimestamp(optionalDate)
	try
		if optionalDate is missing value then
			set theDate to (current date)
		else if class of optionalDate is date then
			set theDate to optionalDate
		else if class of optionalDate is text then
			-- fallback: return the string, don't try to extract fields
			return optionalDate
		else
			return "unknown-date"
		end if
		set y to year of theDate as string
		set m to text -2 thru -1 of ("0" & (month of theDate as integer))
		set d to text -2 thru -1 of ("0" & (day of theDate as string))
		set h to text -2 thru -1 of ("0" & (hours of theDate as string))
		set min to text -2 thru -1 of ("0" & (minutes of theDate as string))
		set s to text -2 thru -1 of ("0" & (seconds of theDate as string))
		return y & "-" & m & "-" & d & " " & h & ":" & min & ":" & s
	on error
		return "unknown-date"
	end try
end getISOTimestamp

on systemDateString(theDate)
	set y to year of theDate as string
	set m to text -2 thru -1 of ("0" & (month of theDate as integer))
	set d to text -2 thru -1 of ("0" & (day of theDate as integer))
	set h to text -2 thru -1 of ("0" & (hours of theDate as integer))
	set min to text -2 thru -1 of ("0" & (minutes of theDate as integer))
	set s to text -2 thru -1 of ("0" & (seconds of theDate as integer))
	return y & "-" & m & "-" & d & " " & h & ":" & min & ":" & s
end systemDateString

-- ============================================
--  processCrossParagraphDedupe(txt) ‚Üí text
--
--  Splits txt on blank lines (double-LF), then collapses any pair of
--  consecutive paragraphs whose ‚Äúnormalized‚Äù content (all LFs ‚Üí spaces,
--  trimmed) is identical. Reassembles with double-LF.
-- ============================================
on processCrossParagraphDedupe(txt as text)
	set oldTID to AppleScript's text item delimiters
	set AppleScript's text item delimiters to linefeed & linefeed
	set paraList to text items of txt
	
	set cleanedParas to {}
	set prevNorm to ""
	repeat with p in paraList
		set thisPara to p as text
		-- normalize: replace LFs with spaces, then trim
		set flat to replaceText(thisPara, linefeed, " ")
		set norm to trimWhitespace(flat)
		if norm ‚â† prevNorm then
			copy thisPara to end of cleanedParas
			set prevNorm to norm
		end if
	end repeat
	
	set AppleScript's text item delimiters to linefeed & linefeed
	set resultText to cleanedParas as text
	
	set AppleScript's text item delimiters to oldTID
	return resultText
end processCrossParagraphDedupe

-------------------------------------------------------------------------------
-- computeReductionMetrics(charsRemoved, originalLength) ‚Üí {kb:real, pct:real}
-- Returns KB removed and percent reduction (0‚Äì100).
-- Pure function, no side-effects.
-------------------------------------------------------------------------------
on computeReductionMetrics(charsRemoved, originalLength)
	-- KB reduction
	set kb to 0
	if charsRemoved > 0 then set kb to (charsRemoved / 1024.0)
	-- Percent reduction
	set pct to 0
	if originalLength > 0 then set pct to (charsRemoved / originalLength) * 100
	return {kb:kb, pct:pct}
end computeReductionMetrics



-- ==============================================
-- TESTING - run handler 
-- ==============================================

on run
	my logSelfTest()
	
	initializeModule()
	
	-- Test backup functions
	log "Testing backup functions..."
	
	-- 1. Test createVersionedBackup
	set testEntity to "TestContact"
	set testContent to "This is test content for backup testing."
	set backupResult to createVersionedBackup(testEntity, testContent, "test")
	
	if backupResult's success then
		log "‚úÖ createVersionedBackup test passed: " & backupResult's path
		
		-- 2. Test findLatestBackup
		set latestBackup to findLatestBackup(testEntity, "test")
		if latestBackup is not "" then
			log "‚úÖ findLatestBackup test passed: " & latestBackup
			
			-- 3. Test extractContentFromBackup
			set extractedContent to extractContentFromBackup(latestBackup)
			if extractedContent is equal to testContent then
				log "‚úÖ extractContentFromBackup test passed"
			else
				log "‚ùå extractContentFromBackup test failed: Content mismatch"
				log "Expected: " & testContent
				log "Got: " & extractedContent
			end if
		else
			log "‚ùå findLatestBackup test failed: No backup found"
		end if
		
		-- 4. Test listBackupEntities
		set entities to listBackupEntities("test")
		if (count of entities) > 0 then
			log "‚úÖ listBackupEntities test passed: Found " & (count of entities) & " entities"
		else
			log "‚ùå listBackupEntities test failed: No entities found"
		end if
		
		-- 5. Test listBackupVersions
		set versions to listBackupVersions(testEntity, "test")
		if (count of versions) > 0 then
			log "‚úÖ listBackupVersions test passed: Found " & (count of versions) & " versions"
		else
			log "‚ùå listBackupVersions test failed: No versions found"
		end if
		
		-- 6. Test manageBackupRetention
		-- Create a few more backups first to have something to clean up
		repeat with i from 1 to 3
			set extraContent to "Extra backup content #" & i
			createVersionedBackup(testEntity, extraContent, "test")
			delay 1 -- Add a small delay to ensure different timestamps
		end repeat
		
		-- Now clean up, keeping only 2 newest
		set retentionResult to manageBackupRetention(testEntity, "test", 2)
		if retentionResult's success then
			log "‚úÖ manageBackupRetention test passed: " & retentionResult's reason
		else
			log "‚ùå manageBackupRetention test failed: " & retentionResult's reason
		end if
	else
		log "‚ùå createVersionedBackup test failed: " & backupResult's errorMessage
	end if
	
	log "Utilities module tests completed."
	return "Utilities module with enhanced backup functions tested successfully."
end run

------------------------------------------------------------
--  logSelfTest()  ‚Ä¢ quick sanity check for the logger
--  Emits INFO ‚Üí ERROR (triggers escalation) ‚Üí DEBUG
------------------------------------------------------------
on logSelfTest()
	set originalLevel to logLevel
	
	my moduleLogInfo("SelfTest", "INFO line ‚Äì should always appear")
	my moduleLogError("SelfTest", "ERROR line ‚Äì escalates to DEBUG")
	my moduleLogDebug("SelfTest", "DEBUG line ‚Äì visible only if escalation worked")
	
	-- restore
	my setLogLevel(originalLevel)
end logSelfTest

on _format(theModule, theMessage, theLevel)
	set {emoji, label} to {"‚ÑπÔ∏è", "INFO"}
	if theLevel = kLogLevelError then set {emoji, label} to {"üî¥", "ERROR"}
	if theLevel = kLogLevelDebug then set {emoji, label} to {"üîç", "DEBUG"}
	set ts to do shell script "date '+%Y-%m-%d %H:%M:%S'"
	return ts & space & emoji & space & "[" & theModule & "] " & label & ": " & theMessage
end _format






